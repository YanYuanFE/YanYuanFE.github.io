{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceCodePro.woff2","path":"fonts/SourceCodePro.woff2","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/favicon.png","path":"css/images/favicon.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"05139ec0c571b7f7bc4e21ef47061a54e4d727ae","modified":1644068346385},{"_id":"themes/vexo/.DS_Store","hash":"1cba14f806cdcc02aa4f3381467696614ef6a60a","modified":1644068386891},{"_id":"themes/vexo/LICENSE","hash":"3e135cd69c0e02c0a49dd43d571f600223cc61d1","modified":1594907807912},{"_id":"themes/vexo/README.md","hash":"036ddc66e868b93411a15ed3fd5ed5e9101045a5","modified":1594907807912},{"_id":"themes/vexo/_config.yml","hash":"8665a0208d7fdc806b47bf4767cb3541b59e1eb5","modified":1619275577485},{"_id":"themes/vexo/lint.sh","hash":"f580302e4aa9ccfb95a253851da6501d145613fe","modified":1594907807918},{"_id":"themes/vexo/package.json","hash":"8852c5a394ac59d219e5bbbcee10d573d33e1fc6","modified":1594907807918},{"_id":"source/_posts/CSS3实现文字流光渐变动画.md","hash":"9486d528baf64ba72df2f5f680c38c15c61a4982","modified":1594907807872},{"_id":"source/_posts/CSS学习笔记之获取元素CSS方法.md","hash":"b92ecb40a9875a31a3ab93c156cc64e2c89ee75f","modified":1594907807872},{"_id":"source/_posts/JavaScript排序算法之选择排序和插入排序.md","hash":"c0ff88ef309f936ddd57e33229a5a0372c106787","modified":1594907807873},{"_id":"source/_posts/React Native 封装HTTP请求.md","hash":"b1c726692fea8c966d46cd1eb2815d58c126faba","modified":1594907807873},{"_id":"source/_posts/React Router V4 学习笔记.md","hash":"a299a39ff8f293dfd320bc5834e03af7bc0b8a57","modified":1594907807873},{"_id":"source/_posts/Redux实现简单计数器.md","hash":"ddc74ce20c915991d0b54aaf1f341286ee66a3a0","modified":1594907807873},{"_id":"source/_posts/Webpack之打包体积优化.md","hash":"c8954f0c30df4315e6801fb30a372bf6d322f082","modified":1594907807874},{"_id":"source/_posts/Ubuntu下搭建前端开发环境和常用工具.md","hash":"76cb3122ebd9183ccdb09b23ae7083354f17ddf2","modified":1594907807873},{"_id":"source/_posts/hello-world.md","hash":"e843158e2979693b1f4d2e7c482eb904bae2e4e1","modified":1594907807874},{"_id":"source/_posts/Webpack之构建速度优化.md","hash":"078ece72f3969c6fd209039689a0933ae952ef87","modified":1594907807874},{"_id":"source/_posts/Webpack5升级指南.md","hash":"f61917116f8de3e7839fd9ef2c11fcab06931f77","modified":1606316894340},{"_id":"source/_posts/react-redux开发简单的to do应用.md","hash":"1e5bfeab44cfe2700f2f9288857ee60b44de8013","modified":1594907807874},{"_id":"source/_posts/你不知道的CSS-一.md","hash":"0f7b505cc4eb1d4ae2d09fcd362b6d1c56053385","modified":1594907807874},{"_id":"source/_posts/使用webpack4和react-router 4实现代码分割.md","hash":"18a30650f7bafa624c3e25da8398071f4d297635","modified":1594907807874},{"_id":"source/_posts/关于一道字符串格式化面试题的思考.md","hash":"3c0547a0ed6f336eb201df6ced43ecaffdb16957","modified":1594907807875},{"_id":"source/_posts/初识Node-js.md","hash":"ae23500cdc4a142d6e2c4ac41e0e92a9c112e4e7","modified":1594907807875},{"_id":"source/_posts/前端代码规范工程化实践指南.md","hash":"a19656e372622ec25e2ad53de151d4b217aceaf9","modified":1594907807875},{"_id":"source/_posts/基于HTML5实现跨文档通信.md","hash":"36a3eae44b77d7c5cf7f59951ded6271337d490c","modified":1594907807875},{"_id":"source/_posts/在React和TypeScript中使用emotion.md","hash":"7a324e9669041c9429def4f7421b12e0928b4769","modified":1614871251835},{"_id":"source/_posts/微信网页授权功能开发总结.md","hash":"bfa52cf123d597875cfb32b20ba62f047f01c424","modified":1594907807876},{"_id":"source/_posts/我和这个世界不熟.md","hash":"aa0862c9899677ed49c3f267e7d529e9616616c0","modified":1594907807876},{"_id":"source/_posts/我的第一个博客，Hexo强力驱动.md","hash":"5ad6aad055c3fc6077b525aa10d2a7335e0a1cf3","modified":1594907807876},{"_id":"source/_posts/手摸手撸一个简单的Redux（一）.md","hash":"0c0649a7b59c3f06fc8424876abcd34f31cf098c","modified":1594907807876},{"_id":"source/_posts/手摸手撸一个简单的Redux（二）.md","hash":"9b7020822f9d034b85e254991277dd76ce07750a","modified":1594907807877},{"_id":"source/_posts/手摸手撸一个简单的Redux（四）.md","hash":"4130c1784dc383880efe466e97b54d9ce748e9d3","modified":1594907807877},{"_id":"source/_posts/手摸手撸一个简单的Redux（三）.md","hash":"7a5188ea1f652c5f0714b49b07caeeb830ceba7b","modified":1594907807876},{"_id":"source/_posts/手摸手撸一个简单的Redux（五）.md","hash":"63a625326df74a87d0f4fb645b7f35866024b915","modified":1594907807877},{"_id":"source/_posts/正则表达式必知必会.md","hash":"986eb415bae463b0620d0bd456f6f1b76659bd34","modified":1594907807877},{"_id":"source/_posts/浅析HTTP缓存.md","hash":"1f70886e9e7ce3e46d2ed026d03919aeb2d3a443","modified":1594907807877},{"_id":"source/_posts/深入理解JavaScript之this.md","hash":"5d29b13c7ad37a83761fd3508d6c098feb0163e2","modified":1594907807878},{"_id":"source/_posts/深入理解JavaScript之克隆.md","hash":"2420e430ba85c546bda7d83e3a8e2a279f93eefb","modified":1594907807878},{"_id":"source/_posts/深入理解JavaScript之变量提升.md","hash":"257a6533447a677491fba84a6354191a310e96d3","modified":1594907807878},{"_id":"source/_posts/深拷贝探秘.md","hash":"03146b0ac433cb68236ecf07bfece896eb09be95","modified":1594907807878},{"_id":"source/_posts/理解ES6之箭头函数.md","hash":"22ba2eeae661d16a441bc52169a1340a61670d48","modified":1594907807879},{"_id":"source/_posts/理解React组件生命周期.md","hash":"9cb4da40d733413a555ac82660f71fc45d6a48fa","modified":1594907807879},{"_id":"source/_posts/理解Redux.md","hash":"d694beb572c96635d3a781d221f42e548e4ed92d","modified":1594907807879},{"_id":"source/_posts/移动端H5调试工具指南.md","hash":"eecb0034fe99edd95d1888c962dd72587004ad7e","modified":1606316687581},{"_id":"source/_posts/编写高性能React代码的原则.md","hash":"974e284ed295e40b04a0cefee15aea610a3ae4fe","modified":1594907807880},{"_id":"source/_posts/谈谈React中的组件.md","hash":"7851778313f5777117a59806d7a338abf6653df4","modified":1594907807880},{"_id":"source/_posts/自定义Hook在React中的实践.md","hash":"22a3349e44282f061bd218ce61d49336a54308a3","modified":1601388630043},{"_id":"source/_posts/聊聊Vue组件通信方式.md","hash":"e06a6508ad558670dc204fda1db55410074e2b30","modified":1594909045997},{"_id":"source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1594907807880},{"_id":"source/_posts/读《前端架构设计》——我眼中的前端架构.md","hash":"f9329253620c64bff7191fc16c492d5ad2708ae4","modified":1594907807880},{"_id":"source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1594907807881},{"_id":"source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1594907807881},{"_id":"themes/vexo/layout/about.ejs","hash":"c8da38fdb6307c406af3e656fc9e219f9e5a4139","modified":1594907807916},{"_id":"themes/vexo/layout/archive.ejs","hash":"cb12abb19cb70e90d410a6233933eedb3f2c033a","modified":1594907807917},{"_id":"themes/vexo/layout/index.ejs","hash":"9f12f5928d68d4d68175b825e18f89f3b0dfdb69","modified":1594907807917},{"_id":"themes/vexo/layout/layout.ejs","hash":"a7b8f1debdca12d667ecd1bcc3d4bc6e13a23d7b","modified":1594907807917},{"_id":"themes/vexo/layout/page.ejs","hash":"a886fb7e8a9d70bc971b6dfc7210d4fa2ee671c9","modified":1594907807917},{"_id":"themes/vexo/layout/project.ejs","hash":"666be5c72bac8165e0946428642b36dd3232983e","modified":1594907807918},{"_id":"themes/vexo/layout/tags.ejs","hash":"5b326e2bd3292b3015d0666b796544d7126acfda","modified":1594907807918},{"_id":"themes/vexo/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1594907807913},{"_id":"themes/vexo/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1594907807913},{"_id":"themes/vexo/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1594907807913},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1594907807914},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"2060923729fb394e76d72334ffd505d685ccfe53","modified":1594907807915},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"0352ce39c28074dcfc3bd6416680195eeb384fd1","modified":1594907807914},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"6032a4dcc6224ad916b7898d54e91552c17396ce","modified":1594907807914},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"e544f516b23bc609cc6367190f380c879b935c21","modified":1594907807915},{"_id":"themes/vexo/layout/_partial/nav.ejs","hash":"3d8ddc1f6e135a240d40edd157cf37f5d0a12df6","modified":1594907807915},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"5d2a2c3f8ca7000945ab426a0c6939421974b224","modified":1594907807916},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"3a1b9680fbfa3baa76933c7c17216996381ad241","modified":1594907807915},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1594907807916},{"_id":"themes/vexo/layout/_third-party/mathjax.ejs","hash":"aa58f0cfe22e7151c1a0521bbfa5cbd76f6dcd9d","modified":1594907807916},{"_id":"themes/vexo/source/css/_config.styl","hash":"d1a2c1d9772c66c62ed37be862c043946435a48c","modified":1619275577486},{"_id":"themes/vexo/source/css/style.styl","hash":"2cd66b0961f004f5582f2208727f730fcbeb0d77","modified":1594907807926},{"_id":"themes/vexo/source/fonts/SourceCodePro.woff2","hash":"67c9510c17e34c0de970997171214696ee6b27c6","modified":1594907807926},{"_id":"themes/vexo/source/js/script.js","hash":"19c6ac9c1d8220fa9ab2ec461c17eaae3bc962d7","modified":1594907807930},{"_id":"themes/vexo/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1594907807929},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"daf87833ee4923615a67f7893d5ed5abf1ca5e00","modified":1594907807919},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"e80ddf26f2af3523632afeabd57f81592537985a","modified":1594907807919},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"cbf3f59d3c3162700eb9cbd4cf72c8470c170f81","modified":1594907807920},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"def3a6938d925c585a7da6256a6f2e90f3b7d61e","modified":1594907807920},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"901c7ee7be2df498d8f4d76dbd9e875769a66206","modified":1619275577486},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"970b6fd3d05834926c69724934b798dd5a1472e6","modified":1594907807920},{"_id":"themes/vexo/source/css/_partial/nav.styl","hash":"e92c010c5cd460e75c67083df8cdd0bf4d25cde4","modified":1594907807921},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1594907807921},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"e9b6faadf4852bce3a4141cba0a102a7afb81e9f","modified":1594907807921},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1594907807922},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1594907807923},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1594907807923},{"_id":"themes/vexo/source/css/images/favicon.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1594907807923},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1594907807924},{"_id":"themes/vexo/source/css/images/logo.png","hash":"1d6ffbfe73a830ae6a777953a16606d45cc26ce4","modified":1594907807924},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1594907807924},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1594907807926},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1594907807928},{"_id":"themes/vexo/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1594907807929},{"_id":"themes/vexo/source/css/images/alipay.jpg","hash":"613dcfceacd4b193b0b52c2b8515ee7339dabb3d","modified":1594907807923},{"_id":"themes/vexo/source/css/images/wechat.jpg","hash":"98802457b2ef94e8d8a597a723283e2725b2c768","modified":1594907807925},{"_id":"public/CNAME","hash":"b3db96b8b1971c9db3daff538a2efe6f91229257","modified":1653710288110},{"_id":"public/about/index.html","hash":"66cc25755de4fc1dd36eb5efd7c1175ba1dd2564","modified":1653710288864},{"_id":"public/project/index.html","hash":"61fd45f88921b4b60b9e4b0b623071bb4fff9b9b","modified":1653710288865},{"_id":"public/2018/02/06/理解Redux/index.html","hash":"b061e720d3d3e84671fd816c8e59fae043c8cd1b","modified":1653710288865},{"_id":"public/2016/10/04/我和这个世界不熟/index.html","hash":"b2811a3b5abaa67de1755a3f76fde5abd2f018d5","modified":1653710288865},{"_id":"public/2016/07/03/我的第一个博客，Hexo强力驱动/index.html","hash":"83dd4ac5db25ec515a7e9019e58392949581ca3c","modified":1653710288865},{"_id":"public/2016/07/01/hello-world/index.html","hash":"90ef198ecc91a93faeb2a01f432a3d076673dfad","modified":1653710288865},{"_id":"public/archives/index.html","hash":"cece58e5b6e98fcc165ded7d8ed101e2df7ff107","modified":1653710288865},{"_id":"public/archives/page/2/index.html","hash":"1b3f81e8aa744ddbd741a8dbd288244959719e42","modified":1653710288865},{"_id":"public/archives/page/3/index.html","hash":"82dbfd2298e0069cc314b7f798669051efe933ca","modified":1653710288866},{"_id":"public/archives/page/4/index.html","hash":"83376442c7d61d8e4849b3149be6e5ab36b138d5","modified":1653710288866},{"_id":"public/archives/page/5/index.html","hash":"b5ab381c6124bdeff3e3d6e08b2e675159fe829c","modified":1653710288866},{"_id":"public/archives/page/6/index.html","hash":"7d0fb2ecb9f18b5f78fa7b936ac74d4707f0f0a8","modified":1653710288866},{"_id":"public/archives/page/7/index.html","hash":"ee1e921e3e5b6afb385814dfb4905fd6243baeb5","modified":1653710288866},{"_id":"public/archives/page/8/index.html","hash":"17ebdcfb9f2028116198d5e8584fbc7e56d06246","modified":1653710288866},{"_id":"public/archives/page/9/index.html","hash":"9f307832c17303eb6126d4c74e351dbe27cc5544","modified":1653710288866},{"_id":"public/archives/2016/index.html","hash":"bd750cd4aecc564efb6769ac2acd56f192fa7b33","modified":1653710288866},{"_id":"public/archives/2016/page/2/index.html","hash":"434706dd8af69ae04410548741cd5432427294c6","modified":1653710288866},{"_id":"public/archives/2016/07/index.html","hash":"0a05c70926765f4bd28c9c7bb03d6eb2abc35025","modified":1653710288866},{"_id":"public/archives/2016/07/page/2/index.html","hash":"1c0fcd081bb32bffc9a94c9989c7a6ace3c68abd","modified":1653710288866},{"_id":"public/archives/2016/09/index.html","hash":"585094a860418ff4a71f0a61602197072f4f13ac","modified":1653710288866},{"_id":"public/archives/2016/10/index.html","hash":"23e20e43bd1d964bb3cf66eaf470b28cfbff5032","modified":1653710288866},{"_id":"public/archives/2017/index.html","hash":"15d40b95faf15353e8124f10f2231e9ca32b1801","modified":1653710288866},{"_id":"public/archives/2017/page/2/index.html","hash":"0e679083a77a3388b1e359d0ee0686dfa8299035","modified":1653710288867},{"_id":"public/archives/2017/01/index.html","hash":"0077f0b7c327b31d30fd66acc9a8f07d9afb4af2","modified":1653710288867},{"_id":"public/archives/2017/02/index.html","hash":"6d167361a5699b4d362658fa7df55a3392353f76","modified":1653710288867},{"_id":"public/archives/2017/03/index.html","hash":"ad633b5aac990f6eb153a9d8923ea378c399ee12","modified":1653710288867},{"_id":"public/archives/2017/05/index.html","hash":"22b45cfb6523aec19919e9e280594a5d0a9d97bd","modified":1653710288867},{"_id":"public/archives/2017/08/index.html","hash":"7bb2679555335696fc5ef8ecee3d6c3a28489929","modified":1653710288867},{"_id":"public/archives/2018/index.html","hash":"0a0c0ffa787a671e186a02352a9b9159e79dd209","modified":1653710288867},{"_id":"public/archives/2018/page/2/index.html","hash":"047a613d42d6e67a9cb3a96c4303d429d6b31a19","modified":1653710288867},{"_id":"public/archives/2018/page/3/index.html","hash":"1e47597fbad218284c17b042ee9d1f088cf8c934","modified":1653710288867},{"_id":"public/archives/2018/page/4/index.html","hash":"5185876984af702aa87251f10e98e2163583ee2d","modified":1653710288867},{"_id":"public/archives/2018/01/index.html","hash":"521b891a0ae07ec81c5b22c0a286774243da717a","modified":1653710288867},{"_id":"public/archives/2018/02/index.html","hash":"04a58353322e801389214dae7c5c0b33ebb8520f","modified":1653710288867},{"_id":"public/archives/2018/03/index.html","hash":"be6b39007954e2c9268289a89fd34fe6827c5200","modified":1653710288867},{"_id":"public/archives/2018/04/index.html","hash":"a79c9ee744e67280e8a79e88bf585c7fcc9cbc2d","modified":1653710288867},{"_id":"public/archives/2018/07/index.html","hash":"9b9ed8e53980b23291eded3679ee6b250a2751cd","modified":1653710288867},{"_id":"public/archives/2018/08/index.html","hash":"3544d326d3dc6da043a2dd974c012053c971e6f7","modified":1653710288867},{"_id":"public/archives/2018/09/index.html","hash":"404f4c7bd1b445ad5909d875b868fad63b0240f7","modified":1653710288868},{"_id":"public/archives/2018/10/index.html","hash":"dee97cdb182f0e25ab23690ad461d8565c59be4f","modified":1653710288868},{"_id":"public/archives/2018/11/index.html","hash":"18d32d0e479bf99951dbd5f72f2f108d27d4f592","modified":1653710288868},{"_id":"public/archives/2018/12/index.html","hash":"b67311c7d03e3691a14e19561c2615ac450edda8","modified":1653710288868},{"_id":"public/archives/2020/index.html","hash":"24824b2fdb675a2a5694a5e81731649842e276f5","modified":1653710288868},{"_id":"public/archives/2020/07/index.html","hash":"6a47df3ac658ccf150f930f7ad0708c37a6ea653","modified":1653710288868},{"_id":"public/archives/2020/08/index.html","hash":"fd1871a24691be8bab97377cc08e2dcf81770b4f","modified":1653710288868},{"_id":"public/archives/2020/09/index.html","hash":"9057dbcdacfccd418c9512f4250650be007d5a3a","modified":1653710288868},{"_id":"public/archives/2020/11/index.html","hash":"f890fec5d1eebedb083042817f8a8641c84a8436","modified":1653710288868},{"_id":"public/archives/2021/index.html","hash":"837f9c0d749e815607cd4074966adc07ff69e0f9","modified":1653710288868},{"_id":"public/archives/2021/01/index.html","hash":"3f21565af114fb3ba2c88783d58894b410dea798","modified":1653710288868},{"_id":"public/categories/前端/index.html","hash":"6b52c148ceb9a3816bb4cfa2022bf49490264d51","modified":1653710288868},{"_id":"public/categories/前端/page/2/index.html","hash":"8499692bc141574a884f5741d3e074bb0aeeda35","modified":1653710288868},{"_id":"public/categories/前端/page/3/index.html","hash":"2518b10b24255680d9a448b378472aee843990a5","modified":1653710288869},{"_id":"public/categories/生活/index.html","hash":"0b5ad42b16596ad91c8ee6a5bb2366a738e4d6b2","modified":1653710288869},{"_id":"public/tags/CSS/index.html","hash":"1ed68b0fc0346d260d04ed72b1a6104ad9a051e0","modified":1653710288869},{"_id":"public/tags/算法/index.html","hash":"eb1409ef289527285cb8563a8c2a720f3f1fe0c0","modified":1653710288869},{"_id":"public/tags/React-Native/index.html","hash":"7f95c14283ef1754de892ad01997facaadc6704e","modified":1653710288869},{"_id":"public/tags/React-Router/index.html","hash":"14d7d72eb9ac244d380be1dd2710dec06e12e944","modified":1653710288869},{"_id":"public/tags/React/index.html","hash":"7c260be7976c631c373d2623e91e72c72fbcaabb","modified":1653710288869},{"_id":"public/tags/React/page/2/index.html","hash":"a9e7d3888b6dcf0304ea84b802a7b00f2d448280","modified":1653710288869},{"_id":"public/tags/React/page/3/index.html","hash":"49a6e11873d2a4d85524a4ac758c3f7885d56abc","modified":1653710288869},{"_id":"public/tags/Redux/index.html","hash":"8fdb5c63838b2be8d7167e05e55def295221b560","modified":1653710288869},{"_id":"public/tags/Redux/page/2/index.html","hash":"735fda9efc466d0548f3f048b6396623b8cddd62","modified":1653710288869},{"_id":"public/tags/Webpack/index.html","hash":"f277db4e515d4b343f6d107aab5d5a46cb72fe55","modified":1653710288869},{"_id":"public/tags/Linux/index.html","hash":"baa31ff16d83a42ab47b961ef13225fb1cada524","modified":1653710288869},{"_id":"public/tags/react-router/index.html","hash":"7c44d455fd1464cdeb29e01c33e805478d0cb0cc","modified":1653710288869},{"_id":"public/tags/JavaScript/index.html","hash":"be7e96434b5edc73166b127d27ec93abd293cc8d","modified":1653710288869},{"_id":"public/tags/Node/index.html","hash":"dc5378e0a3ceac51cf9e3c8eb39300355159e1a2","modified":1653710288869},{"_id":"public/tags/前端/index.html","hash":"4f42a3d7a2134a9f02cdb424ee48f942e9543a5d","modified":1653710288869},{"_id":"public/tags/HTML5/index.html","hash":"74ff18a8edc1ec103b19b1404beea2e3a73bac61","modified":1653710288870},{"_id":"public/tags/微信/index.html","hash":"449622134bebcef76dd33b98cc67beb564fc105c","modified":1653710288870},{"_id":"public/tags/CSS-in-JS/index.html","hash":"fe9b3b1b3aa5d0eb40391ce13e6d4abc43176ce3","modified":1653710288870},{"_id":"public/tags/emotion/index.html","hash":"66191375c760a257ff23a8c33a5f3f816104ff03","modified":1653710288870},{"_id":"public/tags/生活/index.html","hash":"70b13b2cefacfac87ee99f084dccccde2c3d0334","modified":1653710288870},{"_id":"public/tags/正则/index.html","hash":"e54f292b91ecff1952ae4a7f5ea96331ac33e724","modified":1653710288870},{"_id":"public/tags/随笔/index.html","hash":"58e8dc12e6266d6d7cf00d5b8153b142ddb227ae","modified":1653710288870},{"_id":"public/tags/杂谈/index.html","hash":"010c7d23fd200b6470e94d45761531a60427f651","modified":1653710288870},{"_id":"public/tags/HTTP/index.html","hash":"f29393b0877de440c5ff572a9fe1217688b56fa0","modified":1653710288870},{"_id":"public/tags/ES6/index.html","hash":"77a68151457b638f187759519b6ae8a584f6ac75","modified":1653710288870},{"_id":"public/tags/移动端/index.html","hash":"f27524b2d54bf0350476399d299b46c472d1ecb2","modified":1653710288870},{"_id":"public/tags/调试/index.html","hash":"2beb59156f9195992821825076e5de5c47744661","modified":1653710288870},{"_id":"public/tags/hooks/index.html","hash":"86e86968cbe9d3f9db3da855e7255a10bafce00e","modified":1653710288870},{"_id":"public/tags/Vue/index.html","hash":"7bc92c25191acc94c00bee99c03921ddd79f18b2","modified":1653710288870},{"_id":"public/tags/组件/index.html","hash":"f9740ef313fcb6a5a31e8f3f66a57adc51b1e212","modified":1653710288870},{"_id":"public/tags/架构/index.html","hash":"a1c5a4d717b0bb80b002a177becb27aa537b9b79","modified":1653710288870},{"_id":"public/index.html","hash":"b3a1d15bad01f814a1401b11e88a02db458c5472","modified":1653710288871},{"_id":"public/page/2/index.html","hash":"1a35ac3b7671ac4ac16322b299f2314286de2090","modified":1653710288871},{"_id":"public/page/3/index.html","hash":"c9f9a01ec165e46a2428822ee3d696f57f4c905e","modified":1653710288871},{"_id":"public/page/4/index.html","hash":"36dbf615e5b29ef29cc62139fe123936d8a17d6c","modified":1653710288871},{"_id":"public/page/5/index.html","hash":"8c32935a7ebae25cd0f34fdda45fa3846b75bb03","modified":1653710288871},{"_id":"public/tags/index.html","hash":"767d70c1aa52c01564f589b087a2259124f3196d","modified":1653710288871},{"_id":"public/2021/01/13/在React和TypeScript中使用emotion/index.html","hash":"edcb675fb52eef27ca1a25260af8563b0a5f52a5","modified":1653710288871},{"_id":"public/2020/09/20/移动端H5调试工具指南/index.html","hash":"9d26bfbf95b4d6107ce86cf909fcdd7e75be7a14","modified":1653710288871},{"_id":"public/2020/11/05/Webpack5升级指南/index.html","hash":"db695b901f4ed92da410a05ff29be1939382c06c","modified":1653710288871},{"_id":"public/2020/08/03/自定义Hook在React中的实践/index.html","hash":"591a2346d6f3ac1e2b488e33b752070b21a61841","modified":1653710288871},{"_id":"public/2020/07/09/聊聊Vue组件通信方式/index.html","hash":"ea9463126c4de29e7dd1d0a857c7fd76d5650f96","modified":1653710288871},{"_id":"public/2018/11/16/关于一道字符串格式化面试题的思考/index.html","hash":"b8d9e40f1bbe98f41040e48c1033b8fe26d0d7d6","modified":1653710288872},{"_id":"public/2018/11/06/深拷贝探秘/index.html","hash":"edd369f7e827c6e7f70fe7c464ca095da2cf5967","modified":1653710288872},{"_id":"public/2018/12/02/JavaScript排序算法之选择排序和插入排序/index.html","hash":"bdc26d7a1399b130510190f595f0e9300de0fedb","modified":1653710288872},{"_id":"public/2018/10/30/Webpack之打包体积优化/index.html","hash":"9b63af3040a183c8b12864f1c03478b2eec620ae","modified":1653710288872},{"_id":"public/2018/10/29/Webpack之构建速度优化/index.html","hash":"07ef85cf762576d0a16152b685ad6a2dd2837581","modified":1653710288872},{"_id":"public/2018/09/25/编写高性能React代码的原则/index.html","hash":"acba565483b632f01fe2a0e152e6ed3b9f1fd0b3","modified":1653710288872},{"_id":"public/2018/08/22/浅析HTTP缓存/index.html","hash":"785fdb0c3cd94c95054f887a87f652b83b186e22","modified":1653710288872},{"_id":"public/2018/07/27/前端代码规范工程化实践指南/index.html","hash":"1a6908a675ef3845b1e7eba80d08d5debcd93023","modified":1653710288872},{"_id":"public/2018/04/04/手摸手撸一个简单的Redux（五）/index.html","hash":"f77cefe29a92447333bffad4a93420d08711993d","modified":1653710288873},{"_id":"public/2018/03/30/使用webpack4和react-router 4实现代码分割/index.html","hash":"3204f3e1d9ee7317d519a4a84a358b4fdfac816b","modified":1653710288873},{"_id":"public/2018/03/19/谈谈React中的组件/index.html","hash":"d65336633f67a1331ae3835c81c63882b40a81cf","modified":1653710288873},{"_id":"public/2018/03/12/手摸手撸一个简单的Redux（四）/index.html","hash":"bc7788ad18a2b02112dad5563327b48fa56fd950","modified":1653710288873},{"_id":"public/2018/03/08/手摸手撸一个简单的Redux（三）/index.html","hash":"95e7ca210d9a645425d7e19f9b6c74edd2b4f26f","modified":1653710288873},{"_id":"public/2018/03/06/手摸手撸一个简单的Redux（二）/index.html","hash":"6fd8f36d41389b53201edf4b4f1bfb823ced9792","modified":1653710288873},{"_id":"public/2018/02/26/手摸手撸一个简单的Redux（一）/index.html","hash":"7d7901b141d38dbfd50a73b5827131f406fde58b","modified":1653710288873},{"_id":"public/2018/02/23/react-redux开发简单的to do应用/index.html","hash":"3950146c4df228ff6d06b9ef7f7cf7d2c5419fbf","modified":1653710288873},{"_id":"public/2018/02/07/Redux实现简单计数器/index.html","hash":"8d6fd36e8ace3c8828974c00f7c851051be13da5","modified":1653710288873},{"_id":"public/2018/02/02/React Router V4 学习笔记/index.html","hash":"5ddb9113c62e9064a2f2bffaddc67668d03ae415","modified":1653710288873},{"_id":"public/2018/01/04/React Native 封装HTTP请求/index.html","hash":"cf609230f845a4b5a11244eea3036fc129c68790","modified":1653710288873},{"_id":"public/2017/08/25/基于HTML5实现跨文档通信/index.html","hash":"efd1161e32176a261cda01c6a60f48b5fa2e5ffe","modified":1653710288873},{"_id":"public/2017/05/26/读《前端架构设计》——我眼中的前端架构/index.html","hash":"800894ffb1284c46be81e18a022ed66f502da112","modified":1653710288873},{"_id":"public/2017/03/18/CSS3实现文字流光渐变动画/index.html","hash":"19e864214a7fffbb92e91efc08684144a83f6191","modified":1653710288873},{"_id":"public/2017/03/05/微信网页授权功能开发总结/index.html","hash":"67b1dc699b5394d2c5560b866a25f977c6238a71","modified":1653710288873},{"_id":"public/2017/02/02/理解ES6之箭头函数/index.html","hash":"3172cb93e4766f48e5fd62746e21820a255ef6fc","modified":1653710288873},{"_id":"public/2017/01/24/理解React组件生命周期/index.html","hash":"c96f08f4d828cf43ed5907a341fc77ca102278d0","modified":1653710288874},{"_id":"public/2017/01/21/Ubuntu下搭建前端开发环境和常用工具/index.html","hash":"9c0d42de9f8902cdf510227d619850f77cb040a6","modified":1653710288874},{"_id":"public/2016/10/15/正则表达式必知必会/index.html","hash":"0b7d4afd428a7d51064dfaa1d721d225df291782","modified":1653710288874},{"_id":"public/2016/10/06/初识Node-js/index.html","hash":"88b2a26f2c0f62ee9c393bdee5f23d3e3530c990","modified":1653710288874},{"_id":"public/2016/09/24/深入理解JavaScript之克隆/index.html","hash":"f616c8ef42c21c8ab3d01faa78895f9d93212642","modified":1653710288874},{"_id":"public/2016/07/20/CSS学习笔记之获取元素CSS方法/index.html","hash":"6d9f37f8bcbf2fcf8f79a7aa05a8be730a72a8d4","modified":1653710288874},{"_id":"public/2016/07/16/深入理解JavaScript之变量提升/index.html","hash":"db7db5355246b5597fc89936b6ba9c277df5f2d0","modified":1653710288874},{"_id":"public/2016/07/14/深入理解JavaScript之this/index.html","hash":"26e23012e7906f8e366ed74fcc6af86fc8b3f2e9","modified":1653710288874},{"_id":"public/2016/07/10/你不知道的CSS-一/index.html","hash":"bcea48667b51dab2cee4a18e3847db9acff1f8c1","modified":1653710288874},{"_id":"public/fonts/SourceCodePro.woff2","hash":"67c9510c17e34c0de970997171214696ee6b27c6","modified":1653710288886},{"_id":"public/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1653710288886},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1653710288886},{"_id":"public/css/images/favicon.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1653710288886},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1653710288886},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1653710288886},{"_id":"public/css/images/logo.png","hash":"1d6ffbfe73a830ae6a777953a16606d45cc26ce4","modified":1653710288886},{"_id":"public/css/images/alipay.jpg","hash":"613dcfceacd4b193b0b52c2b8515ee7339dabb3d","modified":1653710289178},{"_id":"public/css/images/wechat.jpg","hash":"98802457b2ef94e8d8a597a723283e2725b2c768","modified":1653710289179},{"_id":"public/js/script.js","hash":"19c6ac9c1d8220fa9ab2ec461c17eaae3bc962d7","modified":1653710289183},{"_id":"public/css/style.css","hash":"e9a26d59e4df006f57d16c864ad019ddf86e8afe","modified":1653710289183},{"_id":"public/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1653710289184},{"_id":"public/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1653710289184},{"_id":"public/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1653710289184},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1653710289184}],"Category":[{"name":"前端","_id":"cl3pcenmy0004p70v8rwfun5q"},{"name":"生活","_id":"cl3pcennz001ep70vxy5mz8xr"}],"Data":[],"Page":[{"title":"About","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---","date":"2022-02-05T13:40:38.921Z","updated":"2020-07-16T13:56:47.880Z","path":"about/index.html","comments":1,"_id":"cl3pcenmv0001p70vox6l5pqn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Project","layout":"project","_content":"","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n","date":"2022-02-05T13:40:38.927Z","updated":"2020-07-16T13:56:47.881Z","path":"project/index.html","comments":1,"_id":"cl3pcenmx0003p70vpw5zvizg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2022-02-05T13:40:38.924Z","updated":"2020-07-16T13:56:47.881Z","path":"tags/index.html","comments":1,"_id":"cl3pcenp9004ep70vu5fsjgaj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CSS3实现文字流光渐变动画","date":"2017-03-18T04:29:46.000Z","banner":"http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121942.png","_content":"\n> 来自百度前端技术学院的实践任务：有趣的鼠标悬浮模糊效果，参考：http://ife.baidu.com/course/detail/id/14，用CSS3实现了一下，顺便复习下CSS的基础。\n\n![image](http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121942.png)\n\n<!--more-->\n\n\n### 主要实现\n\n- 最终效果：  \n\nhttp://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\n- 实现文字的流光渐变动画\n- 背景图需要进行模糊处理\n- 实现按钮边框的从中间到两边扩展开\n下面来一步步实现这些效果。\n\n### 页面结构和基础样式\n\nindex.html\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n\t<title>有趣的鼠标悬浮模糊效果</title>\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"box-wrapper\">\n        <div class=\"box\">\n         <h1 class=\"title\">HTML5、CSS3、ES6</h1>\n        </div>\n    </div>\n  \n   <img class=\"img\" src=\"./404_1x.png\" alt=\"404\">\n</div>\n</body>\n\n</html>\n```\nstyle.css\n\n\n``` css\n* {\n  margin:0;\n  padding:0;\n  box-sizing: border-box;\n}\n\n.container {\n  margin:50px auto;\n  width:400px;\n  height:300px;\n  position: relative;\n}\n\n.box-wrapper {\n  position: absolute;\n  text-align: center;\n  width:100%;\n  height:100%;\n  padding:30px;\n}\n\n.box{\n  position: relative;\n  width:100%;\n  height:100%;\n  padding-top: 80px;\n}\n```\n现在我们已经实现了页面的基本布局和样式，container容器固定宽高，在页面中水平居中，包含box-wrapper和img两个盒子，box-wrapper充满container，绝对定位使文字悬浮与图片上面。  \n现在的效果如下：  \n\n![image](http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121705.png)\n\n### 实现文字的背景渐变\n\n实现文字的流光渐变我们需要用到CSS3的**linear-gradient**绘制背景渐变效果，从左到右，这里我们需要设置0～100%的五种颜色，其中0～40%的色值与50%～100%的色值相同，并且0和100%的色值相同，这样是为了让流光效果如丝般顺滑。  \n\n**CSS linear-gradient()** 函数的第一个参数描述渐变线的起始点位置。它包含两个关键词：第一个指出垂直位置left or right，第二个指出水平位置top or bottom。关键词的先后顺序无影响，且都是可选的。  \n\nto top, to bottom, to left 和 to right这些值会被转换成角度0度、180度、270度和90度。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  \n}\n```\n现在可以看到文字背景的渐变效果已经出来了，但是我们需要的是文字颜色渐变的啊。\n\n现在我们需要用到CSS3的background-clip属性。  \n\n**CSS3 background-clip:border-box|padding-box|content-box|text**\n \n\n用于指定background是否包含content之外的border,padding。默认值为border-box，即background从包含border在内的地方开始渲染，IE的默认表现也等同于border-box。\n\n**border-box**:背景裁剪（背景从border(即包括border在内)开始绘制（渲染））;\n\n**padding-box**:背景裁剪（背景从padding(即包括padding在内)开始绘制）;\n\n**content-box**:背景裁剪（背景从content(即内容部分)开始绘制）;\n**text**:背景裁剪（将背景裁剪作为文本的填充色);\n（当前只有webkit内核浏览器支持）。  \n在这里，我们将使用 -webkit-background-clip:text;这个属性来使用文字作为裁剪区域向外裁剪，此时文字的颜色将覆盖在渐变色之上。  \n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  -webkit-background-clip: text;\n}\n```\n\n为了让文字显示渐变色，我们需要将文字颜色变为透明，此时可以使用**-webkit-text-fill-color: transparent**; 或者是** color: transparent**;\n将字体颜色设置成透明，这样就能将渐变色文字显示出来了。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  -webkit-background-clip: text;\n  color:transparent;\n}\n```\n现在的效果如下。  \n\n![image](http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318105511.png)  \n\n### 流光动画原理\n流光动画的原理是将文字的背景色的宽度拉长至原来的两倍，而在**background-image**中我们设置了两份相同的颜色组，将背景拉长之后便只显示一份颜色组，超出背景宽度的颜色组通过动画改变背景色的位置**background-position**来实现流光效果。\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  color:transparent;\n  -webkit-background-clip: text;\n  background-size: 200% 100%;\n}\n```\n下面通过CSS3的**animation**来实现帧动画。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  color:transparent;\n  -webkit-background-clip: text;\n  background-size: 200% 100%;\n  animation: flowlight 5s linear infinite;\n}\n\n\n@keyframes flowlight {\n  0% {\n    background-position: 0 0;\n  }\n  100% {\n    background-position: -100% 0;\n  }\n}\n```\n现在我们已经实现了流光动画的效果，是不是很酷，鼠标悬浮的效果等会一起实现。\n\n### 实现按钮边框的从中间到两边扩展开\n\n这个效果主要使用了伪元素**::before**、**::after**来实现容器的边框，::before设置容器的左右边框，::after设置容器的上下边框，伪元素边框使用绝对定位，父容器box使用相对定位，伪元素边框位置分别定位到相对父元素的top和left的50%，通过改变其位置和宽高来实现边框从中间到两边扩展的动画效果。\n\n\n``` css\n\n.box::before {\n  content:'';\n  border:3px solid #fff;\n  border-width: 0 3px;\n  position: absolute;\n  width:100%;\n  height:0;\n  top:50%;\n  left:0;\n  box-sizing: border-box;\n}\n\n\n.box::after {\n  content:'';\n  border:3px solid #fff;\n  border-width: 3px 0;\n  position: absolute;\n  width:0;\n  height:100%;\n  top:0;\n  left:50%;\n  box-sizing: border-box;\n}\n```\n实现边框扩展的的动画效果，并加上过渡效果。  \n\n``` css\n\n.container:hover .box::before{\n  height:100%;\n  top:0;\n}\n\n.container:hover .box::after {\n  width: 100%;\n  left:0;\n}\n\n.box::before {\n  transition: all .8s;\n}\n\n.box::after {\n  transition: all .8s;\n}\n\n```\n### 背景图的模糊处理\n\n从最终实现我们可以看到，鼠标悬浮时背景图会出现模糊效果，这样的模糊效果我们可以通过CSS3的滤镜属性**filte**r来实现。  \n\n**filter**：CSS滤镜属性，可以在元素呈现之前，为元素的渲染提供一些效果，如模糊、颜色转移之类的。滤镜常用于调整图像、背景、边框的渲染。\n\n在这里我们需要设置**filter**的**blur**来实现对象的模糊效果。\n\n\n``` css\n.container:hover .img {\n   filter: blur(2px);\n   -webkit-filter: blur(2px);\n   -moz-filter: blur(2px);\n   -ms-filter: blur(2px);\n}\n```\n然而，加上之后我们的文字和边框哪儿去了？这是因为图片把文字和边框覆盖了，这里我们需要设置**box-wrapper**容器的**z-index**属性，来凸显各个容器的层级。\n\n\n``` css\n.box-wrapper {\n  position: absolute;\n  text-align: center;\n  width:100%;\n  height:100%;\n  padding:30px;\n  z-index: 99;\n}\n```\n这样，背景模糊的效果就实现了。\n\n\n### 优化细节\n\n细心的你可能注意到，在鼠标悬浮的时候，文字会一个上移的效果还没实现，下面来实现它。  \n文字上移的效果我们通过CSS3的变换属性来实现，默认我们将文字向下位移，鼠标悬浮时我们再将其置0就OK了。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  color:transparent;\n  -webkit-background-clip: text;\n  background-size: 200%;\n  transform: translate(0,20px);\n  animation: flowlight 5s linear infinite;\n}\n```\n通过**translate**将文字向下位移20px。\n\n``` css\n.container:hover .title{\n  transform: translate(0);\n}\n```\n鼠标悬浮时取消位移。 \n\n最后，我们的显示隐藏效果还没实现。这里，我们通过设置透明度**opacity**来实现显示隐藏，设置**transtion**来实现过渡效果。\n\n``` css\n.box{\n  opacity: 0;\n  transition: opacity .8s;\n}\n\n\n.title {\n  transition: transform .8s,opacity .8s;\n}\n\n.container:hover .box{\n  opacity: 1;\n}\n\n.container:hover .title{\n  opacity: 1;\n}\n\n```\n\n现在，我们已经实现了所有的动画效果，看起来还是不错吧，CSS3完成动画效果的能力还是很强大的吧。\n\n### 总结\n\n本文用到的CSS3属性：\n\n- linear-gradient\n- webkit-background-clip\n- -webkit-text-fill-color\n- animation\n- transform\n- transition\n- filter\n\n<div class=\"tip\"> 由于CSS3的兼容性，在完成此效果时，只在Chrome浏览器进行测试，如需兼容其他浏览器，请自行加上浏览器前缀。</div>\n\n源码：https://github.com/YanYuanFE/IFE-task/tree/master/IFE2017/task7  \n\ndemo：http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\n\n\n\n","source":"_posts/CSS3实现文字流光渐变动画.md","raw":"---\ntitle: CSS3实现文字流光渐变动画\ndate: 2017-03-18 12:29:46\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121942.png\ntags:\n\t- CSS\n---\n\n> 来自百度前端技术学院的实践任务：有趣的鼠标悬浮模糊效果，参考：http://ife.baidu.com/course/detail/id/14，用CSS3实现了一下，顺便复习下CSS的基础。\n\n![image](http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121942.png)\n\n<!--more-->\n\n\n### 主要实现\n\n- 最终效果：  \n\nhttp://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\n- 实现文字的流光渐变动画\n- 背景图需要进行模糊处理\n- 实现按钮边框的从中间到两边扩展开\n下面来一步步实现这些效果。\n\n### 页面结构和基础样式\n\nindex.html\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n\t<title>有趣的鼠标悬浮模糊效果</title>\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"box-wrapper\">\n        <div class=\"box\">\n         <h1 class=\"title\">HTML5、CSS3、ES6</h1>\n        </div>\n    </div>\n  \n   <img class=\"img\" src=\"./404_1x.png\" alt=\"404\">\n</div>\n</body>\n\n</html>\n```\nstyle.css\n\n\n``` css\n* {\n  margin:0;\n  padding:0;\n  box-sizing: border-box;\n}\n\n.container {\n  margin:50px auto;\n  width:400px;\n  height:300px;\n  position: relative;\n}\n\n.box-wrapper {\n  position: absolute;\n  text-align: center;\n  width:100%;\n  height:100%;\n  padding:30px;\n}\n\n.box{\n  position: relative;\n  width:100%;\n  height:100%;\n  padding-top: 80px;\n}\n```\n现在我们已经实现了页面的基本布局和样式，container容器固定宽高，在页面中水平居中，包含box-wrapper和img两个盒子，box-wrapper充满container，绝对定位使文字悬浮与图片上面。  \n现在的效果如下：  \n\n![image](http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121705.png)\n\n### 实现文字的背景渐变\n\n实现文字的流光渐变我们需要用到CSS3的**linear-gradient**绘制背景渐变效果，从左到右，这里我们需要设置0～100%的五种颜色，其中0～40%的色值与50%～100%的色值相同，并且0和100%的色值相同，这样是为了让流光效果如丝般顺滑。  \n\n**CSS linear-gradient()** 函数的第一个参数描述渐变线的起始点位置。它包含两个关键词：第一个指出垂直位置left or right，第二个指出水平位置top or bottom。关键词的先后顺序无影响，且都是可选的。  \n\nto top, to bottom, to left 和 to right这些值会被转换成角度0度、180度、270度和90度。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  \n}\n```\n现在可以看到文字背景的渐变效果已经出来了，但是我们需要的是文字颜色渐变的啊。\n\n现在我们需要用到CSS3的background-clip属性。  \n\n**CSS3 background-clip:border-box|padding-box|content-box|text**\n \n\n用于指定background是否包含content之外的border,padding。默认值为border-box，即background从包含border在内的地方开始渲染，IE的默认表现也等同于border-box。\n\n**border-box**:背景裁剪（背景从border(即包括border在内)开始绘制（渲染））;\n\n**padding-box**:背景裁剪（背景从padding(即包括padding在内)开始绘制）;\n\n**content-box**:背景裁剪（背景从content(即内容部分)开始绘制）;\n**text**:背景裁剪（将背景裁剪作为文本的填充色);\n（当前只有webkit内核浏览器支持）。  \n在这里，我们将使用 -webkit-background-clip:text;这个属性来使用文字作为裁剪区域向外裁剪，此时文字的颜色将覆盖在渐变色之上。  \n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  -webkit-background-clip: text;\n}\n```\n\n为了让文字显示渐变色，我们需要将文字颜色变为透明，此时可以使用**-webkit-text-fill-color: transparent**; 或者是** color: transparent**;\n将字体颜色设置成透明，这样就能将渐变色文字显示出来了。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  -webkit-background-clip: text;\n  color:transparent;\n}\n```\n现在的效果如下。  \n\n![image](http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318105511.png)  \n\n### 流光动画原理\n流光动画的原理是将文字的背景色的宽度拉长至原来的两倍，而在**background-image**中我们设置了两份相同的颜色组，将背景拉长之后便只显示一份颜色组，超出背景宽度的颜色组通过动画改变背景色的位置**background-position**来实现流光效果。\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  color:transparent;\n  -webkit-background-clip: text;\n  background-size: 200% 100%;\n}\n```\n下面通过CSS3的**animation**来实现帧动画。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  color:transparent;\n  -webkit-background-clip: text;\n  background-size: 200% 100%;\n  animation: flowlight 5s linear infinite;\n}\n\n\n@keyframes flowlight {\n  0% {\n    background-position: 0 0;\n  }\n  100% {\n    background-position: -100% 0;\n  }\n}\n```\n现在我们已经实现了流光动画的效果，是不是很酷，鼠标悬浮的效果等会一起实现。\n\n### 实现按钮边框的从中间到两边扩展开\n\n这个效果主要使用了伪元素**::before**、**::after**来实现容器的边框，::before设置容器的左右边框，::after设置容器的上下边框，伪元素边框使用绝对定位，父容器box使用相对定位，伪元素边框位置分别定位到相对父元素的top和left的50%，通过改变其位置和宽高来实现边框从中间到两边扩展的动画效果。\n\n\n``` css\n\n.box::before {\n  content:'';\n  border:3px solid #fff;\n  border-width: 0 3px;\n  position: absolute;\n  width:100%;\n  height:0;\n  top:50%;\n  left:0;\n  box-sizing: border-box;\n}\n\n\n.box::after {\n  content:'';\n  border:3px solid #fff;\n  border-width: 3px 0;\n  position: absolute;\n  width:0;\n  height:100%;\n  top:0;\n  left:50%;\n  box-sizing: border-box;\n}\n```\n实现边框扩展的的动画效果，并加上过渡效果。  \n\n``` css\n\n.container:hover .box::before{\n  height:100%;\n  top:0;\n}\n\n.container:hover .box::after {\n  width: 100%;\n  left:0;\n}\n\n.box::before {\n  transition: all .8s;\n}\n\n.box::after {\n  transition: all .8s;\n}\n\n```\n### 背景图的模糊处理\n\n从最终实现我们可以看到，鼠标悬浮时背景图会出现模糊效果，这样的模糊效果我们可以通过CSS3的滤镜属性**filte**r来实现。  \n\n**filter**：CSS滤镜属性，可以在元素呈现之前，为元素的渲染提供一些效果，如模糊、颜色转移之类的。滤镜常用于调整图像、背景、边框的渲染。\n\n在这里我们需要设置**filter**的**blur**来实现对象的模糊效果。\n\n\n``` css\n.container:hover .img {\n   filter: blur(2px);\n   -webkit-filter: blur(2px);\n   -moz-filter: blur(2px);\n   -ms-filter: blur(2px);\n}\n```\n然而，加上之后我们的文字和边框哪儿去了？这是因为图片把文字和边框覆盖了，这里我们需要设置**box-wrapper**容器的**z-index**属性，来凸显各个容器的层级。\n\n\n``` css\n.box-wrapper {\n  position: absolute;\n  text-align: center;\n  width:100%;\n  height:100%;\n  padding:30px;\n  z-index: 99;\n}\n```\n这样，背景模糊的效果就实现了。\n\n\n### 优化细节\n\n细心的你可能注意到，在鼠标悬浮的时候，文字会一个上移的效果还没实现，下面来实现它。  \n文字上移的效果我们通过CSS3的变换属性来实现，默认我们将文字向下位移，鼠标悬浮时我们再将其置0就OK了。\n\n\n``` css\n.title {\n  background-image: -webkit-linear-gradient(left,#D81159, #E53A40 10%, #FFBC42 20%, #75D701 30%, #30A9DE 40%,#D81159 50%, #E53A40 60%, #FFBC42 70%, #75D701 80%, #30A9DE 90%,#D81159);\n  color:transparent;\n  -webkit-background-clip: text;\n  background-size: 200%;\n  transform: translate(0,20px);\n  animation: flowlight 5s linear infinite;\n}\n```\n通过**translate**将文字向下位移20px。\n\n``` css\n.container:hover .title{\n  transform: translate(0);\n}\n```\n鼠标悬浮时取消位移。 \n\n最后，我们的显示隐藏效果还没实现。这里，我们通过设置透明度**opacity**来实现显示隐藏，设置**transtion**来实现过渡效果。\n\n``` css\n.box{\n  opacity: 0;\n  transition: opacity .8s;\n}\n\n\n.title {\n  transition: transform .8s,opacity .8s;\n}\n\n.container:hover .box{\n  opacity: 1;\n}\n\n.container:hover .title{\n  opacity: 1;\n}\n\n```\n\n现在，我们已经实现了所有的动画效果，看起来还是不错吧，CSS3完成动画效果的能力还是很强大的吧。\n\n### 总结\n\n本文用到的CSS3属性：\n\n- linear-gradient\n- webkit-background-clip\n- -webkit-text-fill-color\n- animation\n- transform\n- transition\n- filter\n\n<div class=\"tip\"> 由于CSS3的兼容性，在完成此效果时，只在Chrome浏览器进行测试，如需兼容其他浏览器，请自行加上浏览器前缀。</div>\n\n源码：https://github.com/YanYuanFE/IFE-task/tree/master/IFE2017/task7  \n\ndemo：http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\n\n\n\n","slug":"CSS3实现文字流光渐变动画","published":1,"updated":"2020-07-16T13:56:47.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenmr0000p70vytkzlstx","content":"<blockquote>\n<p>来自百度前端技术学院的实践任务：有趣的鼠标悬浮模糊效果，参考：<a href=\"http://ife.baidu.com/course/detail/id/14，用CSS3实现了一下，顺便复习下CSS的基础。\" target=\"_blank\" rel=\"noopener\">http://ife.baidu.com/course/detail/id/14，用CSS3实现了一下，顺便复习下CSS的基础。</a></p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121942.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"主要实现\"><a href=\"#主要实现\" class=\"headerlink\" title=\"主要实现\"></a>主要实现</h3><ul>\n<li>最终效果：  </li>\n</ul>\n<p><a href=\"http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\" target=\"_blank\" rel=\"noopener\">http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html</a></p>\n<ul>\n<li>实现文字的流光渐变动画</li>\n<li>背景图需要进行模糊处理</li>\n<li>实现按钮边框的从中间到两边扩展开<br>下面来一步步实现这些效果。</li>\n</ul>\n<h3 id=\"页面结构和基础样式\"><a href=\"#页面结构和基础样式\" class=\"headerlink\" title=\"页面结构和基础样式\"></a>页面结构和基础样式</h3><p>index.html<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>有趣的鼠标悬浮模糊效果<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-wrapper\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>HTML5、CSS3、ES6<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./404_1x.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"404\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>style.css</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">50px</span> auto;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box-wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">80px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经实现了页面的基本布局和样式，container容器固定宽高，在页面中水平居中，包含box-wrapper和img两个盒子，box-wrapper充满container，绝对定位使文字悬浮与图片上面。<br>现在的效果如下：  </p>\n<p><img src=\"http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121705.png\" alt=\"image\"></p>\n<h3 id=\"实现文字的背景渐变\"><a href=\"#实现文字的背景渐变\" class=\"headerlink\" title=\"实现文字的背景渐变\"></a>实现文字的背景渐变</h3><p>实现文字的流光渐变我们需要用到CSS3的<strong>linear-gradient</strong>绘制背景渐变效果，从左到右，这里我们需要设置0～100%的五种颜色，其中0～40%的色值与50%～100%的色值相同，并且0和100%的色值相同，这样是为了让流光效果如丝般顺滑。  </p>\n<p><strong>CSS linear-gradient()</strong> 函数的第一个参数描述渐变线的起始点位置。它包含两个关键词：第一个指出垂直位置left or right，第二个指出水平位置top or bottom。关键词的先后顺序无影响，且都是可选的。  </p>\n<p>to top, to bottom, to left 和 to right这些值会被转换成角度0度、180度、270度和90度。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在可以看到文字背景的渐变效果已经出来了，但是我们需要的是文字颜色渐变的啊。</p>\n<p>现在我们需要用到CSS3的background-clip属性。  </p>\n<p><strong>CSS3 background-clip:border-box|padding-box|content-box|text</strong></p>\n<p>用于指定background是否包含content之外的border,padding。默认值为border-box，即background从包含border在内的地方开始渲染，IE的默认表现也等同于border-box。</p>\n<p><strong>border-box</strong>:背景裁剪（背景从border(即包括border在内)开始绘制（渲染））;</p>\n<p><strong>padding-box</strong>:背景裁剪（背景从padding(即包括padding在内)开始绘制）;</p>\n<p><strong>content-box</strong>:背景裁剪（背景从content(即内容部分)开始绘制）;<br><strong>text</strong>:背景裁剪（将背景裁剪作为文本的填充色);<br>（当前只有webkit内核浏览器支持）。<br>在这里，我们将使用 -webkit-background-clip:text;这个属性来使用文字作为裁剪区域向外裁剪，此时文字的颜色将覆盖在渐变色之上。  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了让文字显示渐变色，我们需要将文字颜色变为透明，此时可以使用<strong>-webkit-text-fill-color: transparent</strong>; 或者是<strong> color: transparent</strong>;<br>将字体颜色设置成透明，这样就能将渐变色文字显示出来了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在的效果如下。  </p>\n<p><img src=\"http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318105511.png\" alt=\"image\">  </p>\n<h3 id=\"流光动画原理\"><a href=\"#流光动画原理\" class=\"headerlink\" title=\"流光动画原理\"></a>流光动画原理</h3><p>流光动画的原理是将文字的背景色的宽度拉长至原来的两倍，而在<strong>background-image</strong>中我们设置了两份相同的颜色组，将背景拉长之后便只显示一份颜色组，超出背景宽度的颜色组通过动画改变背景色的位置<strong>background-position</strong>来实现流光效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">200%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面通过CSS3的<strong>animation</strong>来实现帧动画。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">200%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: flowlight <span class=\"number\">5s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> flowlight &#123;</span><br><span class=\"line\">  0% &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: -<span class=\"number\">100%</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经实现了流光动画的效果，是不是很酷，鼠标悬浮的效果等会一起实现。</p>\n<h3 id=\"实现按钮边框的从中间到两边扩展开\"><a href=\"#实现按钮边框的从中间到两边扩展开\" class=\"headerlink\" title=\"实现按钮边框的从中间到两边扩展开\"></a>实现按钮边框的从中间到两边扩展开</h3><p>这个效果主要使用了伪元素<strong>::before</strong>、<strong>::after</strong>来实现容器的边框，::before设置容器的左右边框，::after设置容器的上下边框，伪元素边框使用绝对定位，父容器box使用相对定位，伪元素边框位置分别定位到相对父元素的top和left的50%，通过改变其位置和宽高来实现边框从中间到两边扩展的动画效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">3px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">0</span> <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">3px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">3px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现边框扩展的的动画效果，并加上过渡效果。  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::before</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"背景图的模糊处理\"><a href=\"#背景图的模糊处理\" class=\"headerlink\" title=\"背景图的模糊处理\"></a>背景图的模糊处理</h3><p>从最终实现我们可以看到，鼠标悬浮时背景图会出现模糊效果，这样的模糊效果我们可以通过CSS3的滤镜属性<strong>filte</strong>r来实现。  </p>\n<p><strong>filter</strong>：CSS滤镜属性，可以在元素呈现之前，为元素的渲染提供一些效果，如模糊、颜色转移之类的。滤镜常用于调整图像、背景、边框的渲染。</p>\n<p>在这里我们需要设置<strong>filter</strong>的<strong>blur</strong>来实现对象的模糊效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.img</span> &#123;</span><br><span class=\"line\">   <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">   <span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">   <span class=\"attribute\">-moz-filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">   <span class=\"attribute\">-ms-filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，加上之后我们的文字和边框哪儿去了？这是因为图片把文字和边框覆盖了，这里我们需要设置<strong>box-wrapper</strong>容器的<strong>z-index</strong>属性，来凸显各个容器的层级。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box-wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">99</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，背景模糊的效果就实现了。</p>\n<h3 id=\"优化细节\"><a href=\"#优化细节\" class=\"headerlink\" title=\"优化细节\"></a>优化细节</h3><p>细心的你可能注意到，在鼠标悬浮的时候，文字会一个上移的效果还没实现，下面来实现它。<br>文字上移的效果我们通过CSS3的变换属性来实现，默认我们将文字向下位移，鼠标悬浮时我们再将其置0就OK了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">0</span>,<span class=\"number\">20px</span>);</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: flowlight <span class=\"number\">5s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<strong>translate</strong>将文字向下位移20px。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.title</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>鼠标悬浮时取消位移。 </p>\n<p>最后，我们的显示隐藏效果还没实现。这里，我们通过设置透明度<strong>opacity</strong>来实现显示隐藏，设置<strong>transtion</strong>来实现过渡效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform .<span class=\"number\">8s</span>,opacity .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.title</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们已经实现了所有的动画效果，看起来还是不错吧，CSS3完成动画效果的能力还是很强大的吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文用到的CSS3属性：</p>\n<ul>\n<li>linear-gradient</li>\n<li>webkit-background-clip</li>\n<li>-webkit-text-fill-color</li>\n<li>animation</li>\n<li>transform</li>\n<li>transition</li>\n<li>filter</li>\n</ul>\n<div class=\"tip\"> 由于CSS3的兼容性，在完成此效果时，只在Chrome浏览器进行测试，如需兼容其他浏览器，请自行加上浏览器前缀。</div>\n\n<p>源码：<a href=\"https://github.com/YanYuanFE/IFE-task/tree/master/IFE2017/task7\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/IFE-task/tree/master/IFE2017/task7</a>  </p>\n<p>demo：<a href=\"http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\" target=\"_blank\" rel=\"noopener\">http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>来自百度前端技术学院的实践任务：有趣的鼠标悬浮模糊效果，参考：<a href=\"http://ife.baidu.com/course/detail/id/14，用CSS3实现了一下，顺便复习下CSS的基础。\" target=\"_blank\" rel=\"noopener\">http://ife.baidu.com/course/detail/id/14，用CSS3实现了一下，顺便复习下CSS的基础。</a></p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121942.png\" alt=\"image\"></p>","more":"<h3 id=\"主要实现\"><a href=\"#主要实现\" class=\"headerlink\" title=\"主要实现\"></a>主要实现</h3><ul>\n<li>最终效果：  </li>\n</ul>\n<p><a href=\"http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\" target=\"_blank\" rel=\"noopener\">http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html</a></p>\n<ul>\n<li>实现文字的流光渐变动画</li>\n<li>背景图需要进行模糊处理</li>\n<li>实现按钮边框的从中间到两边扩展开<br>下面来一步步实现这些效果。</li>\n</ul>\n<h3 id=\"页面结构和基础样式\"><a href=\"#页面结构和基础样式\" class=\"headerlink\" title=\"页面结构和基础样式\"></a>页面结构和基础样式</h3><p>index.html<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>有趣的鼠标悬浮模糊效果<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-wrapper\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>HTML5、CSS3、ES6<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./404_1x.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"404\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>style.css</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>:<span class=\"number\">50px</span> auto;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">400px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box-wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">30px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">80px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经实现了页面的基本布局和样式，container容器固定宽高，在页面中水平居中，包含box-wrapper和img两个盒子，box-wrapper充满container，绝对定位使文字悬浮与图片上面。<br>现在的效果如下：  </p>\n<p><img src=\"http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318121705.png\" alt=\"image\"></p>\n<h3 id=\"实现文字的背景渐变\"><a href=\"#实现文字的背景渐变\" class=\"headerlink\" title=\"实现文字的背景渐变\"></a>实现文字的背景渐变</h3><p>实现文字的流光渐变我们需要用到CSS3的<strong>linear-gradient</strong>绘制背景渐变效果，从左到右，这里我们需要设置0～100%的五种颜色，其中0～40%的色值与50%～100%的色值相同，并且0和100%的色值相同，这样是为了让流光效果如丝般顺滑。  </p>\n<p><strong>CSS linear-gradient()</strong> 函数的第一个参数描述渐变线的起始点位置。它包含两个关键词：第一个指出垂直位置left or right，第二个指出水平位置top or bottom。关键词的先后顺序无影响，且都是可选的。  </p>\n<p>to top, to bottom, to left 和 to right这些值会被转换成角度0度、180度、270度和90度。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在可以看到文字背景的渐变效果已经出来了，但是我们需要的是文字颜色渐变的啊。</p>\n<p>现在我们需要用到CSS3的background-clip属性。  </p>\n<p><strong>CSS3 background-clip:border-box|padding-box|content-box|text</strong></p>\n<p>用于指定background是否包含content之外的border,padding。默认值为border-box，即background从包含border在内的地方开始渲染，IE的默认表现也等同于border-box。</p>\n<p><strong>border-box</strong>:背景裁剪（背景从border(即包括border在内)开始绘制（渲染））;</p>\n<p><strong>padding-box</strong>:背景裁剪（背景从padding(即包括padding在内)开始绘制）;</p>\n<p><strong>content-box</strong>:背景裁剪（背景从content(即内容部分)开始绘制）;<br><strong>text</strong>:背景裁剪（将背景裁剪作为文本的填充色);<br>（当前只有webkit内核浏览器支持）。<br>在这里，我们将使用 -webkit-background-clip:text;这个属性来使用文字作为裁剪区域向外裁剪，此时文字的颜色将覆盖在渐变色之上。  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了让文字显示渐变色，我们需要将文字颜色变为透明，此时可以使用<strong>-webkit-text-fill-color: transparent</strong>; 或者是<strong> color: transparent</strong>;<br>将字体颜色设置成透明，这样就能将渐变色文字显示出来了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在的效果如下。  </p>\n<p><img src=\"http://img.yanyuanfe.cn/QQ%E6%88%AA%E5%9B%BE20170318105511.png\" alt=\"image\">  </p>\n<h3 id=\"流光动画原理\"><a href=\"#流光动画原理\" class=\"headerlink\" title=\"流光动画原理\"></a>流光动画原理</h3><p>流光动画的原理是将文字的背景色的宽度拉长至原来的两倍，而在<strong>background-image</strong>中我们设置了两份相同的颜色组，将背景拉长之后便只显示一份颜色组，超出背景宽度的颜色组通过动画改变背景色的位置<strong>background-position</strong>来实现流光效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">200%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面通过CSS3的<strong>animation</strong>来实现帧动画。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">200%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: flowlight <span class=\"number\">5s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> flowlight &#123;</span><br><span class=\"line\">  0% &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: -<span class=\"number\">100%</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经实现了流光动画的效果，是不是很酷，鼠标悬浮的效果等会一起实现。</p>\n<h3 id=\"实现按钮边框的从中间到两边扩展开\"><a href=\"#实现按钮边框的从中间到两边扩展开\" class=\"headerlink\" title=\"实现按钮边框的从中间到两边扩展开\"></a>实现按钮边框的从中间到两边扩展开</h3><p>这个效果主要使用了伪元素<strong>::before</strong>、<strong>::after</strong>来实现容器的边框，::before设置容器的左右边框，::after设置容器的上下边框，伪元素边框使用绝对定位，父容器box使用相对定位，伪元素边框位置分别定位到相对父元素的top和left的50%，通过改变其位置和宽高来实现边框从中间到两边扩展的动画效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">3px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">0</span> <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>:<span class=\"number\">3px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">3px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现边框扩展的的动画效果，并加上过渡效果。  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::before</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"背景图的模糊处理\"><a href=\"#背景图的模糊处理\" class=\"headerlink\" title=\"背景图的模糊处理\"></a>背景图的模糊处理</h3><p>从最终实现我们可以看到，鼠标悬浮时背景图会出现模糊效果，这样的模糊效果我们可以通过CSS3的滤镜属性<strong>filte</strong>r来实现。  </p>\n<p><strong>filter</strong>：CSS滤镜属性，可以在元素呈现之前，为元素的渲染提供一些效果，如模糊、颜色转移之类的。滤镜常用于调整图像、背景、边框的渲染。</p>\n<p>在这里我们需要设置<strong>filter</strong>的<strong>blur</strong>来实现对象的模糊效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.img</span> &#123;</span><br><span class=\"line\">   <span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">   <span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">   <span class=\"attribute\">-moz-filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">   <span class=\"attribute\">-ms-filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">2px</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，加上之后我们的文字和边框哪儿去了？这是因为图片把文字和边框覆盖了，这里我们需要设置<strong>box-wrapper</strong>容器的<strong>z-index</strong>属性，来凸显各个容器的层级。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box-wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>:<span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">99</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，背景模糊的效果就实现了。</p>\n<h3 id=\"优化细节\"><a href=\"#优化细节\" class=\"headerlink\" title=\"优化细节\"></a>优化细节</h3><p>细心的你可能注意到，在鼠标悬浮的时候，文字会一个上移的效果还没实现，下面来实现它。<br>文字上移的效果我们通过CSS3的变换属性来实现，默认我们将文字向下位移，鼠标悬浮时我们再将其置0就OK了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(left,#D81159, #E53A40 <span class=\"number\">10%</span>, #FFBC42 <span class=\"number\">20%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">30%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">40%</span>,#D81159 <span class=\"number\">50%</span>, #E53A40 <span class=\"number\">60%</span>, #FFBC42 <span class=\"number\">70%</span>, #<span class=\"number\">75</span>D701 <span class=\"number\">80%</span>, #<span class=\"number\">30</span>A9DE <span class=\"number\">90%</span>,#D81159);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:transparent;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-background-clip</span>: text;</span><br><span class=\"line\">  <span class=\"attribute\">background-size</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">0</span>,<span class=\"number\">20px</span>);</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: flowlight <span class=\"number\">5s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<strong>translate</strong>将文字向下位移20px。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.title</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>鼠标悬浮时取消位移。 </p>\n<p>最后，我们的显示隐藏效果还没实现。这里，我们通过设置透明度<strong>opacity</strong>来实现显示隐藏，设置<strong>transtion</strong>来实现过渡效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.title</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform .<span class=\"number\">8s</span>,opacity .<span class=\"number\">8s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.title</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们已经实现了所有的动画效果，看起来还是不错吧，CSS3完成动画效果的能力还是很强大的吧。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文用到的CSS3属性：</p>\n<ul>\n<li>linear-gradient</li>\n<li>webkit-background-clip</li>\n<li>-webkit-text-fill-color</li>\n<li>animation</li>\n<li>transform</li>\n<li>transition</li>\n<li>filter</li>\n</ul>\n<div class=\"tip\"> 由于CSS3的兼容性，在完成此效果时，只在Chrome浏览器进行测试，如需兼容其他浏览器，请自行加上浏览器前缀。</div>\n\n<p>源码：<a href=\"https://github.com/YanYuanFE/IFE-task/tree/master/IFE2017/task7\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/IFE-task/tree/master/IFE2017/task7</a>  </p>\n<p>demo：<a href=\"http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html\" target=\"_blank\" rel=\"noopener\">http://yanyuanfe.cn/IFE-task/IFE2017/task7/index.html</a></p>"},{"title":"CSS学习笔记之获取元素Style方法","date":"2016-07-20T12:30:53.000Z","banner":"http://img.yanyuanfe.cn/css.png","_content":"\n> CSS 已经如此壮大,以致于一个普通人已经无法把它完整地装进自己的头脑了。\n\n![image](http://img.yanyuanfe.cn/css.png)\n\n<!--more-->\n\n\n### 从CSS样式说起\n\n最近一直在使用原生JavaScript，在获取元素的样式的时候发现了一些CSS的小秘密，关于CSS的style、currentStyle、getComputedStyle。什么？后面两个你没见过！！！在看了这篇文章之后你就知道了。\n\n在讲干货之前，我想我们应该来复习下关于CSS的基础。\n\n关于这个层叠样式表（CSS），在HTML文档里有三种表现形式。\n1. 内联样式表\n\n内联样式表是指将CSS样式编码写在HTML标签中，如下所示：\n\n``` html\n<h1 style=\"font-size:16px;color:#000FFF\">\n内联CSS样式。\n</h1>\n```\n内联样式表由HTML元素的HTML元素的style支持，只需将CSS代码用分号隔开写在style=\"\"之中。这是最基本的形式，但是它没有实现表现与内容分离且不能灵活的控制多个页面所以我们很少使用。\n2. 内部样式表\n\n内部样式表与内联样式表相似都是把CSS代码写在HTML页面中，稍微不同的是前者可以将样式表放在一个固定的位置，如下所示：\n\n``` html\n<html>\n<head>\n<title>内部样式表</title>\n<style type=\"text/css\">\n   h1{font-size:16px;\n      color:#000FFF\n      }\n</style>\n</head>\n<body>\n<h1>内部CSS样式。</h1>\n</body>\n</html>\n```\n内部样式表编码是初级的应用形式，不能跨页面使用所以不适合使用。\n\n\n3. 外部样式表\n\n外部样式表是CSS应用中最好的一中形式，它将CSS样式代码单独放在一个外部文件中，再由网页进行调用。多个网页可以调用一个样式文件表，这样能够实现代码的最大限度的重用及网站文件的最优化配置，如下所示：\n\n\n``` html\n<html>\n<head>\n<title>外部样式表</title>\n<link rel=\"stylesheet\" rev=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n<h1>外部CSS样式。</h1>\n</body>\n</html>\n```\n在style.css中的代码为\n\n``` css\n@charset \"UTF-8\";\n\nh1{\n    font-size:16px;\n    color:#000FFF\n}\n```\n我们在<head>中使用了<link>标签来调用外部样式表文件。将link指定为stylesheet方式，并使用了href=\"style.css\"指明样式表文件的路径便可将该页面应用到在style.css中定义的样式。\n\n现在你已经知道了CSS的三种形式，那么它们和在JavaScript中获取元素又又怎样的关系呢？下面揭晓答案。\n\n### 获取元素样式方法之style\n\nstyle是通过JavaScript语言来获取CSS的样式的一种最基本的方法，也是最为人所知的方法，它的使用方法是element.style.attr，可读可写。需要注意的是（前方高能），style只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\n神马？（童话里都是骗人的）。下面是验证代码：\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>CSS样式</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\">\n    \n</head>\n<style type=\"text/css\">\n  #container{\n    width: 300px;\n  }\n  h1{\n    font-size: 13px;\n  }\n</style>\n\n<body>\n   <div id=\"container\" style=\"width: 400px;\">\n    <h1 style=\"font-size: 14px;\">CSS学习笔记之获取元素样式</h1>\n   </div>\n  \n  <script src=\"js/task.js\"></script>\n</body>\n\n</html>\n```\n**style.css**\n\n``` css\n#container{\n\twidth: 500px;\n\n}\nh1{\n\tfont-size: 16px;\n}\n```\n**task.js**\n\n``` js\nwindow.onload = function(){\n  var oDiv= document.getElementById('container');\n  var h1=document.getElementsByTagName(\"h1\")[0];\n  console.log(oDiv.style.width); //400px\n  console.log(h1.style.fontSize); //14px\n};\n```\n在上面的代码中，我们分别使用CSS的三种形式对container和h1设置不同的样式，通过js来获取具体值，最后得到的都是内联样式的值。而最终在网页中生效的也是内联样式的值，也表明三种方式中内联样式的优先级最高。\n\n### 获取元素样式方法之currentStyle\n\n说到currentStyle，表示很遗憾，它只兼容IE浏览器，使用currentStyle返回的是元素当前应用的最终CSS属性值（包括外联CSS文件，页面中嵌入的style属性等）。\ncurrentStyle的使用方法是element.currentStyle[\"attr']或者element.currentStyle.attr。\n我们对js代码进行修改如下：\n\n\n**task.js**\n\n``` js\nwindow.onload = function(){\n  var oDiv= document.getElementById('container');\n  var h1=document.getElementsByTagName(\"h1\")[0];\n  console.log(oDiv.currentStyle.width); //400px\n  console.log(h1.currentStyle.fontSize); //14px\n};\n```\n通过测试，IE显示正常，Edge浏览器报错，Chrome报错如下：\n\n``` js\nUncaught TypeError: Cannot read property 'width' of undefined\n```\n\n### 获取元素样式方法之getComputedStyle\n\ngetComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，如果没有设置css样式，会读取默认样式，只读。它的使用方法是：\nwindow.getComputedStyle(element, pseudoElt)[\"attr']或window.getComputedStyle(element, pseudoElt).attr。其中，pseudoElt表示如 :after,:before之类的伪类，如果不用伪类的话设置为null即可，不是必需参数。\n\ngetComputedStyle同currentStyle作用相同，但是适用于Firefox、Opera、Safari、Chrome。\n关于兼容性，getComputedStyle在IE6-8是不支持的。\n我们修改代码如下：\n\n**task.js**\n\n``` js\nwindow.onload = function(){\n  var oDiv= document.getElementById('container');\n  var h1=document.getElementsByTagName(\"h1\")[0];\n  console.log(window.getComputedStyle(oDiv).width); //400px\n  console.log(window.getComputedStyle(h1).fontSize); //14px\n};\n```\n经过测试在Chrome和IE9以上正常，IE8报错：\n\n```\n对象不支持“getComputedStyle”属性或方法\n```\n\n### 获取元素样式方法之关于属性\n\n说点有趣又涨姿势的，当我们使用js获取元素属性值的时候，传入的属性可能跟你想象的不太一样，比如上面驼峰式的fontSize。或者看看下面这个奇葩的浮动属性：\nChrome浏览器下是cssFloat和float，\nFireFox浏览器下是cssFloat，IE7浏览器下则是styleFloat，而IE9浏览器下则是cssFloat和styleFloat都有，简直很变态啊有木有。\n\n那我们再来谈谈获取元素属性的另一个方法，getAttribute，它可以获取CSS样式申明对象上的属性值（直接属性名称），可以访问CSS样式对象的属性。\n使用getAttribute方法也不需要cssFloat与styleFloat的怪异写法与兼容性处理，但是属性名需要驼峰式写法。比如：\n\n\n``` js\nelement.getAttribute(\"float\");\n```\n\n\n``` js\nelement.getAttribute(\"fontSize\");\n```\n### 封装getStyle\n\n经过上面的了解，相信你已经可以写出一个封装获取样式的兼容写法，下面是一个简洁版：\n\n\n``` js\n//获取样式\nfunction getStyle(obj, attr) {\n\treturn obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj, false)[attr];\n}\n```\n\n\n\n","source":"_posts/CSS学习笔记之获取元素CSS方法.md","raw":"---\ntitle: CSS学习笔记之获取元素Style方法\ndate: 2016-07-20 20:30:53\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/css.png\ntags:\n\t- CSS\n\n---\n\n> CSS 已经如此壮大,以致于一个普通人已经无法把它完整地装进自己的头脑了。\n\n![image](http://img.yanyuanfe.cn/css.png)\n\n<!--more-->\n\n\n### 从CSS样式说起\n\n最近一直在使用原生JavaScript，在获取元素的样式的时候发现了一些CSS的小秘密，关于CSS的style、currentStyle、getComputedStyle。什么？后面两个你没见过！！！在看了这篇文章之后你就知道了。\n\n在讲干货之前，我想我们应该来复习下关于CSS的基础。\n\n关于这个层叠样式表（CSS），在HTML文档里有三种表现形式。\n1. 内联样式表\n\n内联样式表是指将CSS样式编码写在HTML标签中，如下所示：\n\n``` html\n<h1 style=\"font-size:16px;color:#000FFF\">\n内联CSS样式。\n</h1>\n```\n内联样式表由HTML元素的HTML元素的style支持，只需将CSS代码用分号隔开写在style=\"\"之中。这是最基本的形式，但是它没有实现表现与内容分离且不能灵活的控制多个页面所以我们很少使用。\n2. 内部样式表\n\n内部样式表与内联样式表相似都是把CSS代码写在HTML页面中，稍微不同的是前者可以将样式表放在一个固定的位置，如下所示：\n\n``` html\n<html>\n<head>\n<title>内部样式表</title>\n<style type=\"text/css\">\n   h1{font-size:16px;\n      color:#000FFF\n      }\n</style>\n</head>\n<body>\n<h1>内部CSS样式。</h1>\n</body>\n</html>\n```\n内部样式表编码是初级的应用形式，不能跨页面使用所以不适合使用。\n\n\n3. 外部样式表\n\n外部样式表是CSS应用中最好的一中形式，它将CSS样式代码单独放在一个外部文件中，再由网页进行调用。多个网页可以调用一个样式文件表，这样能够实现代码的最大限度的重用及网站文件的最优化配置，如下所示：\n\n\n``` html\n<html>\n<head>\n<title>外部样式表</title>\n<link rel=\"stylesheet\" rev=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n<h1>外部CSS样式。</h1>\n</body>\n</html>\n```\n在style.css中的代码为\n\n``` css\n@charset \"UTF-8\";\n\nh1{\n    font-size:16px;\n    color:#000FFF\n}\n```\n我们在<head>中使用了<link>标签来调用外部样式表文件。将link指定为stylesheet方式，并使用了href=\"style.css\"指明样式表文件的路径便可将该页面应用到在style.css中定义的样式。\n\n现在你已经知道了CSS的三种形式，那么它们和在JavaScript中获取元素又又怎样的关系呢？下面揭晓答案。\n\n### 获取元素样式方法之style\n\nstyle是通过JavaScript语言来获取CSS的样式的一种最基本的方法，也是最为人所知的方法，它的使用方法是element.style.attr，可读可写。需要注意的是（前方高能），style只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\n神马？（童话里都是骗人的）。下面是验证代码：\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>CSS样式</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\">\n    \n</head>\n<style type=\"text/css\">\n  #container{\n    width: 300px;\n  }\n  h1{\n    font-size: 13px;\n  }\n</style>\n\n<body>\n   <div id=\"container\" style=\"width: 400px;\">\n    <h1 style=\"font-size: 14px;\">CSS学习笔记之获取元素样式</h1>\n   </div>\n  \n  <script src=\"js/task.js\"></script>\n</body>\n\n</html>\n```\n**style.css**\n\n``` css\n#container{\n\twidth: 500px;\n\n}\nh1{\n\tfont-size: 16px;\n}\n```\n**task.js**\n\n``` js\nwindow.onload = function(){\n  var oDiv= document.getElementById('container');\n  var h1=document.getElementsByTagName(\"h1\")[0];\n  console.log(oDiv.style.width); //400px\n  console.log(h1.style.fontSize); //14px\n};\n```\n在上面的代码中，我们分别使用CSS的三种形式对container和h1设置不同的样式，通过js来获取具体值，最后得到的都是内联样式的值。而最终在网页中生效的也是内联样式的值，也表明三种方式中内联样式的优先级最高。\n\n### 获取元素样式方法之currentStyle\n\n说到currentStyle，表示很遗憾，它只兼容IE浏览器，使用currentStyle返回的是元素当前应用的最终CSS属性值（包括外联CSS文件，页面中嵌入的style属性等）。\ncurrentStyle的使用方法是element.currentStyle[\"attr']或者element.currentStyle.attr。\n我们对js代码进行修改如下：\n\n\n**task.js**\n\n``` js\nwindow.onload = function(){\n  var oDiv= document.getElementById('container');\n  var h1=document.getElementsByTagName(\"h1\")[0];\n  console.log(oDiv.currentStyle.width); //400px\n  console.log(h1.currentStyle.fontSize); //14px\n};\n```\n通过测试，IE显示正常，Edge浏览器报错，Chrome报错如下：\n\n``` js\nUncaught TypeError: Cannot read property 'width' of undefined\n```\n\n### 获取元素样式方法之getComputedStyle\n\ngetComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，如果没有设置css样式，会读取默认样式，只读。它的使用方法是：\nwindow.getComputedStyle(element, pseudoElt)[\"attr']或window.getComputedStyle(element, pseudoElt).attr。其中，pseudoElt表示如 :after,:before之类的伪类，如果不用伪类的话设置为null即可，不是必需参数。\n\ngetComputedStyle同currentStyle作用相同，但是适用于Firefox、Opera、Safari、Chrome。\n关于兼容性，getComputedStyle在IE6-8是不支持的。\n我们修改代码如下：\n\n**task.js**\n\n``` js\nwindow.onload = function(){\n  var oDiv= document.getElementById('container');\n  var h1=document.getElementsByTagName(\"h1\")[0];\n  console.log(window.getComputedStyle(oDiv).width); //400px\n  console.log(window.getComputedStyle(h1).fontSize); //14px\n};\n```\n经过测试在Chrome和IE9以上正常，IE8报错：\n\n```\n对象不支持“getComputedStyle”属性或方法\n```\n\n### 获取元素样式方法之关于属性\n\n说点有趣又涨姿势的，当我们使用js获取元素属性值的时候，传入的属性可能跟你想象的不太一样，比如上面驼峰式的fontSize。或者看看下面这个奇葩的浮动属性：\nChrome浏览器下是cssFloat和float，\nFireFox浏览器下是cssFloat，IE7浏览器下则是styleFloat，而IE9浏览器下则是cssFloat和styleFloat都有，简直很变态啊有木有。\n\n那我们再来谈谈获取元素属性的另一个方法，getAttribute，它可以获取CSS样式申明对象上的属性值（直接属性名称），可以访问CSS样式对象的属性。\n使用getAttribute方法也不需要cssFloat与styleFloat的怪异写法与兼容性处理，但是属性名需要驼峰式写法。比如：\n\n\n``` js\nelement.getAttribute(\"float\");\n```\n\n\n``` js\nelement.getAttribute(\"fontSize\");\n```\n### 封装getStyle\n\n经过上面的了解，相信你已经可以写出一个封装获取样式的兼容写法，下面是一个简洁版：\n\n\n``` js\n//获取样式\nfunction getStyle(obj, attr) {\n\treturn obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj, false)[attr];\n}\n```\n\n\n\n","slug":"CSS学习笔记之获取元素CSS方法","published":1,"updated":"2020-07-16T13:56:47.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenmw0002p70vpz91dvbe","content":"<blockquote>\n<p>CSS 已经如此壮大,以致于一个普通人已经无法把它完整地装进自己的头脑了。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/css.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"从CSS样式说起\"><a href=\"#从CSS样式说起\" class=\"headerlink\" title=\"从CSS样式说起\"></a>从CSS样式说起</h3><p>最近一直在使用原生JavaScript，在获取元素的样式的时候发现了一些CSS的小秘密，关于CSS的style、currentStyle、getComputedStyle。什么？后面两个你没见过！！！在看了这篇文章之后你就知道了。</p>\n<p>在讲干货之前，我想我们应该来复习下关于CSS的基础。</p>\n<p>关于这个层叠样式表（CSS），在HTML文档里有三种表现形式。</p>\n<ol>\n<li>内联样式表</li>\n</ol>\n<p>内联样式表是指将CSS样式编码写在HTML标签中，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:16px;color:#000FFF\"</span>&gt;</span></span><br><span class=\"line\">内联CSS样式。</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>内联样式表由HTML元素的HTML元素的style支持，只需将CSS代码用分号隔开写在style=””之中。这是最基本的形式，但是它没有实现表现与内容分离且不能灵活的控制多个页面所以我们很少使用。</p>\n<ol start=\"2\">\n<li>内部样式表</li>\n</ol>\n<p>内部样式表与内联样式表相似都是把CSS代码写在HTML页面中，稍微不同的是前者可以将样式表放在一个固定的位置，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>内部样式表<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">   <span class=\"selector-tag\">h1</span>&#123;<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span></span><br><span class=\"line\"><span class=\"css\">      <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#000FFF</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>内部CSS样式。<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>内部样式表编码是初级的应用形式，不能跨页面使用所以不适合使用。</p>\n<ol start=\"3\">\n<li>外部样式表</li>\n</ol>\n<p>外部样式表是CSS应用中最好的一中形式，它将CSS样式代码单独放在一个外部文件中，再由网页进行调用。多个网页可以调用一个样式文件表，这样能够实现代码的最大限度的重用及网站文件的最优化配置，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>外部样式表<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">rev</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>外部CSS样式。<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在style.css中的代码为</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@charset</span> <span class=\"string\">\"UTF-8\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#000FFF</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<head><meta name=\"generator\" content=\"Hexo 3.9.0\">中使用了<link>标签来调用外部样式表文件。将link指定为stylesheet方式，并使用了href=”style.css”指明样式表文件的路径便可将该页面应用到在style.css中定义的样式。</head></p>\n<p>现在你已经知道了CSS的三种形式，那么它们和在JavaScript中获取元素又又怎样的关系呢？下面揭晓答案。</p>\n<h3 id=\"获取元素样式方法之style\"><a href=\"#获取元素样式方法之style\" class=\"headerlink\" title=\"获取元素样式方法之style\"></a>获取元素样式方法之style</h3><p>style是通过JavaScript语言来获取CSS的样式的一种最基本的方法，也是最为人所知的方法，它的使用方法是element.style.attr，可读可写。需要注意的是（前方高能），style只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。<br>神马？（童话里都是骗人的）。下面是验证代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>CSS样式<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"css/style.css\"</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-id\">#container</span>&#123;</span></span><br><span class=\"line\">    width: 300px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h1&#123;</span><br><span class=\"line\">    font-size: 13px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 400px;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size: 14px;\"</span>&gt;</span>CSS学习笔记之获取元素样式<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/task.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>style.css</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>task.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oDiv= <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> h1=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(oDiv.style.width); <span class=\"comment\">//400px</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(h1.style.fontSize); <span class=\"comment\">//14px</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们分别使用CSS的三种形式对container和h1设置不同的样式，通过js来获取具体值，最后得到的都是内联样式的值。而最终在网页中生效的也是内联样式的值，也表明三种方式中内联样式的优先级最高。</p>\n<h3 id=\"获取元素样式方法之currentStyle\"><a href=\"#获取元素样式方法之currentStyle\" class=\"headerlink\" title=\"获取元素样式方法之currentStyle\"></a>获取元素样式方法之currentStyle</h3><p>说到currentStyle，表示很遗憾，它只兼容IE浏览器，使用currentStyle返回的是元素当前应用的最终CSS属性值（包括外联CSS文件，页面中嵌入的style属性等）。<br>currentStyle的使用方法是element.currentStyle[“attr’]或者element.currentStyle.attr。<br>我们对js代码进行修改如下：</p>\n<p><strong>task.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oDiv= <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> h1=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(oDiv.currentStyle.width); <span class=\"comment\">//400px</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(h1.currentStyle.fontSize); <span class=\"comment\">//14px</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过测试，IE显示正常，Edge浏览器报错，Chrome报错如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">TypeError</span>: Cannot read property <span class=\"string\">'width'</span> <span class=\"keyword\">of</span> <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取元素样式方法之getComputedStyle\"><a href=\"#获取元素样式方法之getComputedStyle\" class=\"headerlink\" title=\"获取元素样式方法之getComputedStyle\"></a>获取元素样式方法之getComputedStyle</h3><p>getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，如果没有设置css样式，会读取默认样式，只读。它的使用方法是：<br>window.getComputedStyle(element, pseudoElt)[“attr’]或window.getComputedStyle(element, pseudoElt).attr。其中，pseudoElt表示如 :after,:before之类的伪类，如果不用伪类的话设置为null即可，不是必需参数。</p>\n<p>getComputedStyle同currentStyle作用相同，但是适用于Firefox、Opera、Safari、Chrome。<br>关于兼容性，getComputedStyle在IE6-8是不支持的。<br>我们修改代码如下：</p>\n<p><strong>task.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oDiv= <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> h1=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.getComputedStyle(oDiv).width); <span class=\"comment\">//400px</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.getComputedStyle(h1).fontSize); <span class=\"comment\">//14px</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>经过测试在Chrome和IE9以上正常，IE8报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">对象不支持“getComputedStyle”属性或方法</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取元素样式方法之关于属性\"><a href=\"#获取元素样式方法之关于属性\" class=\"headerlink\" title=\"获取元素样式方法之关于属性\"></a>获取元素样式方法之关于属性</h3><p>说点有趣又涨姿势的，当我们使用js获取元素属性值的时候，传入的属性可能跟你想象的不太一样，比如上面驼峰式的fontSize。或者看看下面这个奇葩的浮动属性：<br>Chrome浏览器下是cssFloat和float，<br>FireFox浏览器下是cssFloat，IE7浏览器下则是styleFloat，而IE9浏览器下则是cssFloat和styleFloat都有，简直很变态啊有木有。</p>\n<p>那我们再来谈谈获取元素属性的另一个方法，getAttribute，它可以获取CSS样式申明对象上的属性值（直接属性名称），可以访问CSS样式对象的属性。<br>使用getAttribute方法也不需要cssFloat与styleFloat的怪异写法与兼容性处理，但是属性名需要驼峰式写法。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">element.getAttribute(<span class=\"string\">\"float\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">element.getAttribute(<span class=\"string\">\"fontSize\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装getStyle\"><a href=\"#封装getStyle\" class=\"headerlink\" title=\"封装getStyle\"></a>封装getStyle</h3><p>经过上面的了解，相信你已经可以写出一个封装获取样式的兼容写法，下面是一个简洁版：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取样式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStyle</span>(<span class=\"params\">obj, attr</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj, <span class=\"literal\">false</span>)[attr];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>CSS 已经如此壮大,以致于一个普通人已经无法把它完整地装进自己的头脑了。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/css.png\" alt=\"image\"></p>","more":"<h3 id=\"从CSS样式说起\"><a href=\"#从CSS样式说起\" class=\"headerlink\" title=\"从CSS样式说起\"></a>从CSS样式说起</h3><p>最近一直在使用原生JavaScript，在获取元素的样式的时候发现了一些CSS的小秘密，关于CSS的style、currentStyle、getComputedStyle。什么？后面两个你没见过！！！在看了这篇文章之后你就知道了。</p>\n<p>在讲干货之前，我想我们应该来复习下关于CSS的基础。</p>\n<p>关于这个层叠样式表（CSS），在HTML文档里有三种表现形式。</p>\n<ol>\n<li>内联样式表</li>\n</ol>\n<p>内联样式表是指将CSS样式编码写在HTML标签中，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size:16px;color:#000FFF\"</span>&gt;</span></span><br><span class=\"line\">内联CSS样式。</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>内联样式表由HTML元素的HTML元素的style支持，只需将CSS代码用分号隔开写在style=””之中。这是最基本的形式，但是它没有实现表现与内容分离且不能灵活的控制多个页面所以我们很少使用。</p>\n<ol start=\"2\">\n<li>内部样式表</li>\n</ol>\n<p>内部样式表与内联样式表相似都是把CSS代码写在HTML页面中，稍微不同的是前者可以将样式表放在一个固定的位置，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>内部样式表<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">   <span class=\"selector-tag\">h1</span>&#123;<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span></span><br><span class=\"line\"><span class=\"css\">      <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#000FFF</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>内部CSS样式。<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>内部样式表编码是初级的应用形式，不能跨页面使用所以不适合使用。</p>\n<ol start=\"3\">\n<li>外部样式表</li>\n</ol>\n<p>外部样式表是CSS应用中最好的一中形式，它将CSS样式代码单独放在一个外部文件中，再由网页进行调用。多个网页可以调用一个样式文件表，这样能够实现代码的最大限度的重用及网站文件的最优化配置，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>外部样式表<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">rev</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>外部CSS样式。<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在style.css中的代码为</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@charset</span> <span class=\"string\">\"UTF-8\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#000FFF</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<head><meta name=\"generator\" content=\"Hexo 3.9.0\">中使用了<link>标签来调用外部样式表文件。将link指定为stylesheet方式，并使用了href=”style.css”指明样式表文件的路径便可将该页面应用到在style.css中定义的样式。</head></p>\n<p>现在你已经知道了CSS的三种形式，那么它们和在JavaScript中获取元素又又怎样的关系呢？下面揭晓答案。</p>\n<h3 id=\"获取元素样式方法之style\"><a href=\"#获取元素样式方法之style\" class=\"headerlink\" title=\"获取元素样式方法之style\"></a>获取元素样式方法之style</h3><p>style是通过JavaScript语言来获取CSS的样式的一种最基本的方法，也是最为人所知的方法，它的使用方法是element.style.attr，可读可写。需要注意的是（前方高能），style只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。<br>神马？（童话里都是骗人的）。下面是验证代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>CSS样式<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"css/style.css\"</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-id\">#container</span>&#123;</span></span><br><span class=\"line\">    width: 300px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h1&#123;</span><br><span class=\"line\">    font-size: 13px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 400px;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">style</span>=<span class=\"string\">\"font-size: 14px;\"</span>&gt;</span>CSS学习笔记之获取元素样式<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/task.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>style.css</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#container</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>&#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>task.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oDiv= <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> h1=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(oDiv.style.width); <span class=\"comment\">//400px</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(h1.style.fontSize); <span class=\"comment\">//14px</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们分别使用CSS的三种形式对container和h1设置不同的样式，通过js来获取具体值，最后得到的都是内联样式的值。而最终在网页中生效的也是内联样式的值，也表明三种方式中内联样式的优先级最高。</p>\n<h3 id=\"获取元素样式方法之currentStyle\"><a href=\"#获取元素样式方法之currentStyle\" class=\"headerlink\" title=\"获取元素样式方法之currentStyle\"></a>获取元素样式方法之currentStyle</h3><p>说到currentStyle，表示很遗憾，它只兼容IE浏览器，使用currentStyle返回的是元素当前应用的最终CSS属性值（包括外联CSS文件，页面中嵌入的style属性等）。<br>currentStyle的使用方法是element.currentStyle[“attr’]或者element.currentStyle.attr。<br>我们对js代码进行修改如下：</p>\n<p><strong>task.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oDiv= <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> h1=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(oDiv.currentStyle.width); <span class=\"comment\">//400px</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(h1.currentStyle.fontSize); <span class=\"comment\">//14px</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过测试，IE显示正常，Edge浏览器报错，Chrome报错如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">TypeError</span>: Cannot read property <span class=\"string\">'width'</span> <span class=\"keyword\">of</span> <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取元素样式方法之getComputedStyle\"><a href=\"#获取元素样式方法之getComputedStyle\" class=\"headerlink\" title=\"获取元素样式方法之getComputedStyle\"></a>获取元素样式方法之getComputedStyle</h3><p>getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，如果没有设置css样式，会读取默认样式，只读。它的使用方法是：<br>window.getComputedStyle(element, pseudoElt)[“attr’]或window.getComputedStyle(element, pseudoElt).attr。其中，pseudoElt表示如 :after,:before之类的伪类，如果不用伪类的话设置为null即可，不是必需参数。</p>\n<p>getComputedStyle同currentStyle作用相同，但是适用于Firefox、Opera、Safari、Chrome。<br>关于兼容性，getComputedStyle在IE6-8是不支持的。<br>我们修改代码如下：</p>\n<p><strong>task.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oDiv= <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> h1=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.getComputedStyle(oDiv).width); <span class=\"comment\">//400px</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.getComputedStyle(h1).fontSize); <span class=\"comment\">//14px</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>经过测试在Chrome和IE9以上正常，IE8报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">对象不支持“getComputedStyle”属性或方法</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取元素样式方法之关于属性\"><a href=\"#获取元素样式方法之关于属性\" class=\"headerlink\" title=\"获取元素样式方法之关于属性\"></a>获取元素样式方法之关于属性</h3><p>说点有趣又涨姿势的，当我们使用js获取元素属性值的时候，传入的属性可能跟你想象的不太一样，比如上面驼峰式的fontSize。或者看看下面这个奇葩的浮动属性：<br>Chrome浏览器下是cssFloat和float，<br>FireFox浏览器下是cssFloat，IE7浏览器下则是styleFloat，而IE9浏览器下则是cssFloat和styleFloat都有，简直很变态啊有木有。</p>\n<p>那我们再来谈谈获取元素属性的另一个方法，getAttribute，它可以获取CSS样式申明对象上的属性值（直接属性名称），可以访问CSS样式对象的属性。<br>使用getAttribute方法也不需要cssFloat与styleFloat的怪异写法与兼容性处理，但是属性名需要驼峰式写法。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">element.getAttribute(<span class=\"string\">\"float\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">element.getAttribute(<span class=\"string\">\"fontSize\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装getStyle\"><a href=\"#封装getStyle\" class=\"headerlink\" title=\"封装getStyle\"></a>封装getStyle</h3><p>经过上面的了解，相信你已经可以写出一个封装获取样式的兼容写法，下面是一个简洁版：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取样式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStyle</span>(<span class=\"params\">obj, attr</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj, <span class=\"literal\">false</span>)[attr];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript排序算法之选择排序和插入排序","date":"2018-12-02T12:01:37.000Z","banner":"http://img.yanyuanfe.cn/algorithm.jpg","_content":"\n> 学习数据结构和算法有助于写出性能更优的代码。\n\n![image](http://img.yanyuanfe.cn/algorithm.jpg)\n\n<!--more-->\n\n> 基础决定你可能达到的高度，而业务决定了你的最低瓶颈\n\n了解和学习JavaScript常用算法可以帮助前端开发者写出性能更好的代码，本文介绍排序算法中的两种时间复杂度为O(n^2)的算法，选择排序和插入排序。\n\n### 选择排序\n\n选择排序的原理是：对排序数组进行遍历，在遍历的过程中，对当前索引之后的数组进行遍历，找到最小元素的索引，将当前索引和最小元素的索引对应元素进行交换。\n\n``` js\nfunction swap(arr, a, b) {\n  [arr[a], arr[b]] = [arr[b], arr[a]];\n}\n\nfunction selectionSort(arr) {\n  for (let i = 0, len = arr.length; i < len; i ++) {\n    let minIndex = i;\n    for(let j = i + 1; j < len; j++) {\n      if(arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    swap(arr, i, minIndex);\n  }\n}\n\n```\n选择排序因为嵌套了两层循环，所以其时间复杂度为O(n^2)\n\n\n\n### 插入排序\n\n插入排序的原理与打扑克牌时按牌的大小整理顺序类似，从数组的第一项开始遍历，遍历过程中对于当前索引的左边数组从右向左进行大小比较，如果左边项大于右边项，则进行交换。否则退出当前循环。代码实现如下：\n\n``` js\nfunction insertionSort(arr) {\n  // 从1开始\n  for (let i = 1, len = arr.length; i < len; i ++) {\n    // 寻找元素合适的插入位置\n    for (let j = i; j > 0; j --) {\n      if (arr[j] < arr[j - 1]) {\n        swap(arr, j, j - 1);\n      } else {\n        break; // 退出当前循环\n      }\n    }\n  }\n}\n```\n在内层循环中，可以将比较两项大小的操作放到for循环中，以此来简化代码。\n\n``` js\nfunction insertionSort(arr) {\n  // 从1开始\n  for (let i = 1, len = arr.length; i < len; i ++) {\n    // 寻找元素合适的插入位置\n    for (let j = i; j > 0 && arr[j] < arr[j - 1]; j --) {\n      swap(arr, j, j - 1);\n    }\n  }\n}\n```\n对比选择排序和插入排序，两者都是进行了两层循环，时间复杂度为O(n^2)，但是从代码中看，插入排序在内层循环中会提前终止循环，是否表示插入排序的速度要优于选择排序呢？\n\n### 测试排序时间\n\n现在我们对两种排序算法进行测试，验证是否插入排序的速度优于选择排序？\n\n此处使用console.time和console.timeEnd来测试一段代码运行消耗的时间。console.time方法是开始计算时间，console.timeEnd是停止计时，输出代码执行的时间。\n使用方法如下：\n\n\n``` js\n// 计时开始\nconsole.time('test');\n\n// 测试时间的代码\n\n// 计时结束，输出时间\nconsole.timeEnd('test');\n\n// test:4522.303ms\n```\n这两个方法接收一个参数，作为计时器的名称。\n\n编写测试代码如下：\n\n\n``` js\nfunction testFuncTime(tag, fn, args) {\n  console.time(tag);\n  fn(args);\n  console.timeEnd(tag);\n}\n```\ntestFuncTime接收三个参数，分别是计时器名称，测试的方法，测试方法的参数。\n\n为了使测试结果更加明显，我们需要一个可以生成任意范围随机数的数组的方法。\n\n\n``` js\nfunction getRandom(start, end, n) {\n  let arr = [];\n  for(let i=0; i<n; i++) {\n    let choice = end - start + 1;\n    let value = Math.floor(Math.random() * choice + start);\n    arr.push(value);\n  }\n  return arr;\n}\n```\n编写getRandom方法用于生成在start和end之前的n个数字的随机数数组。\n\n下面是测试代码：\n\n\n``` js\nlet array = getRandom(1, 10000, 1000);\nlet array2 = [...array];\n\ntestFuncTime('selectionSort', selectionSort, array);\ntestFuncTime('insertionSort', insertionSort, array2);\n\nconsole.log(array);\nconsole.log(array2);\n```\n在上述代码中，生成了一个范围在1-10000，长度为1000的随机数数组array，并且拷贝一份赋值给array2，然后运行testFuncTime进行测试，最终输出排序结果。\n结果如下：\n\n![排序测试](http://img.yanyuanfe.cn/sortTest1.png)\n可以看到插入排序的耗时大约是选择排序的三倍，恰恰和预期相反，那究竟是为什么呢？\n\n原因就是：选择排序内层遍历一次取到最小值的索引，每次只需要一次交换（swap）操作。但是插入排序在内层遍历的时候，会从右向左依次比较大小再交换，而\n交换操作又是最耗时的。\n\n下面我们对插入排序的实现进行优化。\n\n### 优化插入排序\n\n``` js\nfunction insertionSort(arr) {\n  // 从1开始\n  for (let i = 1, len = arr.length; i < len; i ++) {\n    // 寻找元素合适的插入位置\n    let e = arr[i];\n    let j; // j保存元素e应该插入的位置\n    for (j = i; j > 0 && arr[j - 1] > e; j --) {\n      arr[j] = arr[j - 1];\n    }\n    arr[j] = e;\n  }\n}\n```\n在上述代码中，对插入排序进行优化，在外层循环中，首先，声明一个变量e来保存当前元素，并且声明变量j来保存元素e应该插入的位置，在内层循环中，如果左边项大于当前项，则将左边项赋值到当前项，变量j不断向左移动，直到循环结束，将待排序元素e赋值给arr[j]。\n\n我们声明了新的变量，使用赋值操作来代替交换操作，优化了性能。下面对优化后的代码进行测试。\n\n![排序测试](http://img.yanyuanfe.cn/sortTest2.png)\n\n从上述图片可以看出，优化后的插入排序耗时为选择排序的一半左右，性能有了相当大的提升。\n\n\n### 总结\n\n本文使用JavaScript实现了时间复杂度为O(n^2)\n的两种排序算法，对于选择排序来说，它的缺点是两层循环都必须完整得执行完成所以它的效率在任何条件下都是非常慢的。相比之下，虽然插入排序在最差的情况下复杂度为O(n^2)，但是在实际的应用中，O(n^2)复杂度的排序算法并非是一无是处的，它可以作为更加复杂排序算法的子过程进行优化，并且，对于近乎有序的数组来讲（系统日志按时间生成），性能比O(nlogn)级别的排序算法还要快，在完全有序的数组中，插入排序的复杂度可以达到O(n)。","source":"_posts/JavaScript排序算法之选择排序和插入排序.md","raw":"---\ntitle: JavaScript排序算法之选择排序和插入排序\ndate: 2018-12-2 20:01:37\nbanner: http://img.yanyuanfe.cn/algorithm.jpg\ntags:\n - 算法\n---\n\n> 学习数据结构和算法有助于写出性能更优的代码。\n\n![image](http://img.yanyuanfe.cn/algorithm.jpg)\n\n<!--more-->\n\n> 基础决定你可能达到的高度，而业务决定了你的最低瓶颈\n\n了解和学习JavaScript常用算法可以帮助前端开发者写出性能更好的代码，本文介绍排序算法中的两种时间复杂度为O(n^2)的算法，选择排序和插入排序。\n\n### 选择排序\n\n选择排序的原理是：对排序数组进行遍历，在遍历的过程中，对当前索引之后的数组进行遍历，找到最小元素的索引，将当前索引和最小元素的索引对应元素进行交换。\n\n``` js\nfunction swap(arr, a, b) {\n  [arr[a], arr[b]] = [arr[b], arr[a]];\n}\n\nfunction selectionSort(arr) {\n  for (let i = 0, len = arr.length; i < len; i ++) {\n    let minIndex = i;\n    for(let j = i + 1; j < len; j++) {\n      if(arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    swap(arr, i, minIndex);\n  }\n}\n\n```\n选择排序因为嵌套了两层循环，所以其时间复杂度为O(n^2)\n\n\n\n### 插入排序\n\n插入排序的原理与打扑克牌时按牌的大小整理顺序类似，从数组的第一项开始遍历，遍历过程中对于当前索引的左边数组从右向左进行大小比较，如果左边项大于右边项，则进行交换。否则退出当前循环。代码实现如下：\n\n``` js\nfunction insertionSort(arr) {\n  // 从1开始\n  for (let i = 1, len = arr.length; i < len; i ++) {\n    // 寻找元素合适的插入位置\n    for (let j = i; j > 0; j --) {\n      if (arr[j] < arr[j - 1]) {\n        swap(arr, j, j - 1);\n      } else {\n        break; // 退出当前循环\n      }\n    }\n  }\n}\n```\n在内层循环中，可以将比较两项大小的操作放到for循环中，以此来简化代码。\n\n``` js\nfunction insertionSort(arr) {\n  // 从1开始\n  for (let i = 1, len = arr.length; i < len; i ++) {\n    // 寻找元素合适的插入位置\n    for (let j = i; j > 0 && arr[j] < arr[j - 1]; j --) {\n      swap(arr, j, j - 1);\n    }\n  }\n}\n```\n对比选择排序和插入排序，两者都是进行了两层循环，时间复杂度为O(n^2)，但是从代码中看，插入排序在内层循环中会提前终止循环，是否表示插入排序的速度要优于选择排序呢？\n\n### 测试排序时间\n\n现在我们对两种排序算法进行测试，验证是否插入排序的速度优于选择排序？\n\n此处使用console.time和console.timeEnd来测试一段代码运行消耗的时间。console.time方法是开始计算时间，console.timeEnd是停止计时，输出代码执行的时间。\n使用方法如下：\n\n\n``` js\n// 计时开始\nconsole.time('test');\n\n// 测试时间的代码\n\n// 计时结束，输出时间\nconsole.timeEnd('test');\n\n// test:4522.303ms\n```\n这两个方法接收一个参数，作为计时器的名称。\n\n编写测试代码如下：\n\n\n``` js\nfunction testFuncTime(tag, fn, args) {\n  console.time(tag);\n  fn(args);\n  console.timeEnd(tag);\n}\n```\ntestFuncTime接收三个参数，分别是计时器名称，测试的方法，测试方法的参数。\n\n为了使测试结果更加明显，我们需要一个可以生成任意范围随机数的数组的方法。\n\n\n``` js\nfunction getRandom(start, end, n) {\n  let arr = [];\n  for(let i=0; i<n; i++) {\n    let choice = end - start + 1;\n    let value = Math.floor(Math.random() * choice + start);\n    arr.push(value);\n  }\n  return arr;\n}\n```\n编写getRandom方法用于生成在start和end之前的n个数字的随机数数组。\n\n下面是测试代码：\n\n\n``` js\nlet array = getRandom(1, 10000, 1000);\nlet array2 = [...array];\n\ntestFuncTime('selectionSort', selectionSort, array);\ntestFuncTime('insertionSort', insertionSort, array2);\n\nconsole.log(array);\nconsole.log(array2);\n```\n在上述代码中，生成了一个范围在1-10000，长度为1000的随机数数组array，并且拷贝一份赋值给array2，然后运行testFuncTime进行测试，最终输出排序结果。\n结果如下：\n\n![排序测试](http://img.yanyuanfe.cn/sortTest1.png)\n可以看到插入排序的耗时大约是选择排序的三倍，恰恰和预期相反，那究竟是为什么呢？\n\n原因就是：选择排序内层遍历一次取到最小值的索引，每次只需要一次交换（swap）操作。但是插入排序在内层遍历的时候，会从右向左依次比较大小再交换，而\n交换操作又是最耗时的。\n\n下面我们对插入排序的实现进行优化。\n\n### 优化插入排序\n\n``` js\nfunction insertionSort(arr) {\n  // 从1开始\n  for (let i = 1, len = arr.length; i < len; i ++) {\n    // 寻找元素合适的插入位置\n    let e = arr[i];\n    let j; // j保存元素e应该插入的位置\n    for (j = i; j > 0 && arr[j - 1] > e; j --) {\n      arr[j] = arr[j - 1];\n    }\n    arr[j] = e;\n  }\n}\n```\n在上述代码中，对插入排序进行优化，在外层循环中，首先，声明一个变量e来保存当前元素，并且声明变量j来保存元素e应该插入的位置，在内层循环中，如果左边项大于当前项，则将左边项赋值到当前项，变量j不断向左移动，直到循环结束，将待排序元素e赋值给arr[j]。\n\n我们声明了新的变量，使用赋值操作来代替交换操作，优化了性能。下面对优化后的代码进行测试。\n\n![排序测试](http://img.yanyuanfe.cn/sortTest2.png)\n\n从上述图片可以看出，优化后的插入排序耗时为选择排序的一半左右，性能有了相当大的提升。\n\n\n### 总结\n\n本文使用JavaScript实现了时间复杂度为O(n^2)\n的两种排序算法，对于选择排序来说，它的缺点是两层循环都必须完整得执行完成所以它的效率在任何条件下都是非常慢的。相比之下，虽然插入排序在最差的情况下复杂度为O(n^2)，但是在实际的应用中，O(n^2)复杂度的排序算法并非是一无是处的，它可以作为更加复杂排序算法的子过程进行优化，并且，对于近乎有序的数组来讲（系统日志按时间生成），性能比O(nlogn)级别的排序算法还要快，在完全有序的数组中，插入排序的复杂度可以达到O(n)。","slug":"JavaScript排序算法之选择排序和插入排序","published":1,"updated":"2020-07-16T13:56:47.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenn00006p70vl06af9fb","content":"<blockquote>\n<p>学习数据结构和算法有助于写出性能更优的代码。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/algorithm.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<blockquote>\n<p>基础决定你可能达到的高度，而业务决定了你的最低瓶颈</p>\n</blockquote>\n<p>了解和学习JavaScript常用算法可以帮助前端开发者写出性能更好的代码，本文介绍排序算法中的两种时间复杂度为O(n^2)的算法，选择排序和插入排序。</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>选择排序的原理是：对排序数组进行遍历，在遍历的过程中，对当前索引之后的数组进行遍历，找到最小元素的索引，将当前索引和最小元素的索引对应元素进行交换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, a, b</span>) </span>&#123;</span><br><span class=\"line\">  [arr[a], arr[b]] = [arr[b], arr[a]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(arr, i, minIndex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>选择排序因为嵌套了两层循环，所以其时间复杂度为O(n^2)</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>插入排序的原理与打扑克牌时按牌的大小整理顺序类似，从数组的第一项开始遍历，遍历过程中对于当前索引的左边数组从右向左进行大小比较，如果左边项大于右边项，则进行交换。否则退出当前循环。代码实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找元素合适的插入位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span>; j --) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, j, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// 退出当前循环</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在内层循环中，可以将比较两项大小的操作放到for循环中，以此来简化代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找元素合适的插入位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class=\"number\">1</span>]; j --) &#123;</span><br><span class=\"line\">      swap(arr, j, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比选择排序和插入排序，两者都是进行了两层循环，时间复杂度为O(n^2)，但是从代码中看，插入排序在内层循环中会提前终止循环，是否表示插入排序的速度要优于选择排序呢？</p>\n<h3 id=\"测试排序时间\"><a href=\"#测试排序时间\" class=\"headerlink\" title=\"测试排序时间\"></a>测试排序时间</h3><p>现在我们对两种排序算法进行测试，验证是否插入排序的速度优于选择排序？</p>\n<p>此处使用console.time和console.timeEnd来测试一段代码运行消耗的时间。console.time方法是开始计算时间，console.timeEnd是停止计时，输出代码执行的时间。<br>使用方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计时开始</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'test'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试时间的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计时结束，输出时间</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'test'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test:4522.303ms</span></span><br></pre></td></tr></table></figure>\n<p>这两个方法接收一个参数，作为计时器的名称。</p>\n<p>编写测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFuncTime</span>(<span class=\"params\">tag, fn, args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(tag);</span><br><span class=\"line\">  fn(args);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.timeEnd(tag);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>testFuncTime接收三个参数，分别是计时器名称，测试的方法，测试方法的参数。</p>\n<p>为了使测试结果更加明显，我们需要一个可以生成任意范围随机数的数组的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandom</span>(<span class=\"params\">start, end, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> choice = end - start + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * choice + start);</span><br><span class=\"line\">    arr.push(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写getRandom方法用于生成在start和end之前的n个数字的随机数数组。</p>\n<p>下面是测试代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = getRandom(<span class=\"number\">1</span>, <span class=\"number\">10000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> array2 = [...array];</span><br><span class=\"line\"></span><br><span class=\"line\">testFuncTime(<span class=\"string\">'selectionSort'</span>, selectionSort, array);</span><br><span class=\"line\">testFuncTime(<span class=\"string\">'insertionSort'</span>, insertionSort, array2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array2);</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，生成了一个范围在1-10000，长度为1000的随机数数组array，并且拷贝一份赋值给array2，然后运行testFuncTime进行测试，最终输出排序结果。<br>结果如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/sortTest1.png\" alt=\"排序测试\"><br>可以看到插入排序的耗时大约是选择排序的三倍，恰恰和预期相反，那究竟是为什么呢？</p>\n<p>原因就是：选择排序内层遍历一次取到最小值的索引，每次只需要一次交换（swap）操作。但是插入排序在内层遍历的时候，会从右向左依次比较大小再交换，而<br>交换操作又是最耗时的。</p>\n<p>下面我们对插入排序的实现进行优化。</p>\n<h3 id=\"优化插入排序\"><a href=\"#优化插入排序\" class=\"headerlink\" title=\"优化插入排序\"></a>优化插入排序</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找元素合适的插入位置</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j; <span class=\"comment\">// j保存元素e应该插入的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = i; j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j - <span class=\"number\">1</span>] &gt; e; j --) &#123;</span><br><span class=\"line\">      arr[j] = arr[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j] = e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，对插入排序进行优化，在外层循环中，首先，声明一个变量e来保存当前元素，并且声明变量j来保存元素e应该插入的位置，在内层循环中，如果左边项大于当前项，则将左边项赋值到当前项，变量j不断向左移动，直到循环结束，将待排序元素e赋值给arr[j]。</p>\n<p>我们声明了新的变量，使用赋值操作来代替交换操作，优化了性能。下面对优化后的代码进行测试。</p>\n<p><img src=\"http://img.yanyuanfe.cn/sortTest2.png\" alt=\"排序测试\"></p>\n<p>从上述图片可以看出，优化后的插入排序耗时为选择排序的一半左右，性能有了相当大的提升。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文使用JavaScript实现了时间复杂度为O(n^2)<br>的两种排序算法，对于选择排序来说，它的缺点是两层循环都必须完整得执行完成所以它的效率在任何条件下都是非常慢的。相比之下，虽然插入排序在最差的情况下复杂度为O(n^2)，但是在实际的应用中，O(n^2)复杂度的排序算法并非是一无是处的，它可以作为更加复杂排序算法的子过程进行优化，并且，对于近乎有序的数组来讲（系统日志按时间生成），性能比O(nlogn)级别的排序算法还要快，在完全有序的数组中，插入排序的复杂度可以达到O(n)。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>学习数据结构和算法有助于写出性能更优的代码。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/algorithm.jpg\" alt=\"image\"></p>","more":"<blockquote>\n<p>基础决定你可能达到的高度，而业务决定了你的最低瓶颈</p>\n</blockquote>\n<p>了解和学习JavaScript常用算法可以帮助前端开发者写出性能更好的代码，本文介绍排序算法中的两种时间复杂度为O(n^2)的算法，选择排序和插入排序。</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>选择排序的原理是：对排序数组进行遍历，在遍历的过程中，对当前索引之后的数组进行遍历，找到最小元素的索引，将当前索引和最小元素的索引对应元素进行交换。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, a, b</span>) </span>&#123;</span><br><span class=\"line\">  [arr[a], arr[b]] = [arr[b], arr[a]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(arr, i, minIndex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>选择排序因为嵌套了两层循环，所以其时间复杂度为O(n^2)</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>插入排序的原理与打扑克牌时按牌的大小整理顺序类似，从数组的第一项开始遍历，遍历过程中对于当前索引的左边数组从右向左进行大小比较，如果左边项大于右边项，则进行交换。否则退出当前循环。代码实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找元素合适的插入位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span>; j --) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, j, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// 退出当前循环</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在内层循环中，可以将比较两项大小的操作放到for循环中，以此来简化代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找元素合适的插入位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class=\"number\">1</span>]; j --) &#123;</span><br><span class=\"line\">      swap(arr, j, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比选择排序和插入排序，两者都是进行了两层循环，时间复杂度为O(n^2)，但是从代码中看，插入排序在内层循环中会提前终止循环，是否表示插入排序的速度要优于选择排序呢？</p>\n<h3 id=\"测试排序时间\"><a href=\"#测试排序时间\" class=\"headerlink\" title=\"测试排序时间\"></a>测试排序时间</h3><p>现在我们对两种排序算法进行测试，验证是否插入排序的速度优于选择排序？</p>\n<p>此处使用console.time和console.timeEnd来测试一段代码运行消耗的时间。console.time方法是开始计算时间，console.timeEnd是停止计时，输出代码执行的时间。<br>使用方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计时开始</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'test'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试时间的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计时结束，输出时间</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'test'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test:4522.303ms</span></span><br></pre></td></tr></table></figure>\n<p>这两个方法接收一个参数，作为计时器的名称。</p>\n<p>编写测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFuncTime</span>(<span class=\"params\">tag, fn, args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(tag);</span><br><span class=\"line\">  fn(args);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.timeEnd(tag);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>testFuncTime接收三个参数，分别是计时器名称，测试的方法，测试方法的参数。</p>\n<p>为了使测试结果更加明显，我们需要一个可以生成任意范围随机数的数组的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandom</span>(<span class=\"params\">start, end, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> choice = end - start + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * choice + start);</span><br><span class=\"line\">    arr.push(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写getRandom方法用于生成在start和end之前的n个数字的随机数数组。</p>\n<p>下面是测试代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = getRandom(<span class=\"number\">1</span>, <span class=\"number\">10000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> array2 = [...array];</span><br><span class=\"line\"></span><br><span class=\"line\">testFuncTime(<span class=\"string\">'selectionSort'</span>, selectionSort, array);</span><br><span class=\"line\">testFuncTime(<span class=\"string\">'insertionSort'</span>, insertionSort, array2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array2);</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，生成了一个范围在1-10000，长度为1000的随机数数组array，并且拷贝一份赋值给array2，然后运行testFuncTime进行测试，最终输出排序结果。<br>结果如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/sortTest1.png\" alt=\"排序测试\"><br>可以看到插入排序的耗时大约是选择排序的三倍，恰恰和预期相反，那究竟是为什么呢？</p>\n<p>原因就是：选择排序内层遍历一次取到最小值的索引，每次只需要一次交换（swap）操作。但是插入排序在内层遍历的时候，会从右向左依次比较大小再交换，而<br>交换操作又是最耗时的。</p>\n<p>下面我们对插入排序的实现进行优化。</p>\n<h3 id=\"优化插入排序\"><a href=\"#优化插入排序\" class=\"headerlink\" title=\"优化插入排序\"></a>优化插入排序</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找元素合适的插入位置</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j; <span class=\"comment\">// j保存元素e应该插入的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = i; j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j - <span class=\"number\">1</span>] &gt; e; j --) &#123;</span><br><span class=\"line\">      arr[j] = arr[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j] = e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，对插入排序进行优化，在外层循环中，首先，声明一个变量e来保存当前元素，并且声明变量j来保存元素e应该插入的位置，在内层循环中，如果左边项大于当前项，则将左边项赋值到当前项，变量j不断向左移动，直到循环结束，将待排序元素e赋值给arr[j]。</p>\n<p>我们声明了新的变量，使用赋值操作来代替交换操作，优化了性能。下面对优化后的代码进行测试。</p>\n<p><img src=\"http://img.yanyuanfe.cn/sortTest2.png\" alt=\"排序测试\"></p>\n<p>从上述图片可以看出，优化后的插入排序耗时为选择排序的一半左右，性能有了相当大的提升。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文使用JavaScript实现了时间复杂度为O(n^2)<br>的两种排序算法，对于选择排序来说，它的缺点是两层循环都必须完整得执行完成所以它的效率在任何条件下都是非常慢的。相比之下，虽然插入排序在最差的情况下复杂度为O(n^2)，但是在实际的应用中，O(n^2)复杂度的排序算法并非是一无是处的，它可以作为更加复杂排序算法的子过程进行优化，并且，对于近乎有序的数组来讲（系统日志按时间生成），性能比O(nlogn)级别的排序算法还要快，在完全有序的数组中，插入排序的复杂度可以达到O(n)。</p>"},{"title":"React Native 封装HTTP请求","date":"2018-01-04T09:45:06.000Z","banner":"http://img.yanyuanfe.cn/QQ20160705-3.png","_content":"\n> 作为一个前端开发者，我觉得React Native也是一个很酷的东西，本文不涉及React Native的开发相关，只是总结了开发中的一些最佳实践。不仅仅适合React Native。\n\n![image](http://img.yanyuanfe.cn/react_1_1x.jpg)\n\n<!--more-->\n\n在进行项目开发时，我们都会将公共的模块抽离出来。在学习React Native的过程中，我也遇到了同样的场景，在此记录下来。React Native使用fetch作为网络请求库，而每个几乎每个模块都需要用到网络请求，那么将其抽离为公共模块甚为必要。\n### 封装HTTP模块的优点\n- 代码复用  \n\n由于很多模块都会用到HTTP请求，将fetch封装为公共模块可以复用很多代码\n\n- 高内聚低耦合\n\n将公共部分提取出来，可以使每个模块专注于自身的业务逻辑\n\n- 便于项目的扩展与后期的维护，并且做到职责分离\n\n\n### 具体做法\n\n首先，在项目根目录下新建utils目录，在utils目录中，新建fetch.js。\n\n要想在其他模块中使用整个模块，首先，我们要将其导出为一个模块供其他模块使用。\n\n``` js\nexport default class fetchUtils {\n    \n}\n```\nfetchUtils模块中应该包含两个方法，分别是get和post的请求方法，下一步，来编写get方法。\n\n\n``` js\nstatic get(url) {\n    return new Promise((resolve, reject) => {\n      fetch(url)\n          .then(response => response.json())\n          .then((result) => {\n              resolve(result);\n          })\n          .catch(error => {\n              reject(error);\n          })\n\n    })\n}\n```\nget方法应该是一个静态方法，接受一个参数url，其返回一个Promise，Promise接受两个参数resolve和reject，用于处理成功和失败的情况，在Promise中，使用fetch发起get请求，然后使用链式函数then来处理服务器返回结果，先取出json数据，当服务器成功返回数据，使用resolve返回结果；当发生错误时，调用catch方法捕获错误。\n\n下面是post方法。\n\n``` js\nstatic post(url, data) {\n    return new Promise((resolve, reject) => {\n        fech(url, {\n            method: 'POST',\n            header: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        })\n        .then(response => response.json())\n        .then((result) => {\n            resolve(result);\n        })\n        .catch(error => {\n            reject(error);\n        })\n    })\n}\n```\npost方法与get方法类似，也是静态方法，post方法接受两个参数，分别是url和提交的数据data。同样的，post方法返回一个Promise，参数与get方法一样，然后向服务器发送POST请求，post请求需要设置method为POST，还需要设置请求头，请求头包含接受的数据类型和Content-Type，均设置为application/json，最后将用户提交的数据放到body中，使用JSON序列化data。然后需要接受服务器返回的数据，这里与get方法一样，不再赘述。\n\n\n以上就是封装好的HTTP请求模块。下面看一下如何使用。\n\n首先，将fetchUtils导入。\n\n\n```\nimport fetchUtils from '../utils/fetch'\n```\n\n\n\n**get方法**\n\n\n``` js\nfetchUtils.get(url)\n    .then(result => {\n        this.setState({result: JSON.stringify(result)})\n    })\n    .catch(error => {\n         this.setState({result: JSON.stringify(error)})\n    })\n```\n\n**post方法**\n\n\n``` js\nfetchUtils.post(url, data)\n    .then(result => {\n        this.setState({result: JSON.stringify(result)})\n    })\n    .catch(error => {\n         this.setState({result: JSON.stringify(error)})\n    })\n```\n### 总结\n\n通过以上对fetch方法的封装，使代码更加精简，业务逻辑更加清晰，也更加容易维护。此处使用React Native为例只是项目开发的一个缩影，这种封装思想是可以在工作中借鉴的。\n\n","source":"_posts/React Native 封装HTTP请求.md","raw":"---\ntitle: \"React Native 封装HTTP请求\"\ndate: 2018-01-04 17:45:06\nbanner: http://img.yanyuanfe.cn/QQ20160705-3.png\ntags:\n - React Native\n---\n\n> 作为一个前端开发者，我觉得React Native也是一个很酷的东西，本文不涉及React Native的开发相关，只是总结了开发中的一些最佳实践。不仅仅适合React Native。\n\n![image](http://img.yanyuanfe.cn/react_1_1x.jpg)\n\n<!--more-->\n\n在进行项目开发时，我们都会将公共的模块抽离出来。在学习React Native的过程中，我也遇到了同样的场景，在此记录下来。React Native使用fetch作为网络请求库，而每个几乎每个模块都需要用到网络请求，那么将其抽离为公共模块甚为必要。\n### 封装HTTP模块的优点\n- 代码复用  \n\n由于很多模块都会用到HTTP请求，将fetch封装为公共模块可以复用很多代码\n\n- 高内聚低耦合\n\n将公共部分提取出来，可以使每个模块专注于自身的业务逻辑\n\n- 便于项目的扩展与后期的维护，并且做到职责分离\n\n\n### 具体做法\n\n首先，在项目根目录下新建utils目录，在utils目录中，新建fetch.js。\n\n要想在其他模块中使用整个模块，首先，我们要将其导出为一个模块供其他模块使用。\n\n``` js\nexport default class fetchUtils {\n    \n}\n```\nfetchUtils模块中应该包含两个方法，分别是get和post的请求方法，下一步，来编写get方法。\n\n\n``` js\nstatic get(url) {\n    return new Promise((resolve, reject) => {\n      fetch(url)\n          .then(response => response.json())\n          .then((result) => {\n              resolve(result);\n          })\n          .catch(error => {\n              reject(error);\n          })\n\n    })\n}\n```\nget方法应该是一个静态方法，接受一个参数url，其返回一个Promise，Promise接受两个参数resolve和reject，用于处理成功和失败的情况，在Promise中，使用fetch发起get请求，然后使用链式函数then来处理服务器返回结果，先取出json数据，当服务器成功返回数据，使用resolve返回结果；当发生错误时，调用catch方法捕获错误。\n\n下面是post方法。\n\n``` js\nstatic post(url, data) {\n    return new Promise((resolve, reject) => {\n        fech(url, {\n            method: 'POST',\n            header: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        })\n        .then(response => response.json())\n        .then((result) => {\n            resolve(result);\n        })\n        .catch(error => {\n            reject(error);\n        })\n    })\n}\n```\npost方法与get方法类似，也是静态方法，post方法接受两个参数，分别是url和提交的数据data。同样的，post方法返回一个Promise，参数与get方法一样，然后向服务器发送POST请求，post请求需要设置method为POST，还需要设置请求头，请求头包含接受的数据类型和Content-Type，均设置为application/json，最后将用户提交的数据放到body中，使用JSON序列化data。然后需要接受服务器返回的数据，这里与get方法一样，不再赘述。\n\n\n以上就是封装好的HTTP请求模块。下面看一下如何使用。\n\n首先，将fetchUtils导入。\n\n\n```\nimport fetchUtils from '../utils/fetch'\n```\n\n\n\n**get方法**\n\n\n``` js\nfetchUtils.get(url)\n    .then(result => {\n        this.setState({result: JSON.stringify(result)})\n    })\n    .catch(error => {\n         this.setState({result: JSON.stringify(error)})\n    })\n```\n\n**post方法**\n\n\n``` js\nfetchUtils.post(url, data)\n    .then(result => {\n        this.setState({result: JSON.stringify(result)})\n    })\n    .catch(error => {\n         this.setState({result: JSON.stringify(error)})\n    })\n```\n### 总结\n\n通过以上对fetch方法的封装，使代码更加精简，业务逻辑更加清晰，也更加容易维护。此处使用React Native为例只是项目开发的一个缩影，这种封装思想是可以在工作中借鉴的。\n\n","slug":"React Native 封装HTTP请求","published":1,"updated":"2020-07-16T13:56:47.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenn20007p70vz70650lb","content":"<blockquote>\n<p>作为一个前端开发者，我觉得React Native也是一个很酷的东西，本文不涉及React Native的开发相关，只是总结了开发中的一些最佳实践。不仅仅适合React Native。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react_1_1x.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>在进行项目开发时，我们都会将公共的模块抽离出来。在学习React Native的过程中，我也遇到了同样的场景，在此记录下来。React Native使用fetch作为网络请求库，而每个几乎每个模块都需要用到网络请求，那么将其抽离为公共模块甚为必要。</p>\n<h3 id=\"封装HTTP模块的优点\"><a href=\"#封装HTTP模块的优点\" class=\"headerlink\" title=\"封装HTTP模块的优点\"></a>封装HTTP模块的优点</h3><ul>\n<li>代码复用  </li>\n</ul>\n<p>由于很多模块都会用到HTTP请求，将fetch封装为公共模块可以复用很多代码</p>\n<ul>\n<li>高内聚低耦合</li>\n</ul>\n<p>将公共部分提取出来，可以使每个模块专注于自身的业务逻辑</p>\n<ul>\n<li>便于项目的扩展与后期的维护，并且做到职责分离</li>\n</ul>\n<h3 id=\"具体做法\"><a href=\"#具体做法\" class=\"headerlink\" title=\"具体做法\"></a>具体做法</h3><p>首先，在项目根目录下新建utils目录，在utils目录中，新建fetch.js。</p>\n<p>要想在其他模块中使用整个模块，首先，我们要将其导出为一个模块供其他模块使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">fetchUtils</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fetchUtils模块中应该包含两个方法，分别是get和post的请求方法，下一步，来编写get方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">get</span>(url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      fetch(url)</span><br><span class=\"line\">          .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">          .then(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              resolve(result);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">              reject(error);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get方法应该是一个静态方法，接受一个参数url，其返回一个Promise，Promise接受两个参数resolve和reject，用于处理成功和失败的情况，在Promise中，使用fetch发起get请求，然后使用链式函数then来处理服务器返回结果，先取出json数据，当服务器成功返回数据，使用resolve返回结果；当发生错误时，调用catch方法捕获错误。</p>\n<p>下面是post方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> post(url, data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        fech(url, &#123;</span><br><span class=\"line\">            method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">            header: &#123;</span><br><span class=\"line\">                <span class=\"string\">'Accept'</span>: <span class=\"string\">'application/json'</span>,</span><br><span class=\"line\">                <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            body: <span class=\"built_in\">JSON</span>.stringify(data)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(result);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">            reject(error);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>post方法与get方法类似，也是静态方法，post方法接受两个参数，分别是url和提交的数据data。同样的，post方法返回一个Promise，参数与get方法一样，然后向服务器发送POST请求，post请求需要设置method为POST，还需要设置请求头，请求头包含接受的数据类型和Content-Type，均设置为application/json，最后将用户提交的数据放到body中，使用JSON序列化data。然后需要接受服务器返回的数据，这里与get方法一样，不再赘述。</p>\n<p>以上就是封装好的HTTP请求模块。下面看一下如何使用。</p>\n<p>首先，将fetchUtils导入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import fetchUtils from &apos;../utils/fetch&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>get方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetchUtils.get(url)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(result)&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(error)&#125;)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>post方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetchUtils.post(url, data)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(result)&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(error)&#125;)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上对fetch方法的封装，使代码更加精简，业务逻辑更加清晰，也更加容易维护。此处使用React Native为例只是项目开发的一个缩影，这种封装思想是可以在工作中借鉴的。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>作为一个前端开发者，我觉得React Native也是一个很酷的东西，本文不涉及React Native的开发相关，只是总结了开发中的一些最佳实践。不仅仅适合React Native。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react_1_1x.jpg\" alt=\"image\"></p>","more":"<p>在进行项目开发时，我们都会将公共的模块抽离出来。在学习React Native的过程中，我也遇到了同样的场景，在此记录下来。React Native使用fetch作为网络请求库，而每个几乎每个模块都需要用到网络请求，那么将其抽离为公共模块甚为必要。</p>\n<h3 id=\"封装HTTP模块的优点\"><a href=\"#封装HTTP模块的优点\" class=\"headerlink\" title=\"封装HTTP模块的优点\"></a>封装HTTP模块的优点</h3><ul>\n<li>代码复用  </li>\n</ul>\n<p>由于很多模块都会用到HTTP请求，将fetch封装为公共模块可以复用很多代码</p>\n<ul>\n<li>高内聚低耦合</li>\n</ul>\n<p>将公共部分提取出来，可以使每个模块专注于自身的业务逻辑</p>\n<ul>\n<li>便于项目的扩展与后期的维护，并且做到职责分离</li>\n</ul>\n<h3 id=\"具体做法\"><a href=\"#具体做法\" class=\"headerlink\" title=\"具体做法\"></a>具体做法</h3><p>首先，在项目根目录下新建utils目录，在utils目录中，新建fetch.js。</p>\n<p>要想在其他模块中使用整个模块，首先，我们要将其导出为一个模块供其他模块使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">fetchUtils</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fetchUtils模块中应该包含两个方法，分别是get和post的请求方法，下一步，来编写get方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">get</span>(url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      fetch(url)</span><br><span class=\"line\">          .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">          .then(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              resolve(result);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">              reject(error);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get方法应该是一个静态方法，接受一个参数url，其返回一个Promise，Promise接受两个参数resolve和reject，用于处理成功和失败的情况，在Promise中，使用fetch发起get请求，然后使用链式函数then来处理服务器返回结果，先取出json数据，当服务器成功返回数据，使用resolve返回结果；当发生错误时，调用catch方法捕获错误。</p>\n<p>下面是post方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> post(url, data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        fech(url, &#123;</span><br><span class=\"line\">            method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">            header: &#123;</span><br><span class=\"line\">                <span class=\"string\">'Accept'</span>: <span class=\"string\">'application/json'</span>,</span><br><span class=\"line\">                <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            body: <span class=\"built_in\">JSON</span>.stringify(data)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(result);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">            reject(error);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>post方法与get方法类似，也是静态方法，post方法接受两个参数，分别是url和提交的数据data。同样的，post方法返回一个Promise，参数与get方法一样，然后向服务器发送POST请求，post请求需要设置method为POST，还需要设置请求头，请求头包含接受的数据类型和Content-Type，均设置为application/json，最后将用户提交的数据放到body中，使用JSON序列化data。然后需要接受服务器返回的数据，这里与get方法一样，不再赘述。</p>\n<p>以上就是封装好的HTTP请求模块。下面看一下如何使用。</p>\n<p>首先，将fetchUtils导入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import fetchUtils from &apos;../utils/fetch&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>get方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetchUtils.get(url)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(result)&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(error)&#125;)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>post方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetchUtils.post(url, data)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(result)&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">result</span>: <span class=\"built_in\">JSON</span>.stringify(error)&#125;)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上对fetch方法的封装，使代码更加精简，业务逻辑更加清晰，也更加容易维护。此处使用React Native为例只是项目开发的一个缩影，这种封装思想是可以在工作中借鉴的。</p>"},{"title":"React Router V4学习笔记","date":"2018-02-02T03:27:57.000Z","banner":"http://img.yanyuanfe.cn/stock-photo-245282361.jpg","_content":"\n> React Router现在已经是React开发单页应用必备技能，自升级V4版本以来，许多核心API都进行了重写，践行路由即组件的概念，本文是我学习React Router V4以来的一些总结。\n\n![image](http://img.yanyuanfe.cn/recatrouter.png)\n\n<!--more-->\n\n### 介绍\nReact-Router V4是react-router的一次重大更新，许多核心API都已改变，使用react-router4不需要对路由进行集中式配置，react-router 4的核心是一切皆组件。 \n\nreact-router 4一共被拆分为三个包：react-router、react-router-dom、react-router-native，react-router提供了React Router的核心路由功能，包括Router, Route, Switch等，但是我们不会直接使用它。react-router-dom和react-router-native提供在特定运行环境下的路由组件。如果你需要开发在浏览器中运行的Web应用，则应该安装react-router-dom。同样，如果你需要开发React Native应用程序，则应该安装react-router-native。这两者都将安装react-router作为依赖项。\n\n### react-router-dom\n\nreact-router使用react-router-dom作为浏览器端的路由，提供了BrowserRouter,Route,Link等api,通过DOM的事件控制路由。在Web开发过程中，我们更多是使用react-router-dom。本文的讨论也仅限于react-router-dom。\n\n**安装**\n\n``` bash\nnpm install react-router-dom --save\n```\n\n### 使用\n\n#### Router\n\nreact-router4的使用首先需要选择Router，Router用于包裹在应用最外层。Router有两种类型：HashRouter和BrowserRouter，其表现方式也有所不同，使用时需要区分。\n\n#### HashRouter与BrowserRouter\n\n从表面区分HashRouter和BrowserRouter的方法就是HashRouter的url中有个#，例如localhost:3000/#，HashRouter通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。  \n\nBrowserRouter的url中没有#，它的url如http://localhost:3001/user/login，BrowserRouter的原理是依赖HTML5的history API实现的路由机制。  \n\nHashRouter和BrowserRouter都具有basename属性，如果你的URL不是位于网站根目录，而是放在子目录里，你需要设置这个属性。如下：\n\n\n``` js\n<BrowserRouter basename=\"/calendar\"/>\n<Link to=\"/today\"/> // 渲染为 <a href=\"/calendar/today\">\n```\n\n#### Route\nRoute是Router的子元素，控制路径对应显示的组件。常用属性有exact、path以及component。\n考虑以下代码：\n\n``` js\n<Route path=\"/\" exact component={HomePage} />\n<Route path=\"/users\" component={UsersPage} />\n```\nreact-router4的路由是包含性的，多个Route可以同时进行匹配和渲染，exact控制到路径匹配成功时不会再继续向下匹配，在面代码中，我们试图根据路径渲染 HomePage 或者 UsersPage。如果从Route删除了 exact 属性，那么在浏览器中访问 /users 时，HomePage 和 UsersPage 组件将同时被渲染。\n\n#### Switch\n\n在Router组件中的任意位置创建多个<Route>，但通常我们会把它们放在同一个位置。使用<Switch>组件来包裹一组<Route>。<Switch>会遍历自身的子元素（即路由）并对第一个匹配当前路径的元素进行渲染。考虑如下代码：\n\n\n``` js\n<Switch>\n  <Route exact path=\"/\" component={DashBoard} />\n  <Route path=\"/user\" component={User} />\n</Switch>\n```\n\n如果去掉Switch组件，当我们访问/user的时候，路由会同时匹配“/”和/user，将同时渲染DashBoard和User组件。\n\n#### Link vs NavLink\n\nreact-router4提供了两种导航API，用于页面切换，当页面切换时，页面不会重新加载，但是组件会被重新渲染。它们作用相同，但NavLink在匹配URL成功时，可以提供一些额外的样式能力。\n\n**Link**\n\nLink提供to属性控制跳转地址，可传入字符串或者对象。如下：\n\n``` js\n<Link to=\"/courses\"/>to: object\n<Link to={{\n  pathname: '/courses',\n  search: '?sort=name',\n  hash: '#the-hash',\n  state: { fromDashboard: true }\n}}/>\n```\n**NavLink**\n\nNavLink可以给当前匹配成功的链接提供一个className类名，常在Tab导航中使用。\n\n\n``` js\n<nav>\n  <NavLinkto=\"/app\"exact activeClassName=\"active\">Home</NavLink>\n  <NavLinkto=\"/app/users\"activeClassName=\"active\">Users</NavLink>\n  <NavLinkto=\"/app/products\"activeClassName=\"active\">Products</NavLink>\n</nav>\n```\n\n\n#### 路径参数\n在react router4中，match用于获取路径上的参数，match是使用<Route>渲染时传递到组件内的一个props，在react组件内部通过this.props.match获取match的属性，\n考虑如下代码：\n\n``` js\n<Switch>\n  <Route exact path=\"/\" component={DashBoard} />\n  <Route path=\"/user/:id\" component={User} />\n  <Route path=\"/user\" component={User} />\n</Switch>\n```\n\n当访问http://localhost:3001/user/123时，打印this.props.match的内容。\nmatch获取的属性主要有：\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_167.png)\n\n\n然后，通过this.props.match.params.id就可以获取路由匹配的id了。\n\n#### withRouter\n\n试想，如果组件没有通过<Route>渲染，该如何获取history、match、location等props呢？react router4提供了一个高阶组件withRouter。使用方法如下：\n\n``` js\nimport { withRouter } from 'react-router-dom';\n```\n\n使用withRouter有两种办法，第一种简洁的方法是使用装饰器，如下：\n\n``` js\n@withRouter\nclass AuthRoute extends React.Component {\n}\n```\n\n另一种方法直接调用withRouter包裹原来的组件返回一个新的组件：\n\n``` js\nclass Auth extends React.Component {\n\n}\nconst AuthRoute = withRouter(Auth)\n```\n\n通过以上两种方法，就能在组件内部使用路由的props了。如下：\n\n``` js\nconst { match，location，history} = this.props;\n```\n\n\n### 结语\n关于react router4,本文只是讲解了一些常用的api和用法，需要学习的还有很多，这里只是开始。\n\n### 参考\n\n[react router 官方文档](http://reacttraining.cn/)","source":"_posts/React Router V4 学习笔记.md","raw":"---\ntitle: React Router V4学习笔记\ndate: 2018-02-02 11:27:57\nbanner: http://img.yanyuanfe.cn/stock-photo-245282361.jpg\ntags:\n - React Router\n - React\n---\n\n> React Router现在已经是React开发单页应用必备技能，自升级V4版本以来，许多核心API都进行了重写，践行路由即组件的概念，本文是我学习React Router V4以来的一些总结。\n\n![image](http://img.yanyuanfe.cn/recatrouter.png)\n\n<!--more-->\n\n### 介绍\nReact-Router V4是react-router的一次重大更新，许多核心API都已改变，使用react-router4不需要对路由进行集中式配置，react-router 4的核心是一切皆组件。 \n\nreact-router 4一共被拆分为三个包：react-router、react-router-dom、react-router-native，react-router提供了React Router的核心路由功能，包括Router, Route, Switch等，但是我们不会直接使用它。react-router-dom和react-router-native提供在特定运行环境下的路由组件。如果你需要开发在浏览器中运行的Web应用，则应该安装react-router-dom。同样，如果你需要开发React Native应用程序，则应该安装react-router-native。这两者都将安装react-router作为依赖项。\n\n### react-router-dom\n\nreact-router使用react-router-dom作为浏览器端的路由，提供了BrowserRouter,Route,Link等api,通过DOM的事件控制路由。在Web开发过程中，我们更多是使用react-router-dom。本文的讨论也仅限于react-router-dom。\n\n**安装**\n\n``` bash\nnpm install react-router-dom --save\n```\n\n### 使用\n\n#### Router\n\nreact-router4的使用首先需要选择Router，Router用于包裹在应用最外层。Router有两种类型：HashRouter和BrowserRouter，其表现方式也有所不同，使用时需要区分。\n\n#### HashRouter与BrowserRouter\n\n从表面区分HashRouter和BrowserRouter的方法就是HashRouter的url中有个#，例如localhost:3000/#，HashRouter通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。  \n\nBrowserRouter的url中没有#，它的url如http://localhost:3001/user/login，BrowserRouter的原理是依赖HTML5的history API实现的路由机制。  \n\nHashRouter和BrowserRouter都具有basename属性，如果你的URL不是位于网站根目录，而是放在子目录里，你需要设置这个属性。如下：\n\n\n``` js\n<BrowserRouter basename=\"/calendar\"/>\n<Link to=\"/today\"/> // 渲染为 <a href=\"/calendar/today\">\n```\n\n#### Route\nRoute是Router的子元素，控制路径对应显示的组件。常用属性有exact、path以及component。\n考虑以下代码：\n\n``` js\n<Route path=\"/\" exact component={HomePage} />\n<Route path=\"/users\" component={UsersPage} />\n```\nreact-router4的路由是包含性的，多个Route可以同时进行匹配和渲染，exact控制到路径匹配成功时不会再继续向下匹配，在面代码中，我们试图根据路径渲染 HomePage 或者 UsersPage。如果从Route删除了 exact 属性，那么在浏览器中访问 /users 时，HomePage 和 UsersPage 组件将同时被渲染。\n\n#### Switch\n\n在Router组件中的任意位置创建多个<Route>，但通常我们会把它们放在同一个位置。使用<Switch>组件来包裹一组<Route>。<Switch>会遍历自身的子元素（即路由）并对第一个匹配当前路径的元素进行渲染。考虑如下代码：\n\n\n``` js\n<Switch>\n  <Route exact path=\"/\" component={DashBoard} />\n  <Route path=\"/user\" component={User} />\n</Switch>\n```\n\n如果去掉Switch组件，当我们访问/user的时候，路由会同时匹配“/”和/user，将同时渲染DashBoard和User组件。\n\n#### Link vs NavLink\n\nreact-router4提供了两种导航API，用于页面切换，当页面切换时，页面不会重新加载，但是组件会被重新渲染。它们作用相同，但NavLink在匹配URL成功时，可以提供一些额外的样式能力。\n\n**Link**\n\nLink提供to属性控制跳转地址，可传入字符串或者对象。如下：\n\n``` js\n<Link to=\"/courses\"/>to: object\n<Link to={{\n  pathname: '/courses',\n  search: '?sort=name',\n  hash: '#the-hash',\n  state: { fromDashboard: true }\n}}/>\n```\n**NavLink**\n\nNavLink可以给当前匹配成功的链接提供一个className类名，常在Tab导航中使用。\n\n\n``` js\n<nav>\n  <NavLinkto=\"/app\"exact activeClassName=\"active\">Home</NavLink>\n  <NavLinkto=\"/app/users\"activeClassName=\"active\">Users</NavLink>\n  <NavLinkto=\"/app/products\"activeClassName=\"active\">Products</NavLink>\n</nav>\n```\n\n\n#### 路径参数\n在react router4中，match用于获取路径上的参数，match是使用<Route>渲染时传递到组件内的一个props，在react组件内部通过this.props.match获取match的属性，\n考虑如下代码：\n\n``` js\n<Switch>\n  <Route exact path=\"/\" component={DashBoard} />\n  <Route path=\"/user/:id\" component={User} />\n  <Route path=\"/user\" component={User} />\n</Switch>\n```\n\n当访问http://localhost:3001/user/123时，打印this.props.match的内容。\nmatch获取的属性主要有：\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_167.png)\n\n\n然后，通过this.props.match.params.id就可以获取路由匹配的id了。\n\n#### withRouter\n\n试想，如果组件没有通过<Route>渲染，该如何获取history、match、location等props呢？react router4提供了一个高阶组件withRouter。使用方法如下：\n\n``` js\nimport { withRouter } from 'react-router-dom';\n```\n\n使用withRouter有两种办法，第一种简洁的方法是使用装饰器，如下：\n\n``` js\n@withRouter\nclass AuthRoute extends React.Component {\n}\n```\n\n另一种方法直接调用withRouter包裹原来的组件返回一个新的组件：\n\n``` js\nclass Auth extends React.Component {\n\n}\nconst AuthRoute = withRouter(Auth)\n```\n\n通过以上两种方法，就能在组件内部使用路由的props了。如下：\n\n``` js\nconst { match，location，history} = this.props;\n```\n\n\n### 结语\n关于react router4,本文只是讲解了一些常用的api和用法，需要学习的还有很多，这里只是开始。\n\n### 参考\n\n[react router 官方文档](http://reacttraining.cn/)","slug":"React Router V4 学习笔记","published":1,"updated":"2020-07-16T13:56:47.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenn30008p70vwa85tt5t","content":"<blockquote>\n<p>React Router现在已经是React开发单页应用必备技能，自升级V4版本以来，许多核心API都进行了重写，践行路由即组件的概念，本文是我学习React Router V4以来的一些总结。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/recatrouter.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>React-Router V4是react-router的一次重大更新，许多核心API都已改变，使用react-router4不需要对路由进行集中式配置，react-router 4的核心是一切皆组件。 </p>\n<p>react-router 4一共被拆分为三个包：react-router、react-router-dom、react-router-native，react-router提供了React Router的核心路由功能，包括Router, Route, Switch等，但是我们不会直接使用它。react-router-dom和react-router-native提供在特定运行环境下的路由组件。如果你需要开发在浏览器中运行的Web应用，则应该安装react-router-dom。同样，如果你需要开发React Native应用程序，则应该安装react-router-native。这两者都将安装react-router作为依赖项。</p>\n<h3 id=\"react-router-dom\"><a href=\"#react-router-dom\" class=\"headerlink\" title=\"react-router-dom\"></a>react-router-dom</h3><p>react-router使用react-router-dom作为浏览器端的路由，提供了BrowserRouter,Route,Link等api,通过DOM的事件控制路由。在Web开发过程中，我们更多是使用react-router-dom。本文的讨论也仅限于react-router-dom。</p>\n<p><strong>安装</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install react-router-dom --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h4><p>react-router4的使用首先需要选择Router，Router用于包裹在应用最外层。Router有两种类型：HashRouter和BrowserRouter，其表现方式也有所不同，使用时需要区分。</p>\n<h4 id=\"HashRouter与BrowserRouter\"><a href=\"#HashRouter与BrowserRouter\" class=\"headerlink\" title=\"HashRouter与BrowserRouter\"></a>HashRouter与BrowserRouter</h4><p>从表面区分HashRouter和BrowserRouter的方法就是HashRouter的url中有个#，例如localhost:3000/#，HashRouter通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。  </p>\n<p>BrowserRouter的url中没有#，它的url如<a href=\"http://localhost:3001/user/login，BrowserRouter的原理是依赖HTML5的history\" target=\"_blank\" rel=\"noopener\">http://localhost:3001/user/login，BrowserRouter的原理是依赖HTML5的history</a> API实现的路由机制。  </p>\n<p>HashRouter和BrowserRouter都具有basename属性，如果你的URL不是位于网站根目录，而是放在子目录里，你需要设置这个属性。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;BrowserRouter basename=<span class=\"string\">\"/calendar\"</span>/&gt;</span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/today\"</span>/&gt; <span class=\"comment\">// 渲染为 &lt;a href=\"/calendar/today\"&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Route\"><a href=\"#Route\" class=\"headerlink\" title=\"Route\"></a>Route</h4><p>Route是Router的子元素，控制路径对应显示的组件。常用属性有exact、path以及component。<br>考虑以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=<span class=\"string\">\"/\"</span> exact component=&#123;HomePage&#125; /&gt;</span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/users\"</span> component=&#123;UsersPage&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>react-router4的路由是包含性的，多个Route可以同时进行匹配和渲染，exact控制到路径匹配成功时不会再继续向下匹配，在面代码中，我们试图根据路径渲染 HomePage 或者 UsersPage。如果从Route删除了 exact 属性，那么在浏览器中访问 /users 时，HomePage 和 UsersPage 组件将同时被渲染。</p>\n<h4 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h4><p>在Router组件中的任意位置创建多个<route>，但通常我们会把它们放在同一个位置。使用<switch>组件来包裹一组<route>。<switch>会遍历自身的子元素（即路由）并对第一个匹配当前路径的元素进行渲染。考虑如下代码：</switch></route></switch></route></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">  &lt;Route exact path=<span class=\"string\">\"/\"</span> component=&#123;DashBoard&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/user\"</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Switch&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果去掉Switch组件，当我们访问/user的时候，路由会同时匹配“/”和/user，将同时渲染DashBoard和User组件。</p>\n<h4 id=\"Link-vs-NavLink\"><a href=\"#Link-vs-NavLink\" class=\"headerlink\" title=\"Link vs NavLink\"></a>Link vs NavLink</h4><p>react-router4提供了两种导航API，用于页面切换，当页面切换时，页面不会重新加载，但是组件会被重新渲染。它们作用相同，但NavLink在匹配URL成功时，可以提供一些额外的样式能力。</p>\n<p><strong>Link</strong></p>\n<p>Link提供to属性控制跳转地址，可传入字符串或者对象。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Link to=<span class=\"string\">\"/courses\"</span>/&gt;to: object</span><br><span class=\"line\">&lt;Link to=&#123;&#123;</span><br><span class=\"line\">  pathname: <span class=\"string\">'/courses'</span>,</span><br><span class=\"line\">  search: <span class=\"string\">'?sort=name'</span>,</span><br><span class=\"line\">  hash: <span class=\"string\">'#the-hash'</span>,</span><br><span class=\"line\">  state: &#123; <span class=\"attr\">fromDashboard</span>: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>NavLink</strong></p>\n<p>NavLink可以给当前匹配成功的链接提供一个className类名，常在Tab导航中使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;nav&gt;</span><br><span class=\"line\">  &lt;NavLinkto=<span class=\"string\">\"/app\"</span>exact activeClassName=<span class=\"string\">\"active\"</span>&gt;Home&lt;<span class=\"regexp\">/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;NavLinkto=\"/</span>app/users<span class=\"string\">\"activeClassName=\"</span>active<span class=\"string\">\"&gt;Users&lt;/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;NavLinkto=\"</span>/app/products<span class=\"string\">\"activeClassName=\"</span>active<span class=\"string\">\"&gt;Products&lt;/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/nav&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"路径参数\"><a href=\"#路径参数\" class=\"headerlink\" title=\"路径参数\"></a>路径参数</h4><p>在react router4中，match用于获取路径上的参数，match是使用<route>渲染时传递到组件内的一个props，在react组件内部通过this.props.match获取match的属性，<br>考虑如下代码：</route></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">  &lt;Route exact path=<span class=\"string\">\"/\"</span> component=&#123;DashBoard&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/user/:id\"</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/user\"</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Switch&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当访问<a href=\"http://localhost:3001/user/123时，打印this.props.match的内容。\" target=\"_blank\" rel=\"noopener\">http://localhost:3001/user/123时，打印this.props.match的内容。</a><br>match获取的属性主要有：<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_167.png\" alt=\"image\"></p>\n<p>然后，通过this.props.match.params.id就可以获取路由匹配的id了。</p>\n<h4 id=\"withRouter\"><a href=\"#withRouter\" class=\"headerlink\" title=\"withRouter\"></a>withRouter</h4><p>试想，如果组件没有通过<route>渲染，该如何获取history、match、location等props呢？react router4提供了一个高阶组件withRouter。使用方法如下：</route></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; withRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure>\n<p>使用withRouter有两种办法，第一种简洁的方法是使用装饰器，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">@withRouter</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthRoute</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种方法直接调用withRouter包裹原来的组件返回一个新的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Auth</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> AuthRoute = withRouter(Auth)</span><br></pre></td></tr></table></figure>\n<p>通过以上两种方法，就能在组件内部使用路由的props了。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; match，location，history&#125; = <span class=\"keyword\">this</span>.props;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>关于react router4,本文只是讲解了一些常用的api和用法，需要学习的还有很多，这里只是开始。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://reacttraining.cn/\" target=\"_blank\" rel=\"noopener\">react router 官方文档</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>React Router现在已经是React开发单页应用必备技能，自升级V4版本以来，许多核心API都进行了重写，践行路由即组件的概念，本文是我学习React Router V4以来的一些总结。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/recatrouter.png\" alt=\"image\"></p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>React-Router V4是react-router的一次重大更新，许多核心API都已改变，使用react-router4不需要对路由进行集中式配置，react-router 4的核心是一切皆组件。 </p>\n<p>react-router 4一共被拆分为三个包：react-router、react-router-dom、react-router-native，react-router提供了React Router的核心路由功能，包括Router, Route, Switch等，但是我们不会直接使用它。react-router-dom和react-router-native提供在特定运行环境下的路由组件。如果你需要开发在浏览器中运行的Web应用，则应该安装react-router-dom。同样，如果你需要开发React Native应用程序，则应该安装react-router-native。这两者都将安装react-router作为依赖项。</p>\n<h3 id=\"react-router-dom\"><a href=\"#react-router-dom\" class=\"headerlink\" title=\"react-router-dom\"></a>react-router-dom</h3><p>react-router使用react-router-dom作为浏览器端的路由，提供了BrowserRouter,Route,Link等api,通过DOM的事件控制路由。在Web开发过程中，我们更多是使用react-router-dom。本文的讨论也仅限于react-router-dom。</p>\n<p><strong>安装</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install react-router-dom --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h4><p>react-router4的使用首先需要选择Router，Router用于包裹在应用最外层。Router有两种类型：HashRouter和BrowserRouter，其表现方式也有所不同，使用时需要区分。</p>\n<h4 id=\"HashRouter与BrowserRouter\"><a href=\"#HashRouter与BrowserRouter\" class=\"headerlink\" title=\"HashRouter与BrowserRouter\"></a>HashRouter与BrowserRouter</h4><p>从表面区分HashRouter和BrowserRouter的方法就是HashRouter的url中有个#，例如localhost:3000/#，HashRouter通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。  </p>\n<p>BrowserRouter的url中没有#，它的url如<a href=\"http://localhost:3001/user/login，BrowserRouter的原理是依赖HTML5的history\" target=\"_blank\" rel=\"noopener\">http://localhost:3001/user/login，BrowserRouter的原理是依赖HTML5的history</a> API实现的路由机制。  </p>\n<p>HashRouter和BrowserRouter都具有basename属性，如果你的URL不是位于网站根目录，而是放在子目录里，你需要设置这个属性。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;BrowserRouter basename=<span class=\"string\">\"/calendar\"</span>/&gt;</span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/today\"</span>/&gt; <span class=\"comment\">// 渲染为 &lt;a href=\"/calendar/today\"&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Route\"><a href=\"#Route\" class=\"headerlink\" title=\"Route\"></a>Route</h4><p>Route是Router的子元素，控制路径对应显示的组件。常用属性有exact、path以及component。<br>考虑以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=<span class=\"string\">\"/\"</span> exact component=&#123;HomePage&#125; /&gt;</span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/users\"</span> component=&#123;UsersPage&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>react-router4的路由是包含性的，多个Route可以同时进行匹配和渲染，exact控制到路径匹配成功时不会再继续向下匹配，在面代码中，我们试图根据路径渲染 HomePage 或者 UsersPage。如果从Route删除了 exact 属性，那么在浏览器中访问 /users 时，HomePage 和 UsersPage 组件将同时被渲染。</p>\n<h4 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h4><p>在Router组件中的任意位置创建多个<route>，但通常我们会把它们放在同一个位置。使用<switch>组件来包裹一组<route>。<switch>会遍历自身的子元素（即路由）并对第一个匹配当前路径的元素进行渲染。考虑如下代码：</switch></route></switch></route></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">  &lt;Route exact path=<span class=\"string\">\"/\"</span> component=&#123;DashBoard&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/user\"</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Switch&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果去掉Switch组件，当我们访问/user的时候，路由会同时匹配“/”和/user，将同时渲染DashBoard和User组件。</p>\n<h4 id=\"Link-vs-NavLink\"><a href=\"#Link-vs-NavLink\" class=\"headerlink\" title=\"Link vs NavLink\"></a>Link vs NavLink</h4><p>react-router4提供了两种导航API，用于页面切换，当页面切换时，页面不会重新加载，但是组件会被重新渲染。它们作用相同，但NavLink在匹配URL成功时，可以提供一些额外的样式能力。</p>\n<p><strong>Link</strong></p>\n<p>Link提供to属性控制跳转地址，可传入字符串或者对象。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Link to=<span class=\"string\">\"/courses\"</span>/&gt;to: object</span><br><span class=\"line\">&lt;Link to=&#123;&#123;</span><br><span class=\"line\">  pathname: <span class=\"string\">'/courses'</span>,</span><br><span class=\"line\">  search: <span class=\"string\">'?sort=name'</span>,</span><br><span class=\"line\">  hash: <span class=\"string\">'#the-hash'</span>,</span><br><span class=\"line\">  state: &#123; <span class=\"attr\">fromDashboard</span>: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>NavLink</strong></p>\n<p>NavLink可以给当前匹配成功的链接提供一个className类名，常在Tab导航中使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;nav&gt;</span><br><span class=\"line\">  &lt;NavLinkto=<span class=\"string\">\"/app\"</span>exact activeClassName=<span class=\"string\">\"active\"</span>&gt;Home&lt;<span class=\"regexp\">/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;NavLinkto=\"/</span>app/users<span class=\"string\">\"activeClassName=\"</span>active<span class=\"string\">\"&gt;Users&lt;/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;NavLinkto=\"</span>/app/products<span class=\"string\">\"activeClassName=\"</span>active<span class=\"string\">\"&gt;Products&lt;/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/nav&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"路径参数\"><a href=\"#路径参数\" class=\"headerlink\" title=\"路径参数\"></a>路径参数</h4><p>在react router4中，match用于获取路径上的参数，match是使用<route>渲染时传递到组件内的一个props，在react组件内部通过this.props.match获取match的属性，<br>考虑如下代码：</route></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">  &lt;Route exact path=<span class=\"string\">\"/\"</span> component=&#123;DashBoard&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/user/:id\"</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/user\"</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Switch&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当访问<a href=\"http://localhost:3001/user/123时，打印this.props.match的内容。\" target=\"_blank\" rel=\"noopener\">http://localhost:3001/user/123时，打印this.props.match的内容。</a><br>match获取的属性主要有：<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_167.png\" alt=\"image\"></p>\n<p>然后，通过this.props.match.params.id就可以获取路由匹配的id了。</p>\n<h4 id=\"withRouter\"><a href=\"#withRouter\" class=\"headerlink\" title=\"withRouter\"></a>withRouter</h4><p>试想，如果组件没有通过<route>渲染，该如何获取history、match、location等props呢？react router4提供了一个高阶组件withRouter。使用方法如下：</route></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; withRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure>\n<p>使用withRouter有两种办法，第一种简洁的方法是使用装饰器，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">@withRouter</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthRoute</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种方法直接调用withRouter包裹原来的组件返回一个新的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Auth</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> AuthRoute = withRouter(Auth)</span><br></pre></td></tr></table></figure>\n<p>通过以上两种方法，就能在组件内部使用路由的props了。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; match，location，history&#125; = <span class=\"keyword\">this</span>.props;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>关于react router4,本文只是讲解了一些常用的api和用法，需要学习的还有很多，这里只是开始。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://reacttraining.cn/\" target=\"_blank\" rel=\"noopener\">react router 官方文档</a></p>"},{"title":"Redux实现简单计数器","date":"2018-02-07T12:37:16.000Z","banner":"http://img.yanyuanfe.cn/photo-1453928582365-b6ad33cbcf64.jpeg","_content":"\n> redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文结合实例讲解Redux的使用，可以更好的理解Redux。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n当你已经了解一些redux的基础概念后，现在开始尝试使用redux吧，redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文尝试在react应用中使用redux来开发应用，而并没有使用react-redux，这有助于理解redux的数据流。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-1\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 开始\n首先，初始化一个react应用，使用creat-react-app来进行创建，使用之前需要先安装，打开命令行，输入：\n\n``` bash\nnpm i create-react-app -g\n```\n进行全局安装。然后进入准备开发的目录，打开命令行，进入当前文件夹，输入：\n\n``` bash\ncreate-react-app redux-app\n```\n，等待创建完成。然后\n\n``` bash\ncd redux-app\n```\n\n，运行npm start，react应用会自动运行并打开浏览器。\n下一步，需要安装redux，命令行输入\n\n``` bash\nnpm i redux --save\n```\n\n，下面，开始编写redux部分。\n### redux\n由于应用比较简单，可以直接编写reducer部分，在src目录下新建reducers文件夹，新建index.js，在reducer中，主要处理action来返回新的state，在本应用中，计数器触发的action主要有加和减两种，分别将其定义为\n'INCREMENT'和'DECREMENT'，当触发计数器加1的时候，将state+1,触发计数器减1的时候，将state-1,否则，将返回原来的satte。并且需要将整个reducer export default以供其他部分使用。代码如下：\n\n``` js\nexport default (state = 0, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n  }\n}\n```\n\nreducer编写完毕后，下一步需要生成store注入整个应用。此处，需要修改src目录下的index.js，通过import导入redux，需要使用redux提供的APIcreateStore将reducer生成整个应用的状态store，并且将store通过props传入整个应用的根组件App。同时，需要将原本的渲染逻辑封装成一个render方法并手动调用。同时，当store改变后，应用并不会自动重新渲染，需要使用store的方法subscribe来手动订阅，store.subscribe(render);意思是让store订阅render方法，当store改变时，就调用render重新渲染整个应用。\n\n\n``` js\nReactDOM.render(<App store={store}/>, document.getElementById('root'))\n```\n\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { createStore } from 'redux';\nimport registerServiceWorker from './registerServiceWorker';\nimport counter from './reducers';\n\nconst store = createStore(counter);\n\nconst render = () => ReactDOM.render(<App store={store}/>, document.getElementById('root'));\n\nrender();\n\nstore.subscribe(render);\nregisterServiceWorker();\n```\n\n### 组件编写\nstore通过props传递到APP组件后，在APP组件内需要通过store来获取数据以及触发action。在APP组件中，为了使组件逻辑分离，计数器相关的实现将会单独抽离成组件，APP组件负责将数据和事件通过props传递到计数器组件中。\n在src目录下新建components目录，在components目录下新建Counter.js，下面是计数器的代码：\n\n``` js\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.incrementAsync = this.incrementAsync.bind(this);\n    this.incrementIfOdd = this.incrementIfOdd.bind(this);\n  }\n\n  render() {\n    const { value, onIncrement, onDecrement } = this.props;\n    return (\n      <p>\n        Clicked: {value} times\n        {' '}\n        <button onClick={onIncrement}>\n          +\n        </button>\n        {' '}\n        <button onClick={onDecrement}>\n          -\n        </button>\n      </p>\n    )\n  }\n}\n\nexport default Counter;\n```\n\n\n在Counter组件中，通过props接收父组件传递的value和加、减数值的方法，value绑定到视图显示计数器的数值，加、减按钮分别用来控制计数器的加减操作，分别将父组件传递的方法进行绑定到按钮上。\n然后在src目录下的App.js中引入计数器的组件，并在render中使用。\n\n``` js\nimport React, { Component } from 'react';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { store } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={store.getState()}\n          onIncrement={() => store.dispatch({ type: 'INCREMENT' })}\n          onDecrement={() => store.dispatch({ type: 'DECREMENT' })}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n在APP组件中，使用ES6的对象解构语法在props中获取store，在render中渲染计数器组件Counter，同时，向Couter组件传入约定的props，计数器数值value通过store.getState()来获取，增加数值方法onIncrement传入一个方法，调用store.dispatch来发起一个Action，action中传入代表增加数值的type ‘Increment’，同理，减少数值的方法onDecrement中传入的actionType为‘DECREMENT’。\n\n到这里，整个计数器应用就完全开发完成了。\n\n``` js\nnpm start\n```\n\n启动应用，打开浏览器，最终效果如下：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_208.png)\n\n点击+、-按钮可以控制数字的加减，而且数字是实时更新的。\n\n### 写在最后\n通过redux实现的计数器应用已经开发完成了，你可以尝试梳理一下redux的流程，首先，redux的核心包括store、action、reducer，store暴露到全局应用中，通过store可以获取state，触发action，订阅state改变后的事件。要想改变state的数据，必须触发Action，action可以通过一些交互和事件来触发，reducer用来处理action，并返回一个新的state，当state改变后，store的subscribe方法就会触发，可以用来更新视图。如果你使用react来开发应用，当你的应用变得复杂，仅仅使用redux会变得很繁琐，你可能需要将store通过props来一层层传递到你需要的组件中，为了解决这样的问题，react-redux出现了，可以使用简单的方式获取到全局的状态，那么，拭目以待吧。","source":"_posts/Redux实现简单计数器.md","raw":"---\ntitle: Redux实现简单计数器\ndate: 2018-02-7 20:37:16\nbanner: http://img.yanyuanfe.cn/photo-1453928582365-b6ad33cbcf64.jpeg\ntags:\n - Redux\n---\n\n> redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文结合实例讲解Redux的使用，可以更好的理解Redux。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n当你已经了解一些redux的基础概念后，现在开始尝试使用redux吧，redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文尝试在react应用中使用redux来开发应用，而并没有使用react-redux，这有助于理解redux的数据流。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-1\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 开始\n首先，初始化一个react应用，使用creat-react-app来进行创建，使用之前需要先安装，打开命令行，输入：\n\n``` bash\nnpm i create-react-app -g\n```\n进行全局安装。然后进入准备开发的目录，打开命令行，进入当前文件夹，输入：\n\n``` bash\ncreate-react-app redux-app\n```\n，等待创建完成。然后\n\n``` bash\ncd redux-app\n```\n\n，运行npm start，react应用会自动运行并打开浏览器。\n下一步，需要安装redux，命令行输入\n\n``` bash\nnpm i redux --save\n```\n\n，下面，开始编写redux部分。\n### redux\n由于应用比较简单，可以直接编写reducer部分，在src目录下新建reducers文件夹，新建index.js，在reducer中，主要处理action来返回新的state，在本应用中，计数器触发的action主要有加和减两种，分别将其定义为\n'INCREMENT'和'DECREMENT'，当触发计数器加1的时候，将state+1,触发计数器减1的时候，将state-1,否则，将返回原来的satte。并且需要将整个reducer export default以供其他部分使用。代码如下：\n\n``` js\nexport default (state = 0, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n  }\n}\n```\n\nreducer编写完毕后，下一步需要生成store注入整个应用。此处，需要修改src目录下的index.js，通过import导入redux，需要使用redux提供的APIcreateStore将reducer生成整个应用的状态store，并且将store通过props传入整个应用的根组件App。同时，需要将原本的渲染逻辑封装成一个render方法并手动调用。同时，当store改变后，应用并不会自动重新渲染，需要使用store的方法subscribe来手动订阅，store.subscribe(render);意思是让store订阅render方法，当store改变时，就调用render重新渲染整个应用。\n\n\n``` js\nReactDOM.render(<App store={store}/>, document.getElementById('root'))\n```\n\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { createStore } from 'redux';\nimport registerServiceWorker from './registerServiceWorker';\nimport counter from './reducers';\n\nconst store = createStore(counter);\n\nconst render = () => ReactDOM.render(<App store={store}/>, document.getElementById('root'));\n\nrender();\n\nstore.subscribe(render);\nregisterServiceWorker();\n```\n\n### 组件编写\nstore通过props传递到APP组件后，在APP组件内需要通过store来获取数据以及触发action。在APP组件中，为了使组件逻辑分离，计数器相关的实现将会单独抽离成组件，APP组件负责将数据和事件通过props传递到计数器组件中。\n在src目录下新建components目录，在components目录下新建Counter.js，下面是计数器的代码：\n\n``` js\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.incrementAsync = this.incrementAsync.bind(this);\n    this.incrementIfOdd = this.incrementIfOdd.bind(this);\n  }\n\n  render() {\n    const { value, onIncrement, onDecrement } = this.props;\n    return (\n      <p>\n        Clicked: {value} times\n        {' '}\n        <button onClick={onIncrement}>\n          +\n        </button>\n        {' '}\n        <button onClick={onDecrement}>\n          -\n        </button>\n      </p>\n    )\n  }\n}\n\nexport default Counter;\n```\n\n\n在Counter组件中，通过props接收父组件传递的value和加、减数值的方法，value绑定到视图显示计数器的数值，加、减按钮分别用来控制计数器的加减操作，分别将父组件传递的方法进行绑定到按钮上。\n然后在src目录下的App.js中引入计数器的组件，并在render中使用。\n\n``` js\nimport React, { Component } from 'react';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { store } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={store.getState()}\n          onIncrement={() => store.dispatch({ type: 'INCREMENT' })}\n          onDecrement={() => store.dispatch({ type: 'DECREMENT' })}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n在APP组件中，使用ES6的对象解构语法在props中获取store，在render中渲染计数器组件Counter，同时，向Couter组件传入约定的props，计数器数值value通过store.getState()来获取，增加数值方法onIncrement传入一个方法，调用store.dispatch来发起一个Action，action中传入代表增加数值的type ‘Increment’，同理，减少数值的方法onDecrement中传入的actionType为‘DECREMENT’。\n\n到这里，整个计数器应用就完全开发完成了。\n\n``` js\nnpm start\n```\n\n启动应用，打开浏览器，最终效果如下：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_208.png)\n\n点击+、-按钮可以控制数字的加减，而且数字是实时更新的。\n\n### 写在最后\n通过redux实现的计数器应用已经开发完成了，你可以尝试梳理一下redux的流程，首先，redux的核心包括store、action、reducer，store暴露到全局应用中，通过store可以获取state，触发action，订阅state改变后的事件。要想改变state的数据，必须触发Action，action可以通过一些交互和事件来触发，reducer用来处理action，并返回一个新的state，当state改变后，store的subscribe方法就会触发，可以用来更新视图。如果你使用react来开发应用，当你的应用变得复杂，仅仅使用redux会变得很繁琐，你可能需要将store通过props来一层层传递到你需要的组件中，为了解决这样的问题，react-redux出现了，可以使用简单的方式获取到全局的状态，那么，拭目以待吧。","slug":"Redux实现简单计数器","published":1,"updated":"2020-07-16T13:56:47.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenn6000cp70volk8gi7z","content":"<blockquote>\n<p>redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文结合实例讲解Redux的使用，可以更好的理解Redux。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>当你已经了解一些redux的基础概念后，现在开始尝试使用redux吧，redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文尝试在react应用中使用redux来开发应用，而并没有使用react-redux，这有助于理解redux的数据流。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-1</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>首先，初始化一个react应用，使用creat-react-app来进行创建，使用之前需要先安装，打开命令行，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i create-react-app -g</span><br></pre></td></tr></table></figure>\n<p>进行全局安装。然后进入准备开发的目录，打开命令行，进入当前文件夹，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">create-react-app redux-app</span><br></pre></td></tr></table></figure>\n<p>，等待创建完成。然后</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br></pre></td></tr></table></figure>\n<p>，运行npm start，react应用会自动运行并打开浏览器。<br>下一步，需要安装redux，命令行输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i redux --save</span><br></pre></td></tr></table></figure>\n<p>，下面，开始编写redux部分。</p>\n<h3 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h3><p>由于应用比较简单，可以直接编写reducer部分，在src目录下新建reducers文件夹，新建index.js，在reducer中，主要处理action来返回新的state，在本应用中，计数器触发的action主要有加和减两种，分别将其定义为<br>‘INCREMENT’和’DECREMENT’，当触发计数器加1的时候，将state+1,触发计数器减1的时候，将state-1,否则，将返回原来的satte。并且需要将整个reducer export default以供其他部分使用。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (state = <span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducer编写完毕后，下一步需要生成store注入整个应用。此处，需要修改src目录下的index.js，通过import导入redux，需要使用redux提供的APIcreateStore将reducer生成整个应用的状态store，并且将store通过props传入整个应用的根组件App。同时，需要将原本的渲染逻辑封装成一个render方法并手动调用。同时，当store改变后，应用并不会自动重新渲染，需要使用store的方法subscribe来手动订阅，store.subscribe(render);意思是让store订阅render方法，当store改变时，就调用render重新渲染整个应用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;/</span>&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> registerServiceWorker <span class=\"keyword\">from</span> <span class=\"string\">'./registerServiceWorker'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;/</span>&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">render();</span><br><span class=\"line\"></span><br><span class=\"line\">store.subscribe(render);</span><br><span class=\"line\">registerServiceWorker();</span><br></pre></td></tr></table></figure>\n<h3 id=\"组件编写\"><a href=\"#组件编写\" class=\"headerlink\" title=\"组件编写\"></a>组件编写</h3><p>store通过props传递到APP组件后，在APP组件内需要通过store来获取数据以及触发action。在APP组件中，为了使组件逻辑分离，计数器相关的实现将会单独抽离成组件，APP组件负责将数据和事件通过props传递到计数器组件中。<br>在src目录下新建components目录，在components目录下新建Counter.js，下面是计数器的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementAsync = <span class=\"keyword\">this</span>.incrementAsync.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementIfOdd = <span class=\"keyword\">this</span>.incrementIfOdd.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrement, onDecrement &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;value&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrement&#125;&gt;</span><br><span class=\"line\">          +</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;onDecrement&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          -</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Counter;</span></span><br></pre></td></tr></table></figure>\n<p>在Counter组件中，通过props接收父组件传递的value和加、减数值的方法，value绑定到视图显示计数器的数值，加、减按钮分别用来控制计数器的加减操作，分别将父组件传递的方法进行绑定到按钮上。<br>然后在src目录下的App.js中引入计数器的组件，并在render中使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;store.getState()&#125;</span><br><span class=\"line\">          onIncrement=&#123;() =&gt; store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)&#125;</span><br><span class=\"line\">          onDecrement=&#123;() =&gt; store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'DECREMENT'</span> &#125;)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<p>在APP组件中，使用ES6的对象解构语法在props中获取store，在render中渲染计数器组件Counter，同时，向Couter组件传入约定的props，计数器数值value通过store.getState()来获取，增加数值方法onIncrement传入一个方法，调用store.dispatch来发起一个Action，action中传入代表增加数值的type ‘Increment’，同理，减少数值的方法onDecrement中传入的actionType为‘DECREMENT’。</p>\n<p>到这里，整个计数器应用就完全开发完成了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>启动应用，打开浏览器，最终效果如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_208.png\" alt=\"image\"></p>\n<p>点击+、-按钮可以控制数字的加减，而且数字是实时更新的。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>通过redux实现的计数器应用已经开发完成了，你可以尝试梳理一下redux的流程，首先，redux的核心包括store、action、reducer，store暴露到全局应用中，通过store可以获取state，触发action，订阅state改变后的事件。要想改变state的数据，必须触发Action，action可以通过一些交互和事件来触发，reducer用来处理action，并返回一个新的state，当state改变后，store的subscribe方法就会触发，可以用来更新视图。如果你使用react来开发应用，当你的应用变得复杂，仅仅使用redux会变得很繁琐，你可能需要将store通过props来一层层传递到你需要的组件中，为了解决这样的问题，react-redux出现了，可以使用简单的方式获取到全局的状态，那么，拭目以待吧。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文结合实例讲解Redux的使用，可以更好的理解Redux。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>","more":"<p>当你已经了解一些redux的基础概念后，现在开始尝试使用redux吧，redux专注于状态管理，和react解耦，redux也可以结合Angular一起使用。本文尝试在react应用中使用redux来开发应用，而并没有使用react-redux，这有助于理解redux的数据流。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-1</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>首先，初始化一个react应用，使用creat-react-app来进行创建，使用之前需要先安装，打开命令行，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i create-react-app -g</span><br></pre></td></tr></table></figure>\n<p>进行全局安装。然后进入准备开发的目录，打开命令行，进入当前文件夹，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">create-react-app redux-app</span><br></pre></td></tr></table></figure>\n<p>，等待创建完成。然后</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br></pre></td></tr></table></figure>\n<p>，运行npm start，react应用会自动运行并打开浏览器。<br>下一步，需要安装redux，命令行输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i redux --save</span><br></pre></td></tr></table></figure>\n<p>，下面，开始编写redux部分。</p>\n<h3 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h3><p>由于应用比较简单，可以直接编写reducer部分，在src目录下新建reducers文件夹，新建index.js，在reducer中，主要处理action来返回新的state，在本应用中，计数器触发的action主要有加和减两种，分别将其定义为<br>‘INCREMENT’和’DECREMENT’，当触发计数器加1的时候，将state+1,触发计数器减1的时候，将state-1,否则，将返回原来的satte。并且需要将整个reducer export default以供其他部分使用。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (state = <span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducer编写完毕后，下一步需要生成store注入整个应用。此处，需要修改src目录下的index.js，通过import导入redux，需要使用redux提供的APIcreateStore将reducer生成整个应用的状态store，并且将store通过props传入整个应用的根组件App。同时，需要将原本的渲染逻辑封装成一个render方法并手动调用。同时，当store改变后，应用并不会自动重新渲染，需要使用store的方法subscribe来手动订阅，store.subscribe(render);意思是让store订阅render方法，当store改变时，就调用render重新渲染整个应用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;/</span>&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> registerServiceWorker <span class=\"keyword\">from</span> <span class=\"string\">'./registerServiceWorker'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;/</span>&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">render();</span><br><span class=\"line\"></span><br><span class=\"line\">store.subscribe(render);</span><br><span class=\"line\">registerServiceWorker();</span><br></pre></td></tr></table></figure>\n<h3 id=\"组件编写\"><a href=\"#组件编写\" class=\"headerlink\" title=\"组件编写\"></a>组件编写</h3><p>store通过props传递到APP组件后，在APP组件内需要通过store来获取数据以及触发action。在APP组件中，为了使组件逻辑分离，计数器相关的实现将会单独抽离成组件，APP组件负责将数据和事件通过props传递到计数器组件中。<br>在src目录下新建components目录，在components目录下新建Counter.js，下面是计数器的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementAsync = <span class=\"keyword\">this</span>.incrementAsync.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementIfOdd = <span class=\"keyword\">this</span>.incrementIfOdd.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrement, onDecrement &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;value&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrement&#125;&gt;</span><br><span class=\"line\">          +</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;onDecrement&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          -</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Counter;</span></span><br></pre></td></tr></table></figure>\n<p>在Counter组件中，通过props接收父组件传递的value和加、减数值的方法，value绑定到视图显示计数器的数值，加、减按钮分别用来控制计数器的加减操作，分别将父组件传递的方法进行绑定到按钮上。<br>然后在src目录下的App.js中引入计数器的组件，并在render中使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;store.getState()&#125;</span><br><span class=\"line\">          onIncrement=&#123;() =&gt; store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)&#125;</span><br><span class=\"line\">          onDecrement=&#123;() =&gt; store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'DECREMENT'</span> &#125;)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<p>在APP组件中，使用ES6的对象解构语法在props中获取store，在render中渲染计数器组件Counter，同时，向Couter组件传入约定的props，计数器数值value通过store.getState()来获取，增加数值方法onIncrement传入一个方法，调用store.dispatch来发起一个Action，action中传入代表增加数值的type ‘Increment’，同理，减少数值的方法onDecrement中传入的actionType为‘DECREMENT’。</p>\n<p>到这里，整个计数器应用就完全开发完成了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>启动应用，打开浏览器，最终效果如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_208.png\" alt=\"image\"></p>\n<p>点击+、-按钮可以控制数字的加减，而且数字是实时更新的。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>通过redux实现的计数器应用已经开发完成了，你可以尝试梳理一下redux的流程，首先，redux的核心包括store、action、reducer，store暴露到全局应用中，通过store可以获取state，触发action，订阅state改变后的事件。要想改变state的数据，必须触发Action，action可以通过一些交互和事件来触发，reducer用来处理action，并返回一个新的state，当state改变后，store的subscribe方法就会触发，可以用来更新视图。如果你使用react来开发应用，当你的应用变得复杂，仅仅使用redux会变得很繁琐，你可能需要将store通过props来一层层传递到你需要的组件中，为了解决这样的问题，react-redux出现了，可以使用简单的方式获取到全局的状态，那么，拭目以待吧。</p>"},{"title":"Webpack之打包体积优化","date":"2018-10-30T14:39:51.000Z","banner":"http://img.yanyuanfe.cn/webpack.png","_content":"> 本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack打包体积的方法。\n\n![image](http://img.yanyuanfe.cn/webpack.png)\n\n<!--more-->\nWebpack是当前大型项目的主流打包方案，自从将react的脚手架升级Webpack4以来，我也在不断尝试摸索webpack打包优化的一些方案。本文将从以下几个方面，对于如何优化Webpack的打包体积，进行一些总结。\n\n\n### Bundle分析\n\nwebpack-bundle-analyzer可以对打包输出的chunk进行可视化分析, 可以看到打包后每个模块的大小，还能给出gizp压缩后的大小，在生产环境中加载的模块都是经过gzip压缩过的，可以作为真实访问的大小依据。\n\n``` bash\nnpm install --save-dev webpack-bundle-analyzer\n```\n\n``` js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n}\n```\n\n\n\n### Tree-Shaking\n\nWebpack4在mode为production的情况下默认开启了Tree-Shaking，但在你的项目中可能会因为babel的原因导致它失效。\n\n因为Tree Shaking这个功能是依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。来找出未使用的代码，所以如果你使用了babel插件的时候，如：babel-preset-env，它默认会将模块打包成commonjs，这样就会让Tree Shaking失效了。\n\n所以需要配置 babel 不transform modules。配置如下：\n\n``` js\n// .babelrc\n{\n  \"presets\": [\n    [\"env\", {\n      modules: false,\n      ...\n    }]\n  ]\n}\n```\n\n### url-loader、file-loader配置优化\n\nurl-loader和file-loader一般用来处理背景图，默认会把css中的背景图打包成Base64，当css中的背景图过大，会造成打包后的css变得庞大，在单页应用中，css阻塞DOM渲染，造成首页白屏时间过长。曾遇到过某项目build后css多达4M，严重影响用户体验，解决办法是配置url-loader的limit字段，超过一定字节则不打包成base64。配置后重新打包后的css约300k。\n\n\n``` js\n{\n    test: /\\.(jpg|png|gif|svg)$/,\n    loader: 'url-loader',\n    include: path.join(__dirname, './src'),\n    exclude: /node_modules/,\n    options: {\n        limit: 8192,\n        name: 'images/[name].[hash:7].[ext]'\n    }\n}\n```\n### 按需加载\n当我们使用React、Vue开发SPA应用时，webpack默认会输出一个js文件，这意味这首屏渲染的时候，会加载完所有的页面js，js体积过大极大影响首屏渲染速度，按需加载是一个不错的选择，对每一个路由对应的页面打包成单独的chunk。目前最流行的办法是使用动态import的方法。在react项目中，你可以使用react-loadable这个第三方库。\n\n\n``` js\nimport Loadable from 'react-loadable';\nimport Loading from './my-loading-component';\n\nconst LoadableComponent = Loadable({\n  loader: () => import('./my-component'),\n  loading: Loading,\n});\n\n<Route path=\"/user\" component={LoadableComponent} />\n```\nwebpack会自动拆分chunk，首屏渲染时，只会加载对应的chunk，提高了渲染速度。\n\n### 按需打包mement、lodash、antd\nmoment、lodash、antd是使用频率很高的第三方库，但是库本身的体积很大，项目中又不会用到全部的功能，全部引入会造成打包后的体积过大。\n\nantd可以使用babel-plugin-import来进行按需加载，只需要安装babel-plugin-import然后配置.babelrc文件：\n\n\n``` js\n{\n  \"plugins\": [\n    [\n      \"import\", {\n        \"libraryName\": \"antd\",\n        \"style\": true\n      }\n    ]\n  ]\n}\n\n```\nbabel-plugin-import目前已经可以使用于antd、antd-mobile、lodash等库。\nlodash也可以使用babel-plugin-import来进行按需加载，也可以使用babel-plugin-lodash来按需加载lodash。\n\n\n``` bash\n npm i --save lodash\n npm i --save-dev babel-plugin-lodash @babel/cli @babel/preset-env\n```\n\n\n``` js\n// .babelrc\n{\n  \"plugins\": [\"lodash\"],\n  \"presets\": [[\"@babel/env\", { \"targets\": { \"node\": 6 } }]]\n}\n```\n\nmoment会将所有本地化内容和核心功能一起打包，打包出来的 moment 依赖包括了许多不需要的 locale 文件。因此我们需要对 moment 的 locale 文件进行按需打包。\n\n你可以使用 IgnorePlugin 在打包时忽略本地化内容:\n\n``` js\nnew webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/);\n```\n\n也可以使用webpack 的上下文替换插件(ContextReplacementPlugin)，允许覆盖查找规则，通过正则筛选指定的文件。\n\n只需要在 webpack 的配置文件 plugins 处增加如下代码即可:\n\n\n``` js\nplugins: [\n  new webpack.ContextReplacementPlugin(\n    /moment[/\\\\]locale$/,\n    /zh-cn/,\n  ),\n],\n```\n\n这里通过正则匹配了 moment/locale 下的名为 zh-cn 的文件。\n\n\n\n","source":"_posts/Webpack之打包体积优化.md","raw":"---\ntitle: Webpack之打包体积优化\ndate: 2018-10-30 22:39:51\nbanner: http://img.yanyuanfe.cn/webpack.png\ntags:\n- Webpack\n---\n> 本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack打包体积的方法。\n\n![image](http://img.yanyuanfe.cn/webpack.png)\n\n<!--more-->\nWebpack是当前大型项目的主流打包方案，自从将react的脚手架升级Webpack4以来，我也在不断尝试摸索webpack打包优化的一些方案。本文将从以下几个方面，对于如何优化Webpack的打包体积，进行一些总结。\n\n\n### Bundle分析\n\nwebpack-bundle-analyzer可以对打包输出的chunk进行可视化分析, 可以看到打包后每个模块的大小，还能给出gizp压缩后的大小，在生产环境中加载的模块都是经过gzip压缩过的，可以作为真实访问的大小依据。\n\n``` bash\nnpm install --save-dev webpack-bundle-analyzer\n```\n\n``` js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n}\n```\n\n\n\n### Tree-Shaking\n\nWebpack4在mode为production的情况下默认开启了Tree-Shaking，但在你的项目中可能会因为babel的原因导致它失效。\n\n因为Tree Shaking这个功能是依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。来找出未使用的代码，所以如果你使用了babel插件的时候，如：babel-preset-env，它默认会将模块打包成commonjs，这样就会让Tree Shaking失效了。\n\n所以需要配置 babel 不transform modules。配置如下：\n\n``` js\n// .babelrc\n{\n  \"presets\": [\n    [\"env\", {\n      modules: false,\n      ...\n    }]\n  ]\n}\n```\n\n### url-loader、file-loader配置优化\n\nurl-loader和file-loader一般用来处理背景图，默认会把css中的背景图打包成Base64，当css中的背景图过大，会造成打包后的css变得庞大，在单页应用中，css阻塞DOM渲染，造成首页白屏时间过长。曾遇到过某项目build后css多达4M，严重影响用户体验，解决办法是配置url-loader的limit字段，超过一定字节则不打包成base64。配置后重新打包后的css约300k。\n\n\n``` js\n{\n    test: /\\.(jpg|png|gif|svg)$/,\n    loader: 'url-loader',\n    include: path.join(__dirname, './src'),\n    exclude: /node_modules/,\n    options: {\n        limit: 8192,\n        name: 'images/[name].[hash:7].[ext]'\n    }\n}\n```\n### 按需加载\n当我们使用React、Vue开发SPA应用时，webpack默认会输出一个js文件，这意味这首屏渲染的时候，会加载完所有的页面js，js体积过大极大影响首屏渲染速度，按需加载是一个不错的选择，对每一个路由对应的页面打包成单独的chunk。目前最流行的办法是使用动态import的方法。在react项目中，你可以使用react-loadable这个第三方库。\n\n\n``` js\nimport Loadable from 'react-loadable';\nimport Loading from './my-loading-component';\n\nconst LoadableComponent = Loadable({\n  loader: () => import('./my-component'),\n  loading: Loading,\n});\n\n<Route path=\"/user\" component={LoadableComponent} />\n```\nwebpack会自动拆分chunk，首屏渲染时，只会加载对应的chunk，提高了渲染速度。\n\n### 按需打包mement、lodash、antd\nmoment、lodash、antd是使用频率很高的第三方库，但是库本身的体积很大，项目中又不会用到全部的功能，全部引入会造成打包后的体积过大。\n\nantd可以使用babel-plugin-import来进行按需加载，只需要安装babel-plugin-import然后配置.babelrc文件：\n\n\n``` js\n{\n  \"plugins\": [\n    [\n      \"import\", {\n        \"libraryName\": \"antd\",\n        \"style\": true\n      }\n    ]\n  ]\n}\n\n```\nbabel-plugin-import目前已经可以使用于antd、antd-mobile、lodash等库。\nlodash也可以使用babel-plugin-import来进行按需加载，也可以使用babel-plugin-lodash来按需加载lodash。\n\n\n``` bash\n npm i --save lodash\n npm i --save-dev babel-plugin-lodash @babel/cli @babel/preset-env\n```\n\n\n``` js\n// .babelrc\n{\n  \"plugins\": [\"lodash\"],\n  \"presets\": [[\"@babel/env\", { \"targets\": { \"node\": 6 } }]]\n}\n```\n\nmoment会将所有本地化内容和核心功能一起打包，打包出来的 moment 依赖包括了许多不需要的 locale 文件。因此我们需要对 moment 的 locale 文件进行按需打包。\n\n你可以使用 IgnorePlugin 在打包时忽略本地化内容:\n\n``` js\nnew webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/);\n```\n\n也可以使用webpack 的上下文替换插件(ContextReplacementPlugin)，允许覆盖查找规则，通过正则筛选指定的文件。\n\n只需要在 webpack 的配置文件 plugins 处增加如下代码即可:\n\n\n``` js\nplugins: [\n  new webpack.ContextReplacementPlugin(\n    /moment[/\\\\]locale$/,\n    /zh-cn/,\n  ),\n],\n```\n\n这里通过正则匹配了 moment/locale 下的名为 zh-cn 的文件。\n\n\n\n","slug":"Webpack之打包体积优化","published":1,"updated":"2020-07-16T13:56:47.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenn9000dp70vxjkcbkax","content":"<blockquote>\n<p>本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack打包体积的方法。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/webpack.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>Webpack是当前大型项目的主流打包方案，自从将react的脚手架升级Webpack4以来，我也在不断尝试摸索webpack打包优化的一些方案。本文将从以下几个方面，对于如何优化Webpack的打包体积，进行一些总结。</p>\n<h3 id=\"Bundle分析\"><a href=\"#Bundle分析\" class=\"headerlink\" title=\"Bundle分析\"></a>Bundle分析</h3><p>webpack-bundle-analyzer可以对打包输出的chunk进行可视化分析, 可以看到打包后每个模块的大小，还能给出gizp压缩后的大小，在生产环境中加载的模块都是经过gzip压缩过的，可以作为真实访问的大小依据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BundleAnalyzerPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree-Shaking\"></a>Tree-Shaking</h3><p>Webpack4在mode为production的情况下默认开启了Tree-Shaking，但在你的项目中可能会因为babel的原因导致它失效。</p>\n<p>因为Tree Shaking这个功能是依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。来找出未使用的代码，所以如果你使用了babel插件的时候，如：babel-preset-env，它默认会将模块打包成commonjs，这样就会让Tree Shaking失效了。</p>\n<p>所以需要配置 babel 不transform modules。配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .babelrc</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"env\"</span>, &#123;</span><br><span class=\"line\">      modules: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"url-loader、file-loader配置优化\"><a href=\"#url-loader、file-loader配置优化\" class=\"headerlink\" title=\"url-loader、file-loader配置优化\"></a>url-loader、file-loader配置优化</h3><p>url-loader和file-loader一般用来处理背景图，默认会把css中的背景图打包成Base64，当css中的背景图过大，会造成打包后的css变得庞大，在单页应用中，css阻塞DOM渲染，造成首页白屏时间过长。曾遇到过某项目build后css多达4M，严重影响用户体验，解决办法是配置url-loader的limit字段，超过一定字节则不打包成base64。配置后重新打包后的css约300k。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(jpg|png|gif|svg)$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">    include: path.join(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        limit: <span class=\"number\">8192</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'images/[name].[hash:7].[ext]'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h3><p>当我们使用React、Vue开发SPA应用时，webpack默认会输出一个js文件，这意味这首屏渲染的时候，会加载完所有的页面js，js体积过大极大影响首屏渲染速度，按需加载是一个不错的选择，对每一个路由对应的页面打包成单独的chunk。目前最流行的办法是使用动态import的方法。在react项目中，你可以使用react-loadable这个第三方库。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Loadable <span class=\"keyword\">from</span> <span class=\"string\">'react-loadable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Loading <span class=\"keyword\">from</span> <span class=\"string\">'./my-loading-component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> LoadableComponent = Loadable(&#123;</span><br><span class=\"line\">  loader: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./my-component'</span>),</span><br><span class=\"line\">  loading: Loading,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/user\"</span> component=&#123;LoadableComponent&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>webpack会自动拆分chunk，首屏渲染时，只会加载对应的chunk，提高了渲染速度。</p>\n<h3 id=\"按需打包mement、lodash、antd\"><a href=\"#按需打包mement、lodash、antd\" class=\"headerlink\" title=\"按需打包mement、lodash、antd\"></a>按需打包mement、lodash、antd</h3><p>moment、lodash、antd是使用频率很高的第三方库，但是库本身的体积很大，项目中又不会用到全部的功能，全部引入会造成打包后的体积过大。</p>\n<p>antd可以使用babel-plugin-import来进行按需加载，只需要安装babel-plugin-import然后配置.babelrc文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"import\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"string\">\"libraryName\"</span>: <span class=\"string\">\"antd\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"style\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>babel-plugin-import目前已经可以使用于antd、antd-mobile、lodash等库。<br>lodash也可以使用babel-plugin-import来进行按需加载，也可以使用babel-plugin-lodash来按需加载lodash。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i --save lodash</span><br><span class=\"line\">npm i --save-dev babel-plugin-lodash @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .babelrc</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [<span class=\"string\">\"lodash\"</span>],</span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [[<span class=\"string\">\"@babel/env\"</span>, &#123; <span class=\"string\">\"targets\"</span>: &#123; <span class=\"string\">\"node\"</span>: <span class=\"number\">6</span> &#125; &#125;]]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>moment会将所有本地化内容和核心功能一起打包，打包出来的 moment 依赖包括了许多不需要的 locale 文件。因此我们需要对 moment 的 locale 文件进行按需打包。</p>\n<p>你可以使用 IgnorePlugin 在打包时忽略本地化内容:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/^\\.\\/locale$/</span>, /moment$/);</span><br></pre></td></tr></table></figure>\n<p>也可以使用webpack 的上下文替换插件(ContextReplacementPlugin)，允许覆盖查找规则，通过正则筛选指定的文件。</p>\n<p>只需要在 webpack 的配置文件 plugins 处增加如下代码即可:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.ContextReplacementPlugin(</span><br><span class=\"line\">    /moment[<span class=\"regexp\">/\\\\]locale$/</span>,</span><br><span class=\"line\">    /zh-cn/,</span><br><span class=\"line\">  ),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<p>这里通过正则匹配了 moment/locale 下的名为 zh-cn 的文件。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack打包体积的方法。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/webpack.png\" alt=\"image\"></p>","more":"<p>Webpack是当前大型项目的主流打包方案，自从将react的脚手架升级Webpack4以来，我也在不断尝试摸索webpack打包优化的一些方案。本文将从以下几个方面，对于如何优化Webpack的打包体积，进行一些总结。</p>\n<h3 id=\"Bundle分析\"><a href=\"#Bundle分析\" class=\"headerlink\" title=\"Bundle分析\"></a>Bundle分析</h3><p>webpack-bundle-analyzer可以对打包输出的chunk进行可视化分析, 可以看到打包后每个模块的大小，还能给出gizp压缩后的大小，在生产环境中加载的模块都是经过gzip压缩过的，可以作为真实访问的大小依据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BundleAnalyzerPlugin()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree-Shaking\"></a>Tree-Shaking</h3><p>Webpack4在mode为production的情况下默认开启了Tree-Shaking，但在你的项目中可能会因为babel的原因导致它失效。</p>\n<p>因为Tree Shaking这个功能是依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。来找出未使用的代码，所以如果你使用了babel插件的时候，如：babel-preset-env，它默认会将模块打包成commonjs，这样就会让Tree Shaking失效了。</p>\n<p>所以需要配置 babel 不transform modules。配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .babelrc</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"env\"</span>, &#123;</span><br><span class=\"line\">      modules: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"url-loader、file-loader配置优化\"><a href=\"#url-loader、file-loader配置优化\" class=\"headerlink\" title=\"url-loader、file-loader配置优化\"></a>url-loader、file-loader配置优化</h3><p>url-loader和file-loader一般用来处理背景图，默认会把css中的背景图打包成Base64，当css中的背景图过大，会造成打包后的css变得庞大，在单页应用中，css阻塞DOM渲染，造成首页白屏时间过长。曾遇到过某项目build后css多达4M，严重影响用户体验，解决办法是配置url-loader的limit字段，超过一定字节则不打包成base64。配置后重新打包后的css约300k。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(jpg|png|gif|svg)$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">    include: path.join(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        limit: <span class=\"number\">8192</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'images/[name].[hash:7].[ext]'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h3><p>当我们使用React、Vue开发SPA应用时，webpack默认会输出一个js文件，这意味这首屏渲染的时候，会加载完所有的页面js，js体积过大极大影响首屏渲染速度，按需加载是一个不错的选择，对每一个路由对应的页面打包成单独的chunk。目前最流行的办法是使用动态import的方法。在react项目中，你可以使用react-loadable这个第三方库。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Loadable <span class=\"keyword\">from</span> <span class=\"string\">'react-loadable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Loading <span class=\"keyword\">from</span> <span class=\"string\">'./my-loading-component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> LoadableComponent = Loadable(&#123;</span><br><span class=\"line\">  loader: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./my-component'</span>),</span><br><span class=\"line\">  loading: Loading,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/user\"</span> component=&#123;LoadableComponent&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>webpack会自动拆分chunk，首屏渲染时，只会加载对应的chunk，提高了渲染速度。</p>\n<h3 id=\"按需打包mement、lodash、antd\"><a href=\"#按需打包mement、lodash、antd\" class=\"headerlink\" title=\"按需打包mement、lodash、antd\"></a>按需打包mement、lodash、antd</h3><p>moment、lodash、antd是使用频率很高的第三方库，但是库本身的体积很大，项目中又不会用到全部的功能，全部引入会造成打包后的体积过大。</p>\n<p>antd可以使用babel-plugin-import来进行按需加载，只需要安装babel-plugin-import然后配置.babelrc文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">\"import\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"string\">\"libraryName\"</span>: <span class=\"string\">\"antd\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"style\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>babel-plugin-import目前已经可以使用于antd、antd-mobile、lodash等库。<br>lodash也可以使用babel-plugin-import来进行按需加载，也可以使用babel-plugin-lodash来按需加载lodash。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i --save lodash</span><br><span class=\"line\">npm i --save-dev babel-plugin-lodash @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .babelrc</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [<span class=\"string\">\"lodash\"</span>],</span><br><span class=\"line\">  <span class=\"string\">\"presets\"</span>: [[<span class=\"string\">\"@babel/env\"</span>, &#123; <span class=\"string\">\"targets\"</span>: &#123; <span class=\"string\">\"node\"</span>: <span class=\"number\">6</span> &#125; &#125;]]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>moment会将所有本地化内容和核心功能一起打包，打包出来的 moment 依赖包括了许多不需要的 locale 文件。因此我们需要对 moment 的 locale 文件进行按需打包。</p>\n<p>你可以使用 IgnorePlugin 在打包时忽略本地化内容:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/^\\.\\/locale$/</span>, /moment$/);</span><br></pre></td></tr></table></figure>\n<p>也可以使用webpack 的上下文替换插件(ContextReplacementPlugin)，允许覆盖查找规则，通过正则筛选指定的文件。</p>\n<p>只需要在 webpack 的配置文件 plugins 处增加如下代码即可:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.ContextReplacementPlugin(</span><br><span class=\"line\">    /moment[<span class=\"regexp\">/\\\\]locale$/</span>,</span><br><span class=\"line\">    /zh-cn/,</span><br><span class=\"line\">  ),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<p>这里通过正则匹配了 moment/locale 下的名为 zh-cn 的文件。</p>"},{"title":"Ubuntu下搭建前端开发环境和常用工具","date":"2017-01-21T07:52:25.000Z","banner":"http://img.yanyuanfe.cn/isodesk.jpg","_content":"\n\n> 现在越来越多的公司都要求开发熟悉Linux环境下开发，常用的Linux版本为Ubuntu，在Ubuntu下开发需要的一些环境和工具是必然要了解的。\n\n![image](http://img.yanyuanfe.cn/isodesk.jpg)\n\n<!--more-->\n\n\n<div class=\"tip\">\n    距离刚开始入职实习到现在已经一个月，还记得刚领到公司配的电脑，打开发现是Ubuntu，整个人都是懵逼的，之前虽然在虚拟机跑过Ubuntu，但是也还没有完全使用它来开发，所以还是吃惊不小，不过心里也有些激动，毕竟Ubuntu要是用的6也挺装逼的不是吗？后来经过一周的熟悉，也掌握了一些基本的操作，也曾踩过许多坑，所以写下这篇文章来总结一下。\n</div>\n\n\n### 科学上网\n\n科学上网应该是每个开发者的必备技能吧，在一台新电脑上，上不了Google简直浑身难受。而且科学上网后上Github的速度都是杠杠的。\n\n目前所知科学上网的几种姿势里，蓝灯最简单方便，shadowsocks最好用，下面分别讲解下其安装方法：\n\nPS：Ubuntu下最常用的快捷键是打开终端：Ctrl+Alt+T。\nWin键：快速打开Dash Home应用搜索。\n\n- Lantern：蓝灯。\n蓝灯的Github：https://github.com/getlantern/lantern\n进去直接下载Ubuntu的deb安装包，下载后双击打开按提示安装即可。\n安装完成后可以按win键进入Dash Home搜索lantern找到蓝灯，或者在命令行输入lantern即可自动打开浏览器，看下是不是能上谷歌了。\n- shadowsocks\nshadowsocks应该是现在最稳定可靠的科学上网利器了，在Ubuntu下安装和配置我也是捣鼓了好几天。\n在Ubuntu下使用shadowsocks最好安装其GUI图形客户端——shadowsocks-qt5，这样以后每次操作会很方便。\n\nshadowsocks-qt5的安装指南：https://github.com/carvenli/shadowsocks-qt5-wiki\n\n**Ubuntu**\n\n通过PPA源安装，仅支持Ubuntu 14.04或更高版本。\n\n\n``` bash\n$ sudo add-apt-repository ppa:hzwhuang/ss-qt5\n$ sudo apt-get update\n$ sudo apt-get install shadowsocks-qt5\n```\n我在安装的时候就出问题了，在运行sudo apt-get update的时候报错hash校验和不符，我百度谷歌试了N种解决方案都没用，甚至重装了一遍系统也一样，最后在同事电脑上安装也不行，后面发现好像是系统问题，于是我在自己的Win10笔记本的虚拟机上试了下，16.06版本的居然可以安装，而公司电脑默认安装的都是Ubuntu14.04的版本的，后来我果断装了Ubuntu16.06才解决这个问题。\n\nshadowsocks不是像lantern那样安装了就能用的，它需要你有服务器节点，在客户端界面进行相关配置，具体资源需要自己去发掘了，最简便的是导入配置文件就好了，然后连接节点，这时候还不能科学上网，Ubuntu需要配置Sockt5代理，打开设置>网络>代理，选择手动，设置Socket5，地址一般是127.0.0.1，端口为8080。然后确定输入密码就可以尽情上Google了。\n\n\n<div class=\"tip\">\nUbuntu16.04的软件中心应该是有bug，安装不了第三方.deb文件，我们只有使用dpkg -i 或者gdebi的方式安装，我使用的是后者，因为后者功能更加强大。要使用gdebi命令先要安装它：\n打开终端并使用下面的命令:\n\n\n sudo apt-get install gdebi\n\n\n然后就可以安装.deb文件了。安装过程如下：先切换到你下载的lantern的安装文件目录下，直接使用：\n\n\n sudo gdebi lantern-installer-beta-64-bit.deb\n\n</div>\n\n\n### Chrome\n\nChrome是我钟爱的浏览器，没有之一。新电脑首先安装的软件就是Chrome，安装Chrome直接进入百度搜索Chrome进入官网下载deb包安装即可。\n\n### Sublime\n\n终于轮到开发工具了，Sublime应该是最轻量级的编辑器了吧，她最大的特点就是秒开，配合其强大的插件库也是如有神助。\n进入Sublime的官网：http://www.sublimetext.com/，可直接下载其deb安装包。\n当然，你也可以通过终端，仅需三行命令：\n\n``` bash\n$ sudo add-apt-repository ppa:webupd8team/sublime-text-3\n\n$ sudo apt-get update\n\n$ sudo apt-get install sublime-text-installer\n\n```\n最后可在Dash Home中见到Sublime-text的软件图标，点击就可使用了.\n你也可以从命令行启动：\n\n``` bash\n$ subl\n```\n\n\n<div class=\"tip\">\n    在使用Sublime时遇到的问题：首先我们都会去安装自己常用的插件来提高自己的开发效率，在安装packge的时候经常遇到安装失败的问题，因为Sublime Text的很多package repository都在托管在github上，但是github在国内的网络环境下有时……。因此在使用Package Control安装插件时，会出现下面的Prompt：\n    ![image](http://img.yanyuanfe.cn/130046_LhBu_243155.png)\n    解决方案如下：  \n    1.  命令行输入：\n\n```bash\n$ dig @8.8.8.8 -t A sublime.wbond.net +noall +answer\n```\n\n输出如下：  \n\n  ; <<>> DiG 9.9.5-3-Ubuntu <<>> @8.8.8.8 -t A   \n  sublime.wbond.net +noall +answer  \n  ; (1 server found)  \n  ;; global options: +cmd  \n  sublime.wbond.net.  82  IN  A   50.116.34.243    \n  那么IPv4 地址就是50.116.34.243.   \n  2.  命令行输入\n\n``` bash\n$ sudo vim /etc/hosts\n```\n\n打开 /etc/hosts文件，然后用上面的IPV4地址将{}替换掉就OK了。  \n{IPv4 address}    sublime.wbond.net \n\n</div>\n\n\n### WebStorm\nWebStorm被成为前端开发神器，我在项目开发的过程中使用的也是这个IDE，值得一提的是它的Git工具，很强大，特别是在处理代码冲突的时候，你会被它折服的。\n\n**安装**\n\n下载：http://www.jetbrains.com/webstorm/\n\n解压下载的 gz 包，命令行下运行：\n\n``` bash\n$ cd bin\n$ ./webstorm.sh\n```\n然后就安装成功了，不过 WebStorm 默认情况下是需要收费的，你可以去找找密钥试试。\n\n### Node\nNode也应该是前端工程化必备的一个工具了。\n安装Node先安装nvm。\nnvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。\n**安装**\n``` bash\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n```\n**配置**\n``` bash\n$ export NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试。\n\n``` bash\n$ nvm\n```\n\n当看到有输出时，则 nvm 安装成功。\n\n使用 nvm 的命令安装 Node.js 最新版：\n\n``` bash\n$ nvm install node\n```\n\n然后在任何新的shell只是使用已安装的版本：\n\n``` bash\n$ nvm use node\n```\n\n安装特定版本Node：\n\n``` bash\n$ nvm run node --version\n```\n\n安装完成后，查看一下\n\n\n``` bash\n$ nvm ls\n```\n这时候可以看到自己安装的所有 Node.js 版本，那个绿色小箭头的意思就是现在正在使用的版本。\n如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 7.4.0 版本\n\n``` bash\n$ nvm use 7.4.0\n```\n\n然后再次查看，这时候小箭头应该出现了。\n\nOK，我们在终端中输入\n\n\n``` bash\n$ node\n```\n\nREPL(read–eval–print loop) 应该就出来了，那我们就成功了。\n\n随便敲两行命令玩玩吧。\n\n\n### Git\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。通过使用git工具，我们可以实现团队间合作开发统一管理，可以从远程仓库中提取代码，也可以把代码上传到远程仓库，从而实现代码的同步更新。\n**安装**\n\n``` bash\n$ sudo apt-get install git\n```\n配置git用户名和邮箱，之后就可以使用git工具了。\n\n``` bash\n$ git config --global user.name  \"用户名或者用户ID\"\n```\n``` bash\n$ git config --global user.email  \"邮箱\"\n```\n\n\n### zsh\n一开始我不知道还有zsh这个东东的，后来看到同事的终端怎么比我的漂亮，就去琢磨了下，原来这就是zsh——传说中的终极Shell。\nLinux发行版通常默认的Shell就是Bash。也就是你刚开始打开的终端。\n\nBash确实是不错的Shell，但仍有用很多不尽人意的地方，如自动补全的功能不够强大，定位较长路径不够方便，命令历史管理不够完善等。\n\n使用zsh，你会变得很Geek。\n\n想知道你的系统有几种shell，可以通过以下命令查看：\n\n``` bash\n$ cat /etc/shells\n```\n**安装zsh**\n\n\n``` bash\n$ sudo apt-get install zsh\n```\n安装完成后设置当前用户使用 zsh：\n\n``` bash\n$ chsh -s /bin/zsh\n```\n\n根据提示输入当前用户的密码然后**重启**就可以了（一开始安装了没重启就用发现还是Bash还以为安装错了）。\n\n**安装oh my zsh**\n\n因为 zsh 的默认配置及其复杂繁琐,让人望而却步,直到有了oh-my-zsh这个开源项目,让zsh配置降到0门槛.而且它完全兼容 bash .\n\n地址:https://github.com/robbyrussell/oh-my-zsh\n\n它就是为配置你的 zsh 而生的.\n\n安装「oh my zsh」可以自动安装也可以手动安装。\n\n自动安装：\n\n``` bash\n$ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n\n手动安装：\n\n\n``` bash\n$ git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n\n安装 oh-my-zsh 时,它自动读取你的环境变量并且自动帮 zsh 进行设置.\n\n### 微信\n\n**Electronic-wechat**\n\n**Ubuntu微信客户端下载**\n\n开箱即用的稳定版应用：\nhttps://github.com/geeeeeeeeek/electronic-wechat/releases \n\n**项目地址**\n\nhttps://github.com/geeeeeeeeek/electronic-wechat\n\n**如何使用**\n\n在下载和运行这个项目之前，你需要在电脑上安装 Git 和 Node.js (来自 npm)。\n\n在命令行中输入:\n**下载仓库**\n\n\n``` bash\n$ git clone https://github.com/geeeeeeeeek/electronic-wechat.git\n```\n\n**进入仓库**\n\n\n``` bash\n$ cd electronic-wechat\n```\n\n**安装依赖, 运行应用**\n\n\n``` bash\n$ npm install && npm start\n```\n\n根据你的平台打包应用:\n\n``` bash\n$ npm run build:osx\n$ npm run build:linux\n$ npm run build:win\n```\n\n提示: 如果 npm install 下载缓慢，你可以使用 淘宝镜像(cnpm) 替代 npm 。\n\n### Shutter\n\n**Ubuntu下的截图利器Shutter**\n\n1. 打开Ubuntu软件中心,搜索Shutter并安装\n2. 搜索系统中安装的Shutter并使用\n3. 体验功能齐全的截图工具吧，包括全屏幕截图，区域截图，下拉菜单截图等超多功能 \n\n### End\n\n到此为止，介绍了一些Ubuntu下前端开发环境的搭建和常用的工具，后续有好的工具会再次更新的。\n\n\n\n","source":"_posts/Ubuntu下搭建前端开发环境和常用工具.md","raw":"---\ntitle: Ubuntu下搭建前端开发环境和常用工具\ndate: 2017-01-21 15:52:25\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/isodesk.jpg\ntags:\n\t- Linux\n---\n\n\n> 现在越来越多的公司都要求开发熟悉Linux环境下开发，常用的Linux版本为Ubuntu，在Ubuntu下开发需要的一些环境和工具是必然要了解的。\n\n![image](http://img.yanyuanfe.cn/isodesk.jpg)\n\n<!--more-->\n\n\n<div class=\"tip\">\n    距离刚开始入职实习到现在已经一个月，还记得刚领到公司配的电脑，打开发现是Ubuntu，整个人都是懵逼的，之前虽然在虚拟机跑过Ubuntu，但是也还没有完全使用它来开发，所以还是吃惊不小，不过心里也有些激动，毕竟Ubuntu要是用的6也挺装逼的不是吗？后来经过一周的熟悉，也掌握了一些基本的操作，也曾踩过许多坑，所以写下这篇文章来总结一下。\n</div>\n\n\n### 科学上网\n\n科学上网应该是每个开发者的必备技能吧，在一台新电脑上，上不了Google简直浑身难受。而且科学上网后上Github的速度都是杠杠的。\n\n目前所知科学上网的几种姿势里，蓝灯最简单方便，shadowsocks最好用，下面分别讲解下其安装方法：\n\nPS：Ubuntu下最常用的快捷键是打开终端：Ctrl+Alt+T。\nWin键：快速打开Dash Home应用搜索。\n\n- Lantern：蓝灯。\n蓝灯的Github：https://github.com/getlantern/lantern\n进去直接下载Ubuntu的deb安装包，下载后双击打开按提示安装即可。\n安装完成后可以按win键进入Dash Home搜索lantern找到蓝灯，或者在命令行输入lantern即可自动打开浏览器，看下是不是能上谷歌了。\n- shadowsocks\nshadowsocks应该是现在最稳定可靠的科学上网利器了，在Ubuntu下安装和配置我也是捣鼓了好几天。\n在Ubuntu下使用shadowsocks最好安装其GUI图形客户端——shadowsocks-qt5，这样以后每次操作会很方便。\n\nshadowsocks-qt5的安装指南：https://github.com/carvenli/shadowsocks-qt5-wiki\n\n**Ubuntu**\n\n通过PPA源安装，仅支持Ubuntu 14.04或更高版本。\n\n\n``` bash\n$ sudo add-apt-repository ppa:hzwhuang/ss-qt5\n$ sudo apt-get update\n$ sudo apt-get install shadowsocks-qt5\n```\n我在安装的时候就出问题了，在运行sudo apt-get update的时候报错hash校验和不符，我百度谷歌试了N种解决方案都没用，甚至重装了一遍系统也一样，最后在同事电脑上安装也不行，后面发现好像是系统问题，于是我在自己的Win10笔记本的虚拟机上试了下，16.06版本的居然可以安装，而公司电脑默认安装的都是Ubuntu14.04的版本的，后来我果断装了Ubuntu16.06才解决这个问题。\n\nshadowsocks不是像lantern那样安装了就能用的，它需要你有服务器节点，在客户端界面进行相关配置，具体资源需要自己去发掘了，最简便的是导入配置文件就好了，然后连接节点，这时候还不能科学上网，Ubuntu需要配置Sockt5代理，打开设置>网络>代理，选择手动，设置Socket5，地址一般是127.0.0.1，端口为8080。然后确定输入密码就可以尽情上Google了。\n\n\n<div class=\"tip\">\nUbuntu16.04的软件中心应该是有bug，安装不了第三方.deb文件，我们只有使用dpkg -i 或者gdebi的方式安装，我使用的是后者，因为后者功能更加强大。要使用gdebi命令先要安装它：\n打开终端并使用下面的命令:\n\n\n sudo apt-get install gdebi\n\n\n然后就可以安装.deb文件了。安装过程如下：先切换到你下载的lantern的安装文件目录下，直接使用：\n\n\n sudo gdebi lantern-installer-beta-64-bit.deb\n\n</div>\n\n\n### Chrome\n\nChrome是我钟爱的浏览器，没有之一。新电脑首先安装的软件就是Chrome，安装Chrome直接进入百度搜索Chrome进入官网下载deb包安装即可。\n\n### Sublime\n\n终于轮到开发工具了，Sublime应该是最轻量级的编辑器了吧，她最大的特点就是秒开，配合其强大的插件库也是如有神助。\n进入Sublime的官网：http://www.sublimetext.com/，可直接下载其deb安装包。\n当然，你也可以通过终端，仅需三行命令：\n\n``` bash\n$ sudo add-apt-repository ppa:webupd8team/sublime-text-3\n\n$ sudo apt-get update\n\n$ sudo apt-get install sublime-text-installer\n\n```\n最后可在Dash Home中见到Sublime-text的软件图标，点击就可使用了.\n你也可以从命令行启动：\n\n``` bash\n$ subl\n```\n\n\n<div class=\"tip\">\n    在使用Sublime时遇到的问题：首先我们都会去安装自己常用的插件来提高自己的开发效率，在安装packge的时候经常遇到安装失败的问题，因为Sublime Text的很多package repository都在托管在github上，但是github在国内的网络环境下有时……。因此在使用Package Control安装插件时，会出现下面的Prompt：\n    ![image](http://img.yanyuanfe.cn/130046_LhBu_243155.png)\n    解决方案如下：  \n    1.  命令行输入：\n\n```bash\n$ dig @8.8.8.8 -t A sublime.wbond.net +noall +answer\n```\n\n输出如下：  \n\n  ; <<>> DiG 9.9.5-3-Ubuntu <<>> @8.8.8.8 -t A   \n  sublime.wbond.net +noall +answer  \n  ; (1 server found)  \n  ;; global options: +cmd  \n  sublime.wbond.net.  82  IN  A   50.116.34.243    \n  那么IPv4 地址就是50.116.34.243.   \n  2.  命令行输入\n\n``` bash\n$ sudo vim /etc/hosts\n```\n\n打开 /etc/hosts文件，然后用上面的IPV4地址将{}替换掉就OK了。  \n{IPv4 address}    sublime.wbond.net \n\n</div>\n\n\n### WebStorm\nWebStorm被成为前端开发神器，我在项目开发的过程中使用的也是这个IDE，值得一提的是它的Git工具，很强大，特别是在处理代码冲突的时候，你会被它折服的。\n\n**安装**\n\n下载：http://www.jetbrains.com/webstorm/\n\n解压下载的 gz 包，命令行下运行：\n\n``` bash\n$ cd bin\n$ ./webstorm.sh\n```\n然后就安装成功了，不过 WebStorm 默认情况下是需要收费的，你可以去找找密钥试试。\n\n### Node\nNode也应该是前端工程化必备的一个工具了。\n安装Node先安装nvm。\nnvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。\n**安装**\n``` bash\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n```\n**配置**\n``` bash\n$ export NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试。\n\n``` bash\n$ nvm\n```\n\n当看到有输出时，则 nvm 安装成功。\n\n使用 nvm 的命令安装 Node.js 最新版：\n\n``` bash\n$ nvm install node\n```\n\n然后在任何新的shell只是使用已安装的版本：\n\n``` bash\n$ nvm use node\n```\n\n安装特定版本Node：\n\n``` bash\n$ nvm run node --version\n```\n\n安装完成后，查看一下\n\n\n``` bash\n$ nvm ls\n```\n这时候可以看到自己安装的所有 Node.js 版本，那个绿色小箭头的意思就是现在正在使用的版本。\n如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 7.4.0 版本\n\n``` bash\n$ nvm use 7.4.0\n```\n\n然后再次查看，这时候小箭头应该出现了。\n\nOK，我们在终端中输入\n\n\n``` bash\n$ node\n```\n\nREPL(read–eval–print loop) 应该就出来了，那我们就成功了。\n\n随便敲两行命令玩玩吧。\n\n\n### Git\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。通过使用git工具，我们可以实现团队间合作开发统一管理，可以从远程仓库中提取代码，也可以把代码上传到远程仓库，从而实现代码的同步更新。\n**安装**\n\n``` bash\n$ sudo apt-get install git\n```\n配置git用户名和邮箱，之后就可以使用git工具了。\n\n``` bash\n$ git config --global user.name  \"用户名或者用户ID\"\n```\n``` bash\n$ git config --global user.email  \"邮箱\"\n```\n\n\n### zsh\n一开始我不知道还有zsh这个东东的，后来看到同事的终端怎么比我的漂亮，就去琢磨了下，原来这就是zsh——传说中的终极Shell。\nLinux发行版通常默认的Shell就是Bash。也就是你刚开始打开的终端。\n\nBash确实是不错的Shell，但仍有用很多不尽人意的地方，如自动补全的功能不够强大，定位较长路径不够方便，命令历史管理不够完善等。\n\n使用zsh，你会变得很Geek。\n\n想知道你的系统有几种shell，可以通过以下命令查看：\n\n``` bash\n$ cat /etc/shells\n```\n**安装zsh**\n\n\n``` bash\n$ sudo apt-get install zsh\n```\n安装完成后设置当前用户使用 zsh：\n\n``` bash\n$ chsh -s /bin/zsh\n```\n\n根据提示输入当前用户的密码然后**重启**就可以了（一开始安装了没重启就用发现还是Bash还以为安装错了）。\n\n**安装oh my zsh**\n\n因为 zsh 的默认配置及其复杂繁琐,让人望而却步,直到有了oh-my-zsh这个开源项目,让zsh配置降到0门槛.而且它完全兼容 bash .\n\n地址:https://github.com/robbyrussell/oh-my-zsh\n\n它就是为配置你的 zsh 而生的.\n\n安装「oh my zsh」可以自动安装也可以手动安装。\n\n自动安装：\n\n``` bash\n$ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n\n手动安装：\n\n\n``` bash\n$ git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n\n安装 oh-my-zsh 时,它自动读取你的环境变量并且自动帮 zsh 进行设置.\n\n### 微信\n\n**Electronic-wechat**\n\n**Ubuntu微信客户端下载**\n\n开箱即用的稳定版应用：\nhttps://github.com/geeeeeeeeek/electronic-wechat/releases \n\n**项目地址**\n\nhttps://github.com/geeeeeeeeek/electronic-wechat\n\n**如何使用**\n\n在下载和运行这个项目之前，你需要在电脑上安装 Git 和 Node.js (来自 npm)。\n\n在命令行中输入:\n**下载仓库**\n\n\n``` bash\n$ git clone https://github.com/geeeeeeeeek/electronic-wechat.git\n```\n\n**进入仓库**\n\n\n``` bash\n$ cd electronic-wechat\n```\n\n**安装依赖, 运行应用**\n\n\n``` bash\n$ npm install && npm start\n```\n\n根据你的平台打包应用:\n\n``` bash\n$ npm run build:osx\n$ npm run build:linux\n$ npm run build:win\n```\n\n提示: 如果 npm install 下载缓慢，你可以使用 淘宝镜像(cnpm) 替代 npm 。\n\n### Shutter\n\n**Ubuntu下的截图利器Shutter**\n\n1. 打开Ubuntu软件中心,搜索Shutter并安装\n2. 搜索系统中安装的Shutter并使用\n3. 体验功能齐全的截图工具吧，包括全屏幕截图，区域截图，下拉菜单截图等超多功能 \n\n### End\n\n到此为止，介绍了一些Ubuntu下前端开发环境的搭建和常用的工具，后续有好的工具会再次更新的。\n\n\n\n","slug":"Ubuntu下搭建前端开发环境和常用工具","published":1,"updated":"2020-07-16T13:56:47.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennb000hp70v2rc8n6bd","content":"<blockquote>\n<p>现在越来越多的公司都要求开发熟悉Linux环境下开发，常用的Linux版本为Ubuntu，在Ubuntu下开发需要的一些环境和工具是必然要了解的。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/isodesk.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<div class=\"tip\"><br>    距离刚开始入职实习到现在已经一个月，还记得刚领到公司配的电脑，打开发现是Ubuntu，整个人都是懵逼的，之前虽然在虚拟机跑过Ubuntu，但是也还没有完全使用它来开发，所以还是吃惊不小，不过心里也有些激动，毕竟Ubuntu要是用的6也挺装逼的不是吗？后来经过一周的熟悉，也掌握了一些基本的操作，也曾踩过许多坑，所以写下这篇文章来总结一下。<br></div>\n\n\n<h3 id=\"科学上网\"><a href=\"#科学上网\" class=\"headerlink\" title=\"科学上网\"></a>科学上网</h3><p>科学上网应该是每个开发者的必备技能吧，在一台新电脑上，上不了Google简直浑身难受。而且科学上网后上Github的速度都是杠杠的。</p>\n<p>目前所知科学上网的几种姿势里，蓝灯最简单方便，shadowsocks最好用，下面分别讲解下其安装方法：</p>\n<p>PS：Ubuntu下最常用的快捷键是打开终端：Ctrl+Alt+T。<br>Win键：快速打开Dash Home应用搜索。</p>\n<ul>\n<li>Lantern：蓝灯。<br>蓝灯的Github：<a href=\"https://github.com/getlantern/lantern\" target=\"_blank\" rel=\"noopener\">https://github.com/getlantern/lantern</a><br>进去直接下载Ubuntu的deb安装包，下载后双击打开按提示安装即可。<br>安装完成后可以按win键进入Dash Home搜索lantern找到蓝灯，或者在命令行输入lantern即可自动打开浏览器，看下是不是能上谷歌了。</li>\n<li>shadowsocks<br>shadowsocks应该是现在最稳定可靠的科学上网利器了，在Ubuntu下安装和配置我也是捣鼓了好几天。<br>在Ubuntu下使用shadowsocks最好安装其GUI图形客户端——shadowsocks-qt5，这样以后每次操作会很方便。</li>\n</ul>\n<p>shadowsocks-qt5的安装指南：<a href=\"https://github.com/carvenli/shadowsocks-qt5-wiki\" target=\"_blank\" rel=\"noopener\">https://github.com/carvenli/shadowsocks-qt5-wiki</a></p>\n<p><strong>Ubuntu</strong></p>\n<p>通过PPA源安装，仅支持Ubuntu 14.04或更高版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>\n<p>我在安装的时候就出问题了，在运行sudo apt-get update的时候报错hash校验和不符，我百度谷歌试了N种解决方案都没用，甚至重装了一遍系统也一样，最后在同事电脑上安装也不行，后面发现好像是系统问题，于是我在自己的Win10笔记本的虚拟机上试了下，16.06版本的居然可以安装，而公司电脑默认安装的都是Ubuntu14.04的版本的，后来我果断装了Ubuntu16.06才解决这个问题。</p>\n<p>shadowsocks不是像lantern那样安装了就能用的，它需要你有服务器节点，在客户端界面进行相关配置，具体资源需要自己去发掘了，最简便的是导入配置文件就好了，然后连接节点，这时候还不能科学上网，Ubuntu需要配置Sockt5代理，打开设置&gt;网络&gt;代理，选择手动，设置Socket5，地址一般是127.0.0.1，端口为8080。然后确定输入密码就可以尽情上Google了。</p>\n<div class=\"tip\"><br>Ubuntu16.04的软件中心应该是有bug，安装不了第三方.deb文件，我们只有使用dpkg -i 或者gdebi的方式安装，我使用的是后者，因为后者功能更加强大。要使用gdebi命令先要安装它：<br>打开终端并使用下面的命令:<br><br><br> sudo apt-get install gdebi<br><br><br>然后就可以安装.deb文件了。安装过程如下：先切换到你下载的lantern的安装文件目录下，直接使用：<br><br><br> sudo gdebi lantern-installer-beta-64-bit.deb<br><br></div>\n\n\n<h3 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h3><p>Chrome是我钟爱的浏览器，没有之一。新电脑首先安装的软件就是Chrome，安装Chrome直接进入百度搜索Chrome进入官网下载deb包安装即可。</p>\n<h3 id=\"Sublime\"><a href=\"#Sublime\" class=\"headerlink\" title=\"Sublime\"></a>Sublime</h3><p>终于轮到开发工具了，Sublime应该是最轻量级的编辑器了吧，她最大的特点就是秒开，配合其强大的插件库也是如有神助。<br>进入Sublime的官网：<a href=\"http://www.sublimetext.com/，可直接下载其deb安装包。\" target=\"_blank\" rel=\"noopener\">http://www.sublimetext.com/，可直接下载其deb安装包。</a><br>当然，你也可以通过终端，仅需三行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure>\n<p>最后可在Dash Home中见到Sublime-text的软件图标，点击就可使用了.<br>你也可以从命令行启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ subl</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>    在使用Sublime时遇到的问题：首先我们都会去安装自己常用的插件来提高自己的开发效率，在安装packge的时候经常遇到安装失败的问题，因为Sublime Text的很多package repository都在托管在github上，但是github在国内的网络环境下有时……。因此在使用Package Control安装插件时，会出现下面的Prompt：<br>    <img src=\"http://img.yanyuanfe.cn/130046_LhBu_243155.png\" alt=\"image\"><br>    解决方案如下：<br>    1.  命令行输入：<br><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ dig @8.8.8.8 -t A sublime.wbond.net +noall +answer</span><br></pre></td></tr></table></figure><br><br>输出如下：<br><br>  ; &lt;&lt;&gt;&gt; DiG 9.9.5-3-Ubuntu &lt;&lt;&gt;&gt; @8.8.8.8 -t A<br>  sublime.wbond.net +noall +answer<br>  ; (1 server found)<br>  ;; global options: +cmd<br>  sublime.wbond.net.  82  IN  A   50.116.34.243<br>  那么IPv4 地址就是50.116.34.243.<br>  2.  命令行输入<br><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><br><br>打开 /etc/hosts文件，然后用上面的IPV4地址将{}替换掉就OK了。<br>{IPv4 address}    sublime.wbond.net<br><br></div>\n\n\n<h3 id=\"WebStorm\"><a href=\"#WebStorm\" class=\"headerlink\" title=\"WebStorm\"></a>WebStorm</h3><p>WebStorm被成为前端开发神器，我在项目开发的过程中使用的也是这个IDE，值得一提的是它的Git工具，很强大，特别是在处理代码冲突的时候，你会被它折服的。</p>\n<p><strong>安装</strong></p>\n<p>下载：<a href=\"http://www.jetbrains.com/webstorm/\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/webstorm/</a></p>\n<p>解压下载的 gz 包，命令行下运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> bin</span><br><span class=\"line\">$ ./webstorm.sh</span><br></pre></td></tr></table></figure>\n<p>然后就安装成功了，不过 WebStorm 默认情况下是需要收费的，你可以去找找密钥试试。</p>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><p>Node也应该是前端工程化必备的一个工具了。<br>安装Node先安装nvm。<br>nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。<br><strong>安装</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</span><br></pre></td></tr></table></figure></p>\n<p><strong>配置</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">\"<span class=\"variable\">$HOME</span>/.nvm\"</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> ] &amp;&amp; . <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"comment\"># This loads nvm</span></span><br></pre></td></tr></table></figure></p>\n<p>安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm</span><br></pre></td></tr></table></figure>\n<p>当看到有输出时，则 nvm 安装成功。</p>\n<p>使用 nvm 的命令安装 Node.js 最新版：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm install node</span><br></pre></td></tr></table></figure>\n<p>然后在任何新的shell只是使用已安装的版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm use node</span><br></pre></td></tr></table></figure>\n<p>安装特定版本Node：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm run node --version</span><br></pre></td></tr></table></figure>\n<p>安装完成后，查看一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm ls</span><br></pre></td></tr></table></figure>\n<p>这时候可以看到自己安装的所有 Node.js 版本，那个绿色小箭头的意思就是现在正在使用的版本。<br>如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 7.4.0 版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm use 7.4.0</span><br></pre></td></tr></table></figure>\n<p>然后再次查看，这时候小箭头应该出现了。</p>\n<p>OK，我们在终端中输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ node</span><br></pre></td></tr></table></figure>\n<p>REPL(read–eval–print loop) 应该就出来了，那我们就成功了。</p>\n<p>随便敲两行命令玩玩吧。</p>\n<h3 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h3><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。通过使用git工具，我们可以实现团队间合作开发统一管理，可以从远程仓库中提取代码，也可以把代码上传到远程仓库，从而实现代码的同步更新。<br><strong>安装</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>\n<p>配置git用户名和邮箱，之后就可以使用git工具了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name  <span class=\"string\">\"用户名或者用户ID\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.email  <span class=\"string\">\"邮箱\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h3><p>一开始我不知道还有zsh这个东东的，后来看到同事的终端怎么比我的漂亮，就去琢磨了下，原来这就是zsh——传说中的终极Shell。<br>Linux发行版通常默认的Shell就是Bash。也就是你刚开始打开的终端。</p>\n<p>Bash确实是不错的Shell，但仍有用很多不尽人意的地方，如自动补全的功能不够强大，定位较长路径不够方便，命令历史管理不够完善等。</p>\n<p>使用zsh，你会变得很Geek。</p>\n<p>想知道你的系统有几种shell，可以通过以下命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat /etc/shells</span><br></pre></td></tr></table></figure>\n<p><strong>安装zsh</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install zsh</span><br></pre></td></tr></table></figure>\n<p>安装完成后设置当前用户使用 zsh：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>\n<p>根据提示输入当前用户的密码然后<strong>重启</strong>就可以了（一开始安装了没重启就用发现还是Bash还以为安装错了）。</p>\n<p><strong>安装oh my zsh</strong></p>\n<p>因为 zsh 的默认配置及其复杂繁琐,让人望而却步,直到有了oh-my-zsh这个开源项目,让zsh配置降到0门槛.而且它完全兼容 bash .</p>\n<p>地址:<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">https://github.com/robbyrussell/oh-my-zsh</a></p>\n<p>它就是为配置你的 zsh 而生的.</p>\n<p>安装「oh my zsh」可以自动安装也可以手动安装。</p>\n<p>自动安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>\n<p>手动安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>安装 oh-my-zsh 时,它自动读取你的环境变量并且自动帮 zsh 进行设置.</p>\n<h3 id=\"微信\"><a href=\"#微信\" class=\"headerlink\" title=\"微信\"></a>微信</h3><p><strong>Electronic-wechat</strong></p>\n<p><strong>Ubuntu微信客户端下载</strong></p>\n<p>开箱即用的稳定版应用：<br><a href=\"https://github.com/geeeeeeeeek/electronic-wechat/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/geeeeeeeeek/electronic-wechat/releases</a> </p>\n<p><strong>项目地址</strong></p>\n<p><a href=\"https://github.com/geeeeeeeeek/electronic-wechat\" target=\"_blank\" rel=\"noopener\">https://github.com/geeeeeeeeek/electronic-wechat</a></p>\n<p><strong>如何使用</strong></p>\n<p>在下载和运行这个项目之前，你需要在电脑上安装 Git 和 Node.js (来自 npm)。</p>\n<p>在命令行中输入:<br><strong>下载仓库</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/geeeeeeeeek/electronic-wechat.git</span><br></pre></td></tr></table></figure>\n<p><strong>进入仓库</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> electronic-wechat</span><br></pre></td></tr></table></figure>\n<p><strong>安装依赖, 运行应用</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure>\n<p>根据你的平台打包应用:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm run build:osx</span><br><span class=\"line\">$ npm run build:linux</span><br><span class=\"line\">$ npm run build:win</span><br></pre></td></tr></table></figure>\n<p>提示: 如果 npm install 下载缓慢，你可以使用 淘宝镜像(cnpm) 替代 npm 。</p>\n<h3 id=\"Shutter\"><a href=\"#Shutter\" class=\"headerlink\" title=\"Shutter\"></a>Shutter</h3><p><strong>Ubuntu下的截图利器Shutter</strong></p>\n<ol>\n<li>打开Ubuntu软件中心,搜索Shutter并安装</li>\n<li>搜索系统中安装的Shutter并使用</li>\n<li>体验功能齐全的截图工具吧，包括全屏幕截图，区域截图，下拉菜单截图等超多功能 </li>\n</ol>\n<h3 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h3><p>到此为止，介绍了一些Ubuntu下前端开发环境的搭建和常用的工具，后续有好的工具会再次更新的。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>现在越来越多的公司都要求开发熟悉Linux环境下开发，常用的Linux版本为Ubuntu，在Ubuntu下开发需要的一些环境和工具是必然要了解的。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/isodesk.jpg\" alt=\"image\"></p>","more":"<div class=\"tip\"><br>    距离刚开始入职实习到现在已经一个月，还记得刚领到公司配的电脑，打开发现是Ubuntu，整个人都是懵逼的，之前虽然在虚拟机跑过Ubuntu，但是也还没有完全使用它来开发，所以还是吃惊不小，不过心里也有些激动，毕竟Ubuntu要是用的6也挺装逼的不是吗？后来经过一周的熟悉，也掌握了一些基本的操作，也曾踩过许多坑，所以写下这篇文章来总结一下。<br></div>\n\n\n<h3 id=\"科学上网\"><a href=\"#科学上网\" class=\"headerlink\" title=\"科学上网\"></a>科学上网</h3><p>科学上网应该是每个开发者的必备技能吧，在一台新电脑上，上不了Google简直浑身难受。而且科学上网后上Github的速度都是杠杠的。</p>\n<p>目前所知科学上网的几种姿势里，蓝灯最简单方便，shadowsocks最好用，下面分别讲解下其安装方法：</p>\n<p>PS：Ubuntu下最常用的快捷键是打开终端：Ctrl+Alt+T。<br>Win键：快速打开Dash Home应用搜索。</p>\n<ul>\n<li>Lantern：蓝灯。<br>蓝灯的Github：<a href=\"https://github.com/getlantern/lantern\" target=\"_blank\" rel=\"noopener\">https://github.com/getlantern/lantern</a><br>进去直接下载Ubuntu的deb安装包，下载后双击打开按提示安装即可。<br>安装完成后可以按win键进入Dash Home搜索lantern找到蓝灯，或者在命令行输入lantern即可自动打开浏览器，看下是不是能上谷歌了。</li>\n<li>shadowsocks<br>shadowsocks应该是现在最稳定可靠的科学上网利器了，在Ubuntu下安装和配置我也是捣鼓了好几天。<br>在Ubuntu下使用shadowsocks最好安装其GUI图形客户端——shadowsocks-qt5，这样以后每次操作会很方便。</li>\n</ul>\n<p>shadowsocks-qt5的安装指南：<a href=\"https://github.com/carvenli/shadowsocks-qt5-wiki\" target=\"_blank\" rel=\"noopener\">https://github.com/carvenli/shadowsocks-qt5-wiki</a></p>\n<p><strong>Ubuntu</strong></p>\n<p>通过PPA源安装，仅支持Ubuntu 14.04或更高版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>\n<p>我在安装的时候就出问题了，在运行sudo apt-get update的时候报错hash校验和不符，我百度谷歌试了N种解决方案都没用，甚至重装了一遍系统也一样，最后在同事电脑上安装也不行，后面发现好像是系统问题，于是我在自己的Win10笔记本的虚拟机上试了下，16.06版本的居然可以安装，而公司电脑默认安装的都是Ubuntu14.04的版本的，后来我果断装了Ubuntu16.06才解决这个问题。</p>\n<p>shadowsocks不是像lantern那样安装了就能用的，它需要你有服务器节点，在客户端界面进行相关配置，具体资源需要自己去发掘了，最简便的是导入配置文件就好了，然后连接节点，这时候还不能科学上网，Ubuntu需要配置Sockt5代理，打开设置&gt;网络&gt;代理，选择手动，设置Socket5，地址一般是127.0.0.1，端口为8080。然后确定输入密码就可以尽情上Google了。</p>\n<div class=\"tip\"><br>Ubuntu16.04的软件中心应该是有bug，安装不了第三方.deb文件，我们只有使用dpkg -i 或者gdebi的方式安装，我使用的是后者，因为后者功能更加强大。要使用gdebi命令先要安装它：<br>打开终端并使用下面的命令:<br><br><br> sudo apt-get install gdebi<br><br><br>然后就可以安装.deb文件了。安装过程如下：先切换到你下载的lantern的安装文件目录下，直接使用：<br><br><br> sudo gdebi lantern-installer-beta-64-bit.deb<br><br></div>\n\n\n<h3 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h3><p>Chrome是我钟爱的浏览器，没有之一。新电脑首先安装的软件就是Chrome，安装Chrome直接进入百度搜索Chrome进入官网下载deb包安装即可。</p>\n<h3 id=\"Sublime\"><a href=\"#Sublime\" class=\"headerlink\" title=\"Sublime\"></a>Sublime</h3><p>终于轮到开发工具了，Sublime应该是最轻量级的编辑器了吧，她最大的特点就是秒开，配合其强大的插件库也是如有神助。<br>进入Sublime的官网：<a href=\"http://www.sublimetext.com/，可直接下载其deb安装包。\" target=\"_blank\" rel=\"noopener\">http://www.sublimetext.com/，可直接下载其deb安装包。</a><br>当然，你也可以通过终端，仅需三行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure>\n<p>最后可在Dash Home中见到Sublime-text的软件图标，点击就可使用了.<br>你也可以从命令行启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ subl</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>    在使用Sublime时遇到的问题：首先我们都会去安装自己常用的插件来提高自己的开发效率，在安装packge的时候经常遇到安装失败的问题，因为Sublime Text的很多package repository都在托管在github上，但是github在国内的网络环境下有时……。因此在使用Package Control安装插件时，会出现下面的Prompt：<br>    <img src=\"http://img.yanyuanfe.cn/130046_LhBu_243155.png\" alt=\"image\"><br>    解决方案如下：<br>    1.  命令行输入：<br><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ dig @8.8.8.8 -t A sublime.wbond.net +noall +answer</span><br></pre></td></tr></table></figure><br><br>输出如下：<br><br>  ; &lt;&lt;&gt;&gt; DiG 9.9.5-3-Ubuntu &lt;&lt;&gt;&gt; @8.8.8.8 -t A<br>  sublime.wbond.net +noall +answer<br>  ; (1 server found)<br>  ;; global options: +cmd<br>  sublime.wbond.net.  82  IN  A   50.116.34.243<br>  那么IPv4 地址就是50.116.34.243.<br>  2.  命令行输入<br><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><br><br>打开 /etc/hosts文件，然后用上面的IPV4地址将{}替换掉就OK了。<br>{IPv4 address}    sublime.wbond.net<br><br></div>\n\n\n<h3 id=\"WebStorm\"><a href=\"#WebStorm\" class=\"headerlink\" title=\"WebStorm\"></a>WebStorm</h3><p>WebStorm被成为前端开发神器，我在项目开发的过程中使用的也是这个IDE，值得一提的是它的Git工具，很强大，特别是在处理代码冲突的时候，你会被它折服的。</p>\n<p><strong>安装</strong></p>\n<p>下载：<a href=\"http://www.jetbrains.com/webstorm/\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/webstorm/</a></p>\n<p>解压下载的 gz 包，命令行下运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> bin</span><br><span class=\"line\">$ ./webstorm.sh</span><br></pre></td></tr></table></figure>\n<p>然后就安装成功了，不过 WebStorm 默认情况下是需要收费的，你可以去找找密钥试试。</p>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><p>Node也应该是前端工程化必备的一个工具了。<br>安装Node先安装nvm。<br>nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。<br><strong>安装</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</span><br></pre></td></tr></table></figure></p>\n<p><strong>配置</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">\"<span class=\"variable\">$HOME</span>/.nvm\"</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> ] &amp;&amp; . <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"comment\"># This loads nvm</span></span><br></pre></td></tr></table></figure></p>\n<p>安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm</span><br></pre></td></tr></table></figure>\n<p>当看到有输出时，则 nvm 安装成功。</p>\n<p>使用 nvm 的命令安装 Node.js 最新版：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm install node</span><br></pre></td></tr></table></figure>\n<p>然后在任何新的shell只是使用已安装的版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm use node</span><br></pre></td></tr></table></figure>\n<p>安装特定版本Node：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm run node --version</span><br></pre></td></tr></table></figure>\n<p>安装完成后，查看一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm ls</span><br></pre></td></tr></table></figure>\n<p>这时候可以看到自己安装的所有 Node.js 版本，那个绿色小箭头的意思就是现在正在使用的版本。<br>如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 7.4.0 版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm use 7.4.0</span><br></pre></td></tr></table></figure>\n<p>然后再次查看，这时候小箭头应该出现了。</p>\n<p>OK，我们在终端中输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ node</span><br></pre></td></tr></table></figure>\n<p>REPL(read–eval–print loop) 应该就出来了，那我们就成功了。</p>\n<p>随便敲两行命令玩玩吧。</p>\n<h3 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h3><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。通过使用git工具，我们可以实现团队间合作开发统一管理，可以从远程仓库中提取代码，也可以把代码上传到远程仓库，从而实现代码的同步更新。<br><strong>安装</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>\n<p>配置git用户名和邮箱，之后就可以使用git工具了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name  <span class=\"string\">\"用户名或者用户ID\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.email  <span class=\"string\">\"邮箱\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h3><p>一开始我不知道还有zsh这个东东的，后来看到同事的终端怎么比我的漂亮，就去琢磨了下，原来这就是zsh——传说中的终极Shell。<br>Linux发行版通常默认的Shell就是Bash。也就是你刚开始打开的终端。</p>\n<p>Bash确实是不错的Shell，但仍有用很多不尽人意的地方，如自动补全的功能不够强大，定位较长路径不够方便，命令历史管理不够完善等。</p>\n<p>使用zsh，你会变得很Geek。</p>\n<p>想知道你的系统有几种shell，可以通过以下命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat /etc/shells</span><br></pre></td></tr></table></figure>\n<p><strong>安装zsh</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install zsh</span><br></pre></td></tr></table></figure>\n<p>安装完成后设置当前用户使用 zsh：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>\n<p>根据提示输入当前用户的密码然后<strong>重启</strong>就可以了（一开始安装了没重启就用发现还是Bash还以为安装错了）。</p>\n<p><strong>安装oh my zsh</strong></p>\n<p>因为 zsh 的默认配置及其复杂繁琐,让人望而却步,直到有了oh-my-zsh这个开源项目,让zsh配置降到0门槛.而且它完全兼容 bash .</p>\n<p>地址:<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">https://github.com/robbyrussell/oh-my-zsh</a></p>\n<p>它就是为配置你的 zsh 而生的.</p>\n<p>安装「oh my zsh」可以自动安装也可以手动安装。</p>\n<p>自动安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>\n<p>手动安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>安装 oh-my-zsh 时,它自动读取你的环境变量并且自动帮 zsh 进行设置.</p>\n<h3 id=\"微信\"><a href=\"#微信\" class=\"headerlink\" title=\"微信\"></a>微信</h3><p><strong>Electronic-wechat</strong></p>\n<p><strong>Ubuntu微信客户端下载</strong></p>\n<p>开箱即用的稳定版应用：<br><a href=\"https://github.com/geeeeeeeeek/electronic-wechat/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/geeeeeeeeek/electronic-wechat/releases</a> </p>\n<p><strong>项目地址</strong></p>\n<p><a href=\"https://github.com/geeeeeeeeek/electronic-wechat\" target=\"_blank\" rel=\"noopener\">https://github.com/geeeeeeeeek/electronic-wechat</a></p>\n<p><strong>如何使用</strong></p>\n<p>在下载和运行这个项目之前，你需要在电脑上安装 Git 和 Node.js (来自 npm)。</p>\n<p>在命令行中输入:<br><strong>下载仓库</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/geeeeeeeeek/electronic-wechat.git</span><br></pre></td></tr></table></figure>\n<p><strong>进入仓库</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> electronic-wechat</span><br></pre></td></tr></table></figure>\n<p><strong>安装依赖, 运行应用</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure>\n<p>根据你的平台打包应用:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm run build:osx</span><br><span class=\"line\">$ npm run build:linux</span><br><span class=\"line\">$ npm run build:win</span><br></pre></td></tr></table></figure>\n<p>提示: 如果 npm install 下载缓慢，你可以使用 淘宝镜像(cnpm) 替代 npm 。</p>\n<h3 id=\"Shutter\"><a href=\"#Shutter\" class=\"headerlink\" title=\"Shutter\"></a>Shutter</h3><p><strong>Ubuntu下的截图利器Shutter</strong></p>\n<ol>\n<li>打开Ubuntu软件中心,搜索Shutter并安装</li>\n<li>搜索系统中安装的Shutter并使用</li>\n<li>体验功能齐全的截图工具吧，包括全屏幕截图，区域截图，下拉菜单截图等超多功能 </li>\n</ol>\n<h3 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h3><p>到此为止，介绍了一些Ubuntu下前端开发环境的搭建和常用的工具，后续有好的工具会再次更新的。</p>"},{"title":"Hello World","date":"2016-07-01T09:21:08.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n<!--more-->\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-07-1 17:21:08\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n<!--more-->\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2020-07-16T13:56:47.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennc000ip70vmx6hbocx","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>","more":"<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"Webpack之构建速度优化","date":"2018-10-29T13:33:46.000Z","banner":"http://img.yanyuanfe.cn/webpack.png","_content":"> 本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack构建速度的方法。\n\n![image](http://img.yanyuanfe.cn/webpack.png)\n\n<!--more-->\n\nWebpack是当前最流行的打包工具，当前的最新版本是Webpack4+，性能有了很大的提升，本文是我在使用过程中的一些总结，主要是提高Webpack的构建性能。\n\n### 保持版本更新\n使用最新的 webpack 版本。新版本一般会进行性能优化。\n\n保持最新的 Node.js 版本也能够提升性能。除此之外，保证你的包管理工具 (例如 npm 或者 yarn ) 为最新也能提升性能。较新的版本能够建立更高效的模块依赖树以及提高解析速度。\n\n### 在Loader中使用include或者exclude\n配置loader的时候，使用include，可以更精确指定要处理的目录，可以减少不必要的遍历，从而减少性能损失。同样，对于已经明确知道的，不需要处理的目录，则应该予以排除，从而进一步提升性能。故而，合理的设置include和exclude，将会极大地提升Webpack 打包优化速度。\n\n``` js\nmodule.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        include: path.resolve(__dirname, 'src'),\n        loader: 'babel-loader'\n      }\n    ]\n  }\n};\n```\n\n### 提高解析速度 \n以下几步可以提高解析速度:\n\n- 尽量减少 resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中类目的数量，因为他们会增加文件系统调用的次数。\n- 如果你不使用 symlinks ，可以设置 resolve.symlinks: false (例如 npm link 或者 yarn link).\n- 如果你使用自定义解析 plugins ，并且没有指定 context 信息，可以设置 resolve.cacheWithContext: false 。\n\n### module.noParse\n防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的类库 可以提高构建性能。\n\n``` js\nmodule.exports = {\n  //...\n  module: {\n    noParse: /jquery|lodash/,\n\n    // 从 webpack 3.0.0 开始\n    noParse: function(content) {\n      return /jquery|lodash/.test(content);\n    }\n  }\n};\n```\n\n\n### babel-loader\nbabel-loader构建很慢，不仅要使用exclude、include，尽可能准确的指定要编译内容的目录，而且要充分利用缓存，进一步提升性能。babel-loader 提供了 cacheDirectory特定选项（默认 false），当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。\n\n通过使用 cacheDirectory 选项，将 babel-loader 提速至少两倍。 这会将转译的结果缓存到文件系统中。\n\nbabel 在每个文件都插入了辅助代码，使代码体积过大！ \nbabel 对一些公共方法使用了非常小的辅助代码，比如 _extend。 默认情况下会被添加到每一个需要它的文件中\n\n你可以引入 babel runtime 作为一个独立模块，来避免重复引入。\n\n下面的配置禁用了 babel 自动对每个文件的 runtime 注入，而是引入 babel-plugin-transform-runtime 并且使所有辅助代码从这里引用。\n\n\n``` js\nrules: [\n  // 'transform-runtime' 插件告诉 babel 要引用 runtime 来代替注入。\n  {\n    test: /\\.js$/,\n    exclude: /(node_modules|bower_components)/,\n    use: {\n      loader: 'babel-loader',\n      options: {\n        presets: ['@babel/preset-env'],\n        plugins: ['@babel/transform-runtime']\n      }\n    }\n  }\n]\n```\n### Dlls\n\n使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。\n\n### Happypack多进程构建\n\n由于Node.js的单进程限制，所有的loader虽然以async的形式来并发调用，但是还是运行在单个node的进程，以及在同一个事件循环中，这就直接导致了些问题：当同时读取多个loader文件资源时，比如babel-loader需要transform各种jsx，es6的资源文件。在这种CPU密集型的场景下，Node的单进程模型就没有优势了，而Happypack就是为解决此类问题而生。\n\nHappypack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建；原本的流程保持不变，这样可以在不修改原有配置的基础上，来完成对编译过程的优化，具体配置如下：\n\n\n``` js\n// webpack.config.js\nconst HappyPack = require('happypack');\nconst happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });\n\nexports.module = {\n  rules: [\n    {\n      test: /.js$/,\n      include: [resolve('src')],\n      exclude: /node_modules/,\n      loader: 'happypack/loader?id=happybabel'\n    }\n  ]\n};\n\nexports.plugins = [\n  new HappyPack({\n    id: 'happybabel',\n    loaders: ['babel-loader'],\n    threadPool: happyThreadPool,\n    cache: true,\n    verbose: true\n  })\n];\n```\nHappypack 在编译过程中，除了利用多进程的模式加速编译，还同时开启了 cache 计算，能充分利用缓存读取构建文件，对构建的速度提升也是非常明显的\n\n\n","source":"_posts/Webpack之构建速度优化.md","raw":"---\ntitle: Webpack之构建速度优化\ndate: 2018-10-29 21:33:46\nbanner: http://img.yanyuanfe.cn/webpack.png\ntags:\n- Webpack\n---\n> 本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack构建速度的方法。\n\n![image](http://img.yanyuanfe.cn/webpack.png)\n\n<!--more-->\n\nWebpack是当前最流行的打包工具，当前的最新版本是Webpack4+，性能有了很大的提升，本文是我在使用过程中的一些总结，主要是提高Webpack的构建性能。\n\n### 保持版本更新\n使用最新的 webpack 版本。新版本一般会进行性能优化。\n\n保持最新的 Node.js 版本也能够提升性能。除此之外，保证你的包管理工具 (例如 npm 或者 yarn ) 为最新也能提升性能。较新的版本能够建立更高效的模块依赖树以及提高解析速度。\n\n### 在Loader中使用include或者exclude\n配置loader的时候，使用include，可以更精确指定要处理的目录，可以减少不必要的遍历，从而减少性能损失。同样，对于已经明确知道的，不需要处理的目录，则应该予以排除，从而进一步提升性能。故而，合理的设置include和exclude，将会极大地提升Webpack 打包优化速度。\n\n``` js\nmodule.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        include: path.resolve(__dirname, 'src'),\n        loader: 'babel-loader'\n      }\n    ]\n  }\n};\n```\n\n### 提高解析速度 \n以下几步可以提高解析速度:\n\n- 尽量减少 resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中类目的数量，因为他们会增加文件系统调用的次数。\n- 如果你不使用 symlinks ，可以设置 resolve.symlinks: false (例如 npm link 或者 yarn link).\n- 如果你使用自定义解析 plugins ，并且没有指定 context 信息，可以设置 resolve.cacheWithContext: false 。\n\n### module.noParse\n防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的类库 可以提高构建性能。\n\n``` js\nmodule.exports = {\n  //...\n  module: {\n    noParse: /jquery|lodash/,\n\n    // 从 webpack 3.0.0 开始\n    noParse: function(content) {\n      return /jquery|lodash/.test(content);\n    }\n  }\n};\n```\n\n\n### babel-loader\nbabel-loader构建很慢，不仅要使用exclude、include，尽可能准确的指定要编译内容的目录，而且要充分利用缓存，进一步提升性能。babel-loader 提供了 cacheDirectory特定选项（默认 false），当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。\n\n通过使用 cacheDirectory 选项，将 babel-loader 提速至少两倍。 这会将转译的结果缓存到文件系统中。\n\nbabel 在每个文件都插入了辅助代码，使代码体积过大！ \nbabel 对一些公共方法使用了非常小的辅助代码，比如 _extend。 默认情况下会被添加到每一个需要它的文件中\n\n你可以引入 babel runtime 作为一个独立模块，来避免重复引入。\n\n下面的配置禁用了 babel 自动对每个文件的 runtime 注入，而是引入 babel-plugin-transform-runtime 并且使所有辅助代码从这里引用。\n\n\n``` js\nrules: [\n  // 'transform-runtime' 插件告诉 babel 要引用 runtime 来代替注入。\n  {\n    test: /\\.js$/,\n    exclude: /(node_modules|bower_components)/,\n    use: {\n      loader: 'babel-loader',\n      options: {\n        presets: ['@babel/preset-env'],\n        plugins: ['@babel/transform-runtime']\n      }\n    }\n  }\n]\n```\n### Dlls\n\n使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。\n\n### Happypack多进程构建\n\n由于Node.js的单进程限制，所有的loader虽然以async的形式来并发调用，但是还是运行在单个node的进程，以及在同一个事件循环中，这就直接导致了些问题：当同时读取多个loader文件资源时，比如babel-loader需要transform各种jsx，es6的资源文件。在这种CPU密集型的场景下，Node的单进程模型就没有优势了，而Happypack就是为解决此类问题而生。\n\nHappypack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建；原本的流程保持不变，这样可以在不修改原有配置的基础上，来完成对编译过程的优化，具体配置如下：\n\n\n``` js\n// webpack.config.js\nconst HappyPack = require('happypack');\nconst happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });\n\nexports.module = {\n  rules: [\n    {\n      test: /.js$/,\n      include: [resolve('src')],\n      exclude: /node_modules/,\n      loader: 'happypack/loader?id=happybabel'\n    }\n  ]\n};\n\nexports.plugins = [\n  new HappyPack({\n    id: 'happybabel',\n    loaders: ['babel-loader'],\n    threadPool: happyThreadPool,\n    cache: true,\n    verbose: true\n  })\n];\n```\nHappypack 在编译过程中，除了利用多进程的模式加速编译，还同时开启了 cache 计算，能充分利用缓存读取构建文件，对构建的速度提升也是非常明显的\n\n\n","slug":"Webpack之构建速度优化","published":1,"updated":"2020-07-16T13:56:47.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennf000lp70vqomkjlx5","content":"<blockquote>\n<p>本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack构建速度的方法。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/webpack.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>Webpack是当前最流行的打包工具，当前的最新版本是Webpack4+，性能有了很大的提升，本文是我在使用过程中的一些总结，主要是提高Webpack的构建性能。</p>\n<h3 id=\"保持版本更新\"><a href=\"#保持版本更新\" class=\"headerlink\" title=\"保持版本更新\"></a>保持版本更新</h3><p>使用最新的 webpack 版本。新版本一般会进行性能优化。</p>\n<p>保持最新的 Node.js 版本也能够提升性能。除此之外，保证你的包管理工具 (例如 npm 或者 yarn ) 为最新也能提升性能。较新的版本能够建立更高效的模块依赖树以及提高解析速度。</p>\n<h3 id=\"在Loader中使用include或者exclude\"><a href=\"#在Loader中使用include或者exclude\" class=\"headerlink\" title=\"在Loader中使用include或者exclude\"></a>在Loader中使用include或者exclude</h3><p>配置loader的时候，使用include，可以更精确指定要处理的目录，可以减少不必要的遍历，从而减少性能损失。同样，对于已经明确知道的，不需要处理的目录，则应该予以排除，从而进一步提升性能。故而，合理的设置include和exclude，将会极大地提升Webpack 打包优化速度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        include: path.resolve(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"提高解析速度\"><a href=\"#提高解析速度\" class=\"headerlink\" title=\"提高解析速度\"></a>提高解析速度</h3><p>以下几步可以提高解析速度:</p>\n<ul>\n<li>尽量减少 resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中类目的数量，因为他们会增加文件系统调用的次数。</li>\n<li>如果你不使用 symlinks ，可以设置 resolve.symlinks: false (例如 npm link 或者 yarn link).</li>\n<li>如果你使用自定义解析 plugins ，并且没有指定 context 信息，可以设置 resolve.cacheWithContext: false 。</li>\n</ul>\n<h3 id=\"module-noParse\"><a href=\"#module-noParse\" class=\"headerlink\" title=\"module.noParse\"></a>module.noParse</h3><p>防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的类库 可以提高构建性能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    noParse: <span class=\"regexp\">/jquery|lodash/</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 webpack 3.0.0 开始</span></span><br><span class=\"line\">    noParse: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"regexp\">/jquery|lodash/</span>.test(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"babel-loader\"><a href=\"#babel-loader\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h3><p>babel-loader构建很慢，不仅要使用exclude、include，尽可能准确的指定要编译内容的目录，而且要充分利用缓存，进一步提升性能。babel-loader 提供了 cacheDirectory特定选项（默认 false），当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。</p>\n<p>通过使用 cacheDirectory 选项，将 babel-loader 提速至少两倍。 这会将转译的结果缓存到文件系统中。</p>\n<p>babel 在每个文件都插入了辅助代码，使代码体积过大！<br>babel 对一些公共方法使用了非常小的辅助代码，比如 _extend。 默认情况下会被添加到每一个需要它的文件中</p>\n<p>你可以引入 babel runtime 作为一个独立模块，来避免重复引入。</p>\n<p>下面的配置禁用了 babel 自动对每个文件的 runtime 注入，而是引入 babel-plugin-transform-runtime 并且使所有辅助代码从这里引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  <span class=\"comment\">// 'transform-runtime' 插件告诉 babel 要引用 runtime 来代替注入。</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/(node_modules|bower_components)/</span>,</span><br><span class=\"line\">    use: &#123;</span><br><span class=\"line\">      loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">      options: &#123;</span><br><span class=\"line\">        presets: [<span class=\"string\">'@babel/preset-env'</span>],</span><br><span class=\"line\">        plugins: [<span class=\"string\">'@babel/transform-runtime'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"Dlls\"><a href=\"#Dlls\" class=\"headerlink\" title=\"Dlls\"></a>Dlls</h3><p>使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。</p>\n<h3 id=\"Happypack多进程构建\"><a href=\"#Happypack多进程构建\" class=\"headerlink\" title=\"Happypack多进程构建\"></a>Happypack多进程构建</h3><p>由于Node.js的单进程限制，所有的loader虽然以async的形式来并发调用，但是还是运行在单个node的进程，以及在同一个事件循环中，这就直接导致了些问题：当同时读取多个loader文件资源时，比如babel-loader需要transform各种jsx，es6的资源文件。在这种CPU密集型的场景下，Node的单进程模型就没有优势了，而Happypack就是为解决此类问题而生。</p>\n<p>Happypack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建；原本的流程保持不变，这样可以在不修改原有配置的基础上，来完成对编译过程的优化，具体配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> HappyPack = <span class=\"built_in\">require</span>(<span class=\"string\">'happypack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> happyThreadPool = HappyPack.ThreadPool(&#123; <span class=\"attr\">size</span>: os.cpus().length &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">exports.module = &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/.js$/</span>,</span><br><span class=\"line\">      include: [resolve(<span class=\"string\">'src'</span>)],</span><br><span class=\"line\">      exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">      loader: <span class=\"string\">'happypack/loader?id=happybabel'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.plugins = [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> HappyPack(&#123;</span><br><span class=\"line\">    id: <span class=\"string\">'happybabel'</span>,</span><br><span class=\"line\">    loaders: [<span class=\"string\">'babel-loader'</span>],</span><br><span class=\"line\">    threadPool: happyThreadPool,</span><br><span class=\"line\">    cache: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    verbose: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>Happypack 在编译过程中，除了利用多进程的模式加速编译，还同时开启了 cache 计算，能充分利用缓存读取构建文件，对构建的速度提升也是非常明显的</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文是我在使用Webpack4过程中的一些总结，介绍一些优化Webpack构建速度的方法。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/webpack.png\" alt=\"image\"></p>","more":"<p>Webpack是当前最流行的打包工具，当前的最新版本是Webpack4+，性能有了很大的提升，本文是我在使用过程中的一些总结，主要是提高Webpack的构建性能。</p>\n<h3 id=\"保持版本更新\"><a href=\"#保持版本更新\" class=\"headerlink\" title=\"保持版本更新\"></a>保持版本更新</h3><p>使用最新的 webpack 版本。新版本一般会进行性能优化。</p>\n<p>保持最新的 Node.js 版本也能够提升性能。除此之外，保证你的包管理工具 (例如 npm 或者 yarn ) 为最新也能提升性能。较新的版本能够建立更高效的模块依赖树以及提高解析速度。</p>\n<h3 id=\"在Loader中使用include或者exclude\"><a href=\"#在Loader中使用include或者exclude\" class=\"headerlink\" title=\"在Loader中使用include或者exclude\"></a>在Loader中使用include或者exclude</h3><p>配置loader的时候，使用include，可以更精确指定要处理的目录，可以减少不必要的遍历，从而减少性能损失。同样，对于已经明确知道的，不需要处理的目录，则应该予以排除，从而进一步提升性能。故而，合理的设置include和exclude，将会极大地提升Webpack 打包优化速度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        include: path.resolve(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"提高解析速度\"><a href=\"#提高解析速度\" class=\"headerlink\" title=\"提高解析速度\"></a>提高解析速度</h3><p>以下几步可以提高解析速度:</p>\n<ul>\n<li>尽量减少 resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中类目的数量，因为他们会增加文件系统调用的次数。</li>\n<li>如果你不使用 symlinks ，可以设置 resolve.symlinks: false (例如 npm link 或者 yarn link).</li>\n<li>如果你使用自定义解析 plugins ，并且没有指定 context 信息，可以设置 resolve.cacheWithContext: false 。</li>\n</ul>\n<h3 id=\"module-noParse\"><a href=\"#module-noParse\" class=\"headerlink\" title=\"module.noParse\"></a>module.noParse</h3><p>防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的类库 可以提高构建性能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    noParse: <span class=\"regexp\">/jquery|lodash/</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 webpack 3.0.0 开始</span></span><br><span class=\"line\">    noParse: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"regexp\">/jquery|lodash/</span>.test(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"babel-loader\"><a href=\"#babel-loader\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h3><p>babel-loader构建很慢，不仅要使用exclude、include，尽可能准确的指定要编译内容的目录，而且要充分利用缓存，进一步提升性能。babel-loader 提供了 cacheDirectory特定选项（默认 false），当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。</p>\n<p>通过使用 cacheDirectory 选项，将 babel-loader 提速至少两倍。 这会将转译的结果缓存到文件系统中。</p>\n<p>babel 在每个文件都插入了辅助代码，使代码体积过大！<br>babel 对一些公共方法使用了非常小的辅助代码，比如 _extend。 默认情况下会被添加到每一个需要它的文件中</p>\n<p>你可以引入 babel runtime 作为一个独立模块，来避免重复引入。</p>\n<p>下面的配置禁用了 babel 自动对每个文件的 runtime 注入，而是引入 babel-plugin-transform-runtime 并且使所有辅助代码从这里引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  <span class=\"comment\">// 'transform-runtime' 插件告诉 babel 要引用 runtime 来代替注入。</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/(node_modules|bower_components)/</span>,</span><br><span class=\"line\">    use: &#123;</span><br><span class=\"line\">      loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">      options: &#123;</span><br><span class=\"line\">        presets: [<span class=\"string\">'@babel/preset-env'</span>],</span><br><span class=\"line\">        plugins: [<span class=\"string\">'@babel/transform-runtime'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"Dlls\"><a href=\"#Dlls\" class=\"headerlink\" title=\"Dlls\"></a>Dlls</h3><p>使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。</p>\n<h3 id=\"Happypack多进程构建\"><a href=\"#Happypack多进程构建\" class=\"headerlink\" title=\"Happypack多进程构建\"></a>Happypack多进程构建</h3><p>由于Node.js的单进程限制，所有的loader虽然以async的形式来并发调用，但是还是运行在单个node的进程，以及在同一个事件循环中，这就直接导致了些问题：当同时读取多个loader文件资源时，比如babel-loader需要transform各种jsx，es6的资源文件。在这种CPU密集型的场景下，Node的单进程模型就没有优势了，而Happypack就是为解决此类问题而生。</p>\n<p>Happypack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建；原本的流程保持不变，这样可以在不修改原有配置的基础上，来完成对编译过程的优化，具体配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> HappyPack = <span class=\"built_in\">require</span>(<span class=\"string\">'happypack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> happyThreadPool = HappyPack.ThreadPool(&#123; <span class=\"attr\">size</span>: os.cpus().length &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">exports.module = &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/.js$/</span>,</span><br><span class=\"line\">      include: [resolve(<span class=\"string\">'src'</span>)],</span><br><span class=\"line\">      exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">      loader: <span class=\"string\">'happypack/loader?id=happybabel'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.plugins = [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> HappyPack(&#123;</span><br><span class=\"line\">    id: <span class=\"string\">'happybabel'</span>,</span><br><span class=\"line\">    loaders: [<span class=\"string\">'babel-loader'</span>],</span><br><span class=\"line\">    threadPool: happyThreadPool,</span><br><span class=\"line\">    cache: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    verbose: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>Happypack 在编译过程中，除了利用多进程的模式加速编译，还同时开启了 cache 计算，能充分利用缓存读取构建文件，对构建的速度提升也是非常明显的</p>"},{"title":"react-redux开发简单的To do应用","date":"2018-02-23T08:44:49.000Z","banner":"http://img.yanyuanfe.cn/photo-1454165804606-c3d57bc86b40%20%281%29.jpeg","_content":"\n> redux专注于状态管理，和react解耦，为了方便使用，redux的作者封装了一个react专用的库react-redux。\n\n![image](http://img.yanyuanfe.cn/bg2016092101.jpg)\n\n<!--more-->\n\n前面通过一个简单的计数器应用来学习redux的基本原理和用法，在本篇文章，将介绍redux如何与react结合使用。\n为了方便使用，redux的作者封装了一个react专用的库react-redux，这也是接下来的重点。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-2\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 安装\n\n\n``` bash\nnpm install react-redux --save\n```\n\n\n### 基本API\n\n#### <Provider/>组件\nreact-redux提供Provider组件，包裹在根组件最外层，用于传递store到组件内部，让应用内部的任何子孙组件非常方便地获取到全局状态，核心原理是react提供的context API。\n示例代码如下：\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport { createStore } from 'redux';\nimport reducer from './reducers';\n\nconst store = createStore(reducer);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n#### connect()\nreact-redux提供connect方法用于将react组件与redux的store进行连接,通过connect方法，可以在任何react组件中，将store中的全局state和Action Creator传递到组件的props中，以供组件使用。\n\nconnect方法接受两个参数，**mapStateToProps**和**mapDispatchToProps**，用于定义组件的输入输出。mapStateToProps负责输入逻辑，将state映射到组件的props，后者负责输出逻辑，将Action Creator方法传递到组件的props中，在组件内即可发起Action。\n示例代码如下：\n\n``` js\nimport { connect } from 'react-redux';\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link);\n\nexport default FilterLink;\n```\n\n\n#### mapStateToProps\nmapStateToProps是一个函数，接受两个参数，state和props，state包含整个全局对象树，props代表组件的props，一般情况下使用state情况最多。执行后返回一个对象，对象的键值对就是一个映射。\n示例代码如下：\n\n\n``` js\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n```\n\n\n上述代码中，在mapStateToProps中，通过全局state和组件的props进行计算，得到包含键active的对象，传入组件，在组件中即可通过this.props.active来获取值。\n\n#### mapDispatchToProps\n\nmapDispatch是一个函数或者对象，用于将store.dispatch映射到组件的props。当mapDiapatchToProps是一个函数时，传入dispatch和ownProps两个参数，返回一个对象，对象的键值对定义了组件的props传递的方法以及对应的action。\n示例代码如下：\n\n\n``` js\nconst mapDispatchToProps = (\n  dispatch,\n  ownProps\n) => {\n  return {\n    onClick: () => {\n      dispatch({\n        type: 'SET_VISIBILITY_FILTER',\n        filter: ownProps.filter\n      });\n    }\n  };\n}\n```\n\n上述代码将dispatch方法映射到组件的props参数onClick，在组件内部即可通过this.props.onClick（）进行调用。\n\n当mapDispatch是一个对象时，它的键值对分别是组件的props参数和一个作为Action Creator的函数，通常在大型应用中，会在专门的文件中定义actionCreators文件，如下：\n\n\n``` js\nexport const setVisibilityFilter = (filter) => ({\n  type: 'SET_VISIBILITY_FILTER',\n  filter\n})\n```\n\n上述代码就是一系列actionCreator之一，返回一个Action，由Redux自动发出，上述代码使用如下：\n\n``` js\nimport { setVisibilityFilter } from '../actions';\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n```\n\n这种方法跟写成函数的方法其实是一样的，只是将action进行了单独的抽离，这样可以避免更多的冗余代码，如需要在多个组件中发起相同的action时。\n\n### 实战To do应用\n前面已经了解了react-redux的核心API，下面来完成一个完整的应用。\n\n整个应用实现的界面如下：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_183.png)\n\n功能主要有，输入文字添加todo事项，显示todo list，点击todo项切换状态，点击tab筛选不同的todo 状态。\n\n在应用开发过程中，使用components，首先，使用create-react-app来初始化react应用，src为主要的开发目录，src目录下，分别新建actions、components、containers、reducers文件夹，actions用于编写actionCreator，reducers文件夹下用于编写应用的reducer，component文件夹下编写UI组件，即无状态组件，只负责UI的呈现，不负责业务逻辑，数据通过props传入，也不操作redux相关的api。containers文件夹下编写容器组件，负责管理数据和业务逻辑，操作redux的api。\n\n首先，在**App.js**中，包含了整个应用的UI界面。\n\n``` js\nimport React, { Component } from 'react';\nimport Footer from './components/Footer';\nimport AddTodo from './containers/AddTodo';\nimport VisibleTodoList from './containers/VisibleTodoList';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n\n    return (\n      <div className=\"App\">\n        <div className=\"todoapp\">\n          <AddTodo/>\n          <VisibleTodoList/>\n          <Footer/>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n\n可以看到，整个应用包含三个组件**AddTodo**、**VisibleTodoList**、**Footer**。\n\n下面逐步介绍整个界面的实现。\n从containers文件夹开始，首先是AddTodo组件，用于添加todo。\n\n``` js\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { addTodo } from '../actions'\n\nlet AddTodo = ({ dispatch }) => {\n  let input\n\n  return (\n    <div>\n      <form onSubmit={e => {\n        e.preventDefault()\n        if (!input.value.trim()) {\n          return\n        }\n        dispatch(addTodo(input.value))\n        input.value = ''\n      }}>\n        <input ref={node => {\n          input = node\n        }} />\n        <button type=\"submit\">\n          Add Todo\n        </button>\n      </form>\n    </div>\n  )\n}\nAddTodo = connect()(AddTodo)\n\nexport default AddTodo\n```\n\n\nAddTodo包含一个Form表单，在Form表单的onSubmit事件中，获取输入值，提交至action，整个组件被redux的connect组件包裹，从而使得dispatch传入到组件的props中。\n\n下面是actions的addTodo方法。\n\n``` js\nlet nextTodoId = 0\nexport const addTodo = (text) => ({\n  type: 'ADD_TODO',\n  id: nextTodoId++,\n  text\n})\n```\n\naddTodo用于新建Todo，将todo的id加1,传入todo的text属性。\n\n下面是VisibleTodoList组件，根据当前选中的tab来显示不同状态下的todo list。\n\n``` js\nimport { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\n\nconst getVisibleTodos = (todos, filter) => {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos\n    case 'SHOW_COMPLETED':\n      return todos.filter(t => t.completed)\n    case 'SHOW_ACTIVE':\n      return todos.filter(t => !t.completed)\n    default:\n      throw new Error('Unknown filter: ' + filter)\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  todos: getVisibleTodos(state.todos, state.visibilityFilter)\n})\n\nconst mapDispatchToProps = {\n  onTodoClick: toggleTodo\n}\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n```\n\n\n从代码中可以看到，VisibleTodoList没有界面相关的部分，仅仅是将TodoList组件进行包裹返回一个新的组件。mapStateToProps中，根据当前所有的todos和筛选条件visibilityFilter，通过getVisibleTodos函数，返回一个筛选后的todos，mapDispatchToProps则是将actionCreator方法通过props传入到UI组件。\n\n\n在actions文件夹下，index.js中，定义了toggleTodo如下：\n\n\n``` js\nexport const toggleTodo = (id) => ({\n  type: 'TOGGLE_TODO',\n  id\n})\n```\n\n\ntoggleTodo通过传入的id对当前操作的todo进行处理。\n\n\n下面是components下的TodoList组件，负责显示todo list。\n\n\n``` js\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport Todo from './Todo'\n\nconst TodoList = ({ todos, onTodoClick }) => (\n  <ul>\n    {todos.map(todo =>\n      <Todo\n        key={todo.id}\n        {...todo}\n        onClick={() => onTodoClick(todo.id)}\n      />\n    )}\n  </ul>\n)\n\nTodoList.propTypes = {\n  todos: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired).isRequired,\n  onTodoClick: PropTypes.func.isRequired\n}\n\nexport default TodoList\n```\n\n\n从上述代码可以看到，TodoList接收props中的todos, onTodoClick，并对todos进行渲染，每个todo又抽离成单独的Todo组件，在每个Todo上传递点击事件，点击事件中，调用onTodoClick，并传入当前todo的id，以此来改变todo的状态。\n\nTodo组件如下所示：\n\n``` js\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\nconst Todo = ({ onClick, completed, text }) => (\n  <li\n    onClick={onClick}\n    style={{\n      textDecoration: completed ? 'line-through' : 'none'\n    }}\n  >\n    {text}\n  </li>\n)\n\nTodo.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  completed: PropTypes.bool.isRequired,\n  text: PropTypes.string.isRequired\n}\n\nexport default Todo\n```\n\n在TodoList组件中，渲染所有的todo list时，将每个todo进行对象解构，传入Todo组件的props，在Todo组件中，获取到组件需要的参数onClick, completed, text，onClick用于绑定到todo的点击事件，completed用于表示todo的状态是否为完成，根据completed的值来渲染todo的样式，text渲染为todo的内容。\n下面是components中的Footer组件：\n\n``` js\nimport React from 'react'\nimport FilterLink from '../containers/FilterLink'\n\nconst Footer = () => (\n  <p>\n    Show:\n    {\" \"}\n    <FilterLink filter=\"SHOW_ALL\">\n      All\n    </FilterLink>\n    {\", \"}\n    <FilterLink filter=\"SHOW_ACTIVE\">\n      Active\n    </FilterLink>\n    {\", \"}\n    <FilterLink filter=\"SHOW_COMPLETED\">\n      Completed\n    </FilterLink>\n  </p>\n)\n\nexport default Footer\n```\n\nFooter组件中，用于对todos的状态进行筛选，共包含三个筛选项，SHOW_ALL显示所有todos，SHOW_ACTIVE显示刚添加的todo，SHOW_COMPLETED显示已经完成的todo。每个筛选项又抽离成FilterLink组件，传入filter作为筛选参数。\n\n下面是container中FilterLink的代码。\n\n\n``` js\nimport { connect } from 'react-redux'\nimport { setVisibilityFilter } from '../actions'\nimport Link from '../components/Link'\n\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link)\n\nexport default FilterLink\n```\n\n\nFilterLink组件也仅仅是负责数据的逻辑，没有UI呈现。mapStateToProps中判断当前组件的props.filter与筛选条件state.visibilityFilter来计算active属性传入props，mapDispatchToProps定义onClick方法，用于dispatch一个action来改变当前的筛选条件，即state.visibilityFilter，传入当前组件的filter属性作为参数。\n\nactions的setVisibilityFilter代码如下：\n\n``` js\nexport const setVisibilityFilter = (filter) => ({\n  type: 'SET_VISIBILITY_FILTER',\n  filter\n})\n```\n\n\n下面是Link组件。\n\n\n``` js\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\nconst Link = ({ active, children, onClick }) => {\n  if (active) {\n    return <span>{children}</span>\n  }\n\n  return (\n    // eslint-disable-next-line\n    <a href=\"#\"\n       onClick={e => {\n         e.preventDefault()\n         onClick()\n       }}\n    >\n      {children}\n    </a>\n  )\n}\n\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\n```\n\n\nLink组件通过props接收active，children，onClick属性值，当active为true时，Link渲染为span，否则渲染为a，a标签绑定点击事件，点击时，触发props中的onClick方法。\n\n自此，界面部分的代码都已经介绍完毕，下面是reducer的编写。\n在reducer的编写中，为了让reducer的职责更为清晰，将reducer拆分为todos和visibilityFilter，todos.js中，用于处理todo的添加，状态改变。代码如下：\n\n``` js\nconst todos = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ]\n    case 'TOGGLE_TODO':\n      return state.map(todo =>\n        (todo.id === action.id)\n          ? {...todo, completed: !todo.completed}\n          : todo\n      )\n    default:\n      return state\n  }\n}\n\nexport default todos\n```\n\n\n此处，todos初始化为一个空数组，reducer必须为纯函数，处理actions，不能直接对state进行修改，应该每次都返回一个新的state，当添加Todo时，使用数组展开运算符对state进行解构，并且，将新的todo对象作为数组的最后一个值，最终，生成一个全新的state。当修改todo状态时，使用数组的map方法，同样返回一个新的state，在map方法内部，使用三元运算符对action参数id和数组每一项的id进行判断，目的是寻找到当前被点击时的todo，将其completed值取反，否则直接返回当前todo。\n\nvisibilityFilter.js中，主要是用于更改todo list的筛选条件，代码如下：\n\n\n``` js\nconst visibilityFilter = (state = 'SHOW_ALL', action) => {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter\n    default:\n      return state\n  }\n}\n\nexport default visibilityFilter\n\n```\n\n此时，state初始化为SHOW_ALL，即应用加载时，默认显示为全部的todos，当处理actions，直接返回action.filter。\n\n当reducer被拆分为单个文件时，上述const 命名的函数名即为全局状态树中的state值，还需要将拆分的reducer进行组合，组合reducer主要使用了redux的combineReducers API，以下为reducers文件夹下index.js代码：\n\n``` js\nimport { combineReducers } from 'redux'\nimport todos from './todos'\nimport visibilityFilter from './visibilityFilter'\n\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n})\n\nexport default todoApp\n```\n\n\n最后一步，需要使用react-redux的Provider API包裹整个应用，src下index.js中：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux'\nimport './index.css';\nimport App from './App';\nimport { createStore } from 'redux';\nimport reducer from './reducers';\n\nconst store = createStore(reducer);\n\nReactDOM.render(\n<Provider store={store}>\n<App/>\n</Provider>,\ndocument.getElementById('root')\n);\n```\n浏览器运行效果如下：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_209.png)\n\n至此，整个To do应用就开发完毕了，对比使用redux开发，react-redux让我们开发react应用的时候更加简单。\n\n","source":"_posts/react-redux开发简单的to do应用.md","raw":"---\ntitle: react-redux开发简单的To do应用\ndate: 2018-02-23 16:44:49\nbanner: http://img.yanyuanfe.cn/photo-1454165804606-c3d57bc86b40%20%281%29.jpeg\ntags:\n - Redux\n - React\n---\n\n> redux专注于状态管理，和react解耦，为了方便使用，redux的作者封装了一个react专用的库react-redux。\n\n![image](http://img.yanyuanfe.cn/bg2016092101.jpg)\n\n<!--more-->\n\n前面通过一个简单的计数器应用来学习redux的基本原理和用法，在本篇文章，将介绍redux如何与react结合使用。\n为了方便使用，redux的作者封装了一个react专用的库react-redux，这也是接下来的重点。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-2\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 安装\n\n\n``` bash\nnpm install react-redux --save\n```\n\n\n### 基本API\n\n#### <Provider/>组件\nreact-redux提供Provider组件，包裹在根组件最外层，用于传递store到组件内部，让应用内部的任何子孙组件非常方便地获取到全局状态，核心原理是react提供的context API。\n示例代码如下：\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport { createStore } from 'redux';\nimport reducer from './reducers';\n\nconst store = createStore(reducer);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n#### connect()\nreact-redux提供connect方法用于将react组件与redux的store进行连接,通过connect方法，可以在任何react组件中，将store中的全局state和Action Creator传递到组件的props中，以供组件使用。\n\nconnect方法接受两个参数，**mapStateToProps**和**mapDispatchToProps**，用于定义组件的输入输出。mapStateToProps负责输入逻辑，将state映射到组件的props，后者负责输出逻辑，将Action Creator方法传递到组件的props中，在组件内即可发起Action。\n示例代码如下：\n\n``` js\nimport { connect } from 'react-redux';\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link);\n\nexport default FilterLink;\n```\n\n\n#### mapStateToProps\nmapStateToProps是一个函数，接受两个参数，state和props，state包含整个全局对象树，props代表组件的props，一般情况下使用state情况最多。执行后返回一个对象，对象的键值对就是一个映射。\n示例代码如下：\n\n\n``` js\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n```\n\n\n上述代码中，在mapStateToProps中，通过全局state和组件的props进行计算，得到包含键active的对象，传入组件，在组件中即可通过this.props.active来获取值。\n\n#### mapDispatchToProps\n\nmapDispatch是一个函数或者对象，用于将store.dispatch映射到组件的props。当mapDiapatchToProps是一个函数时，传入dispatch和ownProps两个参数，返回一个对象，对象的键值对定义了组件的props传递的方法以及对应的action。\n示例代码如下：\n\n\n``` js\nconst mapDispatchToProps = (\n  dispatch,\n  ownProps\n) => {\n  return {\n    onClick: () => {\n      dispatch({\n        type: 'SET_VISIBILITY_FILTER',\n        filter: ownProps.filter\n      });\n    }\n  };\n}\n```\n\n上述代码将dispatch方法映射到组件的props参数onClick，在组件内部即可通过this.props.onClick（）进行调用。\n\n当mapDispatch是一个对象时，它的键值对分别是组件的props参数和一个作为Action Creator的函数，通常在大型应用中，会在专门的文件中定义actionCreators文件，如下：\n\n\n``` js\nexport const setVisibilityFilter = (filter) => ({\n  type: 'SET_VISIBILITY_FILTER',\n  filter\n})\n```\n\n上述代码就是一系列actionCreator之一，返回一个Action，由Redux自动发出，上述代码使用如下：\n\n``` js\nimport { setVisibilityFilter } from '../actions';\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n```\n\n这种方法跟写成函数的方法其实是一样的，只是将action进行了单独的抽离，这样可以避免更多的冗余代码，如需要在多个组件中发起相同的action时。\n\n### 实战To do应用\n前面已经了解了react-redux的核心API，下面来完成一个完整的应用。\n\n整个应用实现的界面如下：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_183.png)\n\n功能主要有，输入文字添加todo事项，显示todo list，点击todo项切换状态，点击tab筛选不同的todo 状态。\n\n在应用开发过程中，使用components，首先，使用create-react-app来初始化react应用，src为主要的开发目录，src目录下，分别新建actions、components、containers、reducers文件夹，actions用于编写actionCreator，reducers文件夹下用于编写应用的reducer，component文件夹下编写UI组件，即无状态组件，只负责UI的呈现，不负责业务逻辑，数据通过props传入，也不操作redux相关的api。containers文件夹下编写容器组件，负责管理数据和业务逻辑，操作redux的api。\n\n首先，在**App.js**中，包含了整个应用的UI界面。\n\n``` js\nimport React, { Component } from 'react';\nimport Footer from './components/Footer';\nimport AddTodo from './containers/AddTodo';\nimport VisibleTodoList from './containers/VisibleTodoList';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n\n    return (\n      <div className=\"App\">\n        <div className=\"todoapp\">\n          <AddTodo/>\n          <VisibleTodoList/>\n          <Footer/>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n\n可以看到，整个应用包含三个组件**AddTodo**、**VisibleTodoList**、**Footer**。\n\n下面逐步介绍整个界面的实现。\n从containers文件夹开始，首先是AddTodo组件，用于添加todo。\n\n``` js\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { addTodo } from '../actions'\n\nlet AddTodo = ({ dispatch }) => {\n  let input\n\n  return (\n    <div>\n      <form onSubmit={e => {\n        e.preventDefault()\n        if (!input.value.trim()) {\n          return\n        }\n        dispatch(addTodo(input.value))\n        input.value = ''\n      }}>\n        <input ref={node => {\n          input = node\n        }} />\n        <button type=\"submit\">\n          Add Todo\n        </button>\n      </form>\n    </div>\n  )\n}\nAddTodo = connect()(AddTodo)\n\nexport default AddTodo\n```\n\n\nAddTodo包含一个Form表单，在Form表单的onSubmit事件中，获取输入值，提交至action，整个组件被redux的connect组件包裹，从而使得dispatch传入到组件的props中。\n\n下面是actions的addTodo方法。\n\n``` js\nlet nextTodoId = 0\nexport const addTodo = (text) => ({\n  type: 'ADD_TODO',\n  id: nextTodoId++,\n  text\n})\n```\n\naddTodo用于新建Todo，将todo的id加1,传入todo的text属性。\n\n下面是VisibleTodoList组件，根据当前选中的tab来显示不同状态下的todo list。\n\n``` js\nimport { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\n\nconst getVisibleTodos = (todos, filter) => {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos\n    case 'SHOW_COMPLETED':\n      return todos.filter(t => t.completed)\n    case 'SHOW_ACTIVE':\n      return todos.filter(t => !t.completed)\n    default:\n      throw new Error('Unknown filter: ' + filter)\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  todos: getVisibleTodos(state.todos, state.visibilityFilter)\n})\n\nconst mapDispatchToProps = {\n  onTodoClick: toggleTodo\n}\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n```\n\n\n从代码中可以看到，VisibleTodoList没有界面相关的部分，仅仅是将TodoList组件进行包裹返回一个新的组件。mapStateToProps中，根据当前所有的todos和筛选条件visibilityFilter，通过getVisibleTodos函数，返回一个筛选后的todos，mapDispatchToProps则是将actionCreator方法通过props传入到UI组件。\n\n\n在actions文件夹下，index.js中，定义了toggleTodo如下：\n\n\n``` js\nexport const toggleTodo = (id) => ({\n  type: 'TOGGLE_TODO',\n  id\n})\n```\n\n\ntoggleTodo通过传入的id对当前操作的todo进行处理。\n\n\n下面是components下的TodoList组件，负责显示todo list。\n\n\n``` js\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport Todo from './Todo'\n\nconst TodoList = ({ todos, onTodoClick }) => (\n  <ul>\n    {todos.map(todo =>\n      <Todo\n        key={todo.id}\n        {...todo}\n        onClick={() => onTodoClick(todo.id)}\n      />\n    )}\n  </ul>\n)\n\nTodoList.propTypes = {\n  todos: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired).isRequired,\n  onTodoClick: PropTypes.func.isRequired\n}\n\nexport default TodoList\n```\n\n\n从上述代码可以看到，TodoList接收props中的todos, onTodoClick，并对todos进行渲染，每个todo又抽离成单独的Todo组件，在每个Todo上传递点击事件，点击事件中，调用onTodoClick，并传入当前todo的id，以此来改变todo的状态。\n\nTodo组件如下所示：\n\n``` js\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\nconst Todo = ({ onClick, completed, text }) => (\n  <li\n    onClick={onClick}\n    style={{\n      textDecoration: completed ? 'line-through' : 'none'\n    }}\n  >\n    {text}\n  </li>\n)\n\nTodo.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  completed: PropTypes.bool.isRequired,\n  text: PropTypes.string.isRequired\n}\n\nexport default Todo\n```\n\n在TodoList组件中，渲染所有的todo list时，将每个todo进行对象解构，传入Todo组件的props，在Todo组件中，获取到组件需要的参数onClick, completed, text，onClick用于绑定到todo的点击事件，completed用于表示todo的状态是否为完成，根据completed的值来渲染todo的样式，text渲染为todo的内容。\n下面是components中的Footer组件：\n\n``` js\nimport React from 'react'\nimport FilterLink from '../containers/FilterLink'\n\nconst Footer = () => (\n  <p>\n    Show:\n    {\" \"}\n    <FilterLink filter=\"SHOW_ALL\">\n      All\n    </FilterLink>\n    {\", \"}\n    <FilterLink filter=\"SHOW_ACTIVE\">\n      Active\n    </FilterLink>\n    {\", \"}\n    <FilterLink filter=\"SHOW_COMPLETED\">\n      Completed\n    </FilterLink>\n  </p>\n)\n\nexport default Footer\n```\n\nFooter组件中，用于对todos的状态进行筛选，共包含三个筛选项，SHOW_ALL显示所有todos，SHOW_ACTIVE显示刚添加的todo，SHOW_COMPLETED显示已经完成的todo。每个筛选项又抽离成FilterLink组件，传入filter作为筛选参数。\n\n下面是container中FilterLink的代码。\n\n\n``` js\nimport { connect } from 'react-redux'\nimport { setVisibilityFilter } from '../actions'\nimport Link from '../components/Link'\n\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link)\n\nexport default FilterLink\n```\n\n\nFilterLink组件也仅仅是负责数据的逻辑，没有UI呈现。mapStateToProps中判断当前组件的props.filter与筛选条件state.visibilityFilter来计算active属性传入props，mapDispatchToProps定义onClick方法，用于dispatch一个action来改变当前的筛选条件，即state.visibilityFilter，传入当前组件的filter属性作为参数。\n\nactions的setVisibilityFilter代码如下：\n\n``` js\nexport const setVisibilityFilter = (filter) => ({\n  type: 'SET_VISIBILITY_FILTER',\n  filter\n})\n```\n\n\n下面是Link组件。\n\n\n``` js\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\nconst Link = ({ active, children, onClick }) => {\n  if (active) {\n    return <span>{children}</span>\n  }\n\n  return (\n    // eslint-disable-next-line\n    <a href=\"#\"\n       onClick={e => {\n         e.preventDefault()\n         onClick()\n       }}\n    >\n      {children}\n    </a>\n  )\n}\n\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\n```\n\n\nLink组件通过props接收active，children，onClick属性值，当active为true时，Link渲染为span，否则渲染为a，a标签绑定点击事件，点击时，触发props中的onClick方法。\n\n自此，界面部分的代码都已经介绍完毕，下面是reducer的编写。\n在reducer的编写中，为了让reducer的职责更为清晰，将reducer拆分为todos和visibilityFilter，todos.js中，用于处理todo的添加，状态改变。代码如下：\n\n``` js\nconst todos = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ]\n    case 'TOGGLE_TODO':\n      return state.map(todo =>\n        (todo.id === action.id)\n          ? {...todo, completed: !todo.completed}\n          : todo\n      )\n    default:\n      return state\n  }\n}\n\nexport default todos\n```\n\n\n此处，todos初始化为一个空数组，reducer必须为纯函数，处理actions，不能直接对state进行修改，应该每次都返回一个新的state，当添加Todo时，使用数组展开运算符对state进行解构，并且，将新的todo对象作为数组的最后一个值，最终，生成一个全新的state。当修改todo状态时，使用数组的map方法，同样返回一个新的state，在map方法内部，使用三元运算符对action参数id和数组每一项的id进行判断，目的是寻找到当前被点击时的todo，将其completed值取反，否则直接返回当前todo。\n\nvisibilityFilter.js中，主要是用于更改todo list的筛选条件，代码如下：\n\n\n``` js\nconst visibilityFilter = (state = 'SHOW_ALL', action) => {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter\n    default:\n      return state\n  }\n}\n\nexport default visibilityFilter\n\n```\n\n此时，state初始化为SHOW_ALL，即应用加载时，默认显示为全部的todos，当处理actions，直接返回action.filter。\n\n当reducer被拆分为单个文件时，上述const 命名的函数名即为全局状态树中的state值，还需要将拆分的reducer进行组合，组合reducer主要使用了redux的combineReducers API，以下为reducers文件夹下index.js代码：\n\n``` js\nimport { combineReducers } from 'redux'\nimport todos from './todos'\nimport visibilityFilter from './visibilityFilter'\n\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n})\n\nexport default todoApp\n```\n\n\n最后一步，需要使用react-redux的Provider API包裹整个应用，src下index.js中：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux'\nimport './index.css';\nimport App from './App';\nimport { createStore } from 'redux';\nimport reducer from './reducers';\n\nconst store = createStore(reducer);\n\nReactDOM.render(\n<Provider store={store}>\n<App/>\n</Provider>,\ndocument.getElementById('root')\n);\n```\n浏览器运行效果如下：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_209.png)\n\n至此，整个To do应用就开发完毕了，对比使用redux开发，react-redux让我们开发react应用的时候更加简单。\n\n","slug":"react-redux开发简单的to do应用","published":1,"updated":"2020-07-16T13:56:47.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennh000np70v7vtxm5xw","content":"<blockquote>\n<p>redux专注于状态管理，和react解耦，为了方便使用，redux的作者封装了一个react专用的库react-redux。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/bg2016092101.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>前面通过一个简单的计数器应用来学习redux的基本原理和用法，在本篇文章，将介绍redux如何与react结合使用。<br>为了方便使用，redux的作者封装了一个react专用的库react-redux，这也是接下来的重点。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-2</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install react-redux --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h3><h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a><provider>组件</provider></h4><p>react-redux提供Provider组件，包裹在根组件最外层，用于传递store到组件内部，让应用内部的任何子孙组件非常方便地获取到全局状态，核心原理是react提供的context API。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect()\"></a>connect()</h4><p>react-redux提供connect方法用于将react组件与redux的store进行连接,通过connect方法，可以在任何react组件中，将store中的全局state和Action Creator传递到组件的props中，以供组件使用。</p>\n<p>connect方法接受两个参数，<strong>mapStateToProps</strong>和<strong>mapDispatchToProps</strong>，用于定义组件的输入输出。mapStateToProps负责输入逻辑，将state映射到组件的props，后者负责输出逻辑，将Action Creator方法传递到组件的props中，在组件内即可发起Action。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> FilterLink;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mapStateToProps\"><a href=\"#mapStateToProps\" class=\"headerlink\" title=\"mapStateToProps\"></a>mapStateToProps</h4><p>mapStateToProps是一个函数，接受两个参数，state和props，state包含整个全局对象树，props代表组件的props，一般情况下使用state情况最多。执行后返回一个对象，对象的键值对就是一个映射。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上述代码中，在mapStateToProps中，通过全局state和组件的props进行计算，得到包含键active的对象，传入组件，在组件中即可通过this.props.active来获取值。</p>\n<h4 id=\"mapDispatchToProps\"><a href=\"#mapDispatchToProps\" class=\"headerlink\" title=\"mapDispatchToProps\"></a>mapDispatchToProps</h4><p>mapDispatch是一个函数或者对象，用于将store.dispatch映射到组件的props。当mapDiapatchToProps是一个函数时，传入dispatch和ownProps两个参数，返回一个对象，对象的键值对定义了组件的props传递的方法以及对应的action。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = (</span><br><span class=\"line\">  dispatch,</span><br><span class=\"line\">  ownProps</span><br><span class=\"line\">) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: <span class=\"string\">'SET_VISIBILITY_FILTER'</span>,</span><br><span class=\"line\">        filter: ownProps.filter</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码将dispatch方法映射到组件的props参数onClick，在组件内部即可通过this.props.onClick（）进行调用。</p>\n<p>当mapDispatch是一个对象时，它的键值对分别是组件的props参数和一个作为Action Creator的函数，通常在大型应用中，会在专门的文件中定义actionCreators文件，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> setVisibilityFilter = <span class=\"function\">(<span class=\"params\">filter</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'SET_VISIBILITY_FILTER'</span>,</span><br><span class=\"line\">  filter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上述代码就是一系列actionCreator之一，返回一个Action，由Redux自动发出，上述代码使用如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; setVisibilityFilter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这种方法跟写成函数的方法其实是一样的，只是将action进行了单独的抽离，这样可以避免更多的冗余代码，如需要在多个组件中发起相同的action时。</p>\n<h3 id=\"实战To-do应用\"><a href=\"#实战To-do应用\" class=\"headerlink\" title=\"实战To do应用\"></a>实战To do应用</h3><p>前面已经了解了react-redux的核心API，下面来完成一个完整的应用。</p>\n<p>整个应用实现的界面如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_183.png\" alt=\"image\"></p>\n<p>功能主要有，输入文字添加todo事项，显示todo list，点击todo项切换状态，点击tab筛选不同的todo 状态。</p>\n<p>在应用开发过程中，使用components，首先，使用create-react-app来初始化react应用，src为主要的开发目录，src目录下，分别新建actions、components、containers、reducers文件夹，actions用于编写actionCreator，reducers文件夹下用于编写应用的reducer，component文件夹下编写UI组件，即无状态组件，只负责UI的呈现，不负责业务逻辑，数据通过props传入，也不操作redux相关的api。containers文件夹下编写容器组件，负责管理数据和业务逻辑，操作redux的api。</p>\n<p>首先，在<strong>App.js</strong>中，包含了整个应用的UI界面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Footer <span class=\"keyword\">from</span> <span class=\"string\">'./components/Footer'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> AddTodo <span class=\"keyword\">from</span> <span class=\"string\">'./containers/AddTodo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> VisibleTodoList <span class=\"keyword\">from</span> <span class=\"string\">'./containers/VisibleTodoList'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"todoapp\"</span>&gt;</span><br><span class=\"line\">          &lt;AddTodo/&gt;</span><br><span class=\"line\">          &lt;VisibleTodoList/&gt;</span><br><span class=\"line\">          &lt;Footer/&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n<p>可以看到，整个应用包含三个组件<strong>AddTodo</strong>、<strong>VisibleTodoList</strong>、<strong>Footer</strong>。</p>\n<p>下面逐步介绍整个界面的实现。<br>从containers文件夹开始，首先是AddTodo组件，用于添加todo。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; addTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> AddTodo = <span class=\"function\">(<span class=\"params\">&#123; dispatch &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> input</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class=\"line\">        e.preventDefault()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!input.value.trim()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dispatch(addTodo(input.value))</span><br><span class=\"line\">        input.value = <span class=\"string\">''</span></span><br><span class=\"line\">      &#125;&#125;&gt;</span><br><span class=\"line\">        &lt;input ref=&#123;node =&gt; &#123;</span><br><span class=\"line\">          input = node</span><br><span class=\"line\">        &#125;&#125; /&gt;</span><br><span class=\"line\">        &lt;button type=<span class=\"string\">\"submit\"</span>&gt;</span><br><span class=\"line\">          Add Todo</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>form&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">AddTodo = connect()(AddTodo)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default AddTodo</span></span><br></pre></td></tr></table></figure>\n<p>AddTodo包含一个Form表单，在Form表单的onSubmit事件中，获取输入值，提交至action，整个组件被redux的connect组件包裹，从而使得dispatch传入到组件的props中。</p>\n<p>下面是actions的addTodo方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextTodoId = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> addTodo = <span class=\"function\">(<span class=\"params\">text</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">  id: nextTodoId++,</span><br><span class=\"line\">  text</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>addTodo用于新建Todo，将todo的id加1,传入todo的text属性。</p>\n<p>下面是VisibleTodoList组件，根据当前选中的tab来显示不同状态下的todo list。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; toggleTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">'../components/TodoList'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getVisibleTodos = <span class=\"function\">(<span class=\"params\">todos, filter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SHOW_ALL'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SHOW_COMPLETED'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SHOW_ACTIVE'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> !t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Unknown filter: '</span> + filter)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = &#123;</span><br><span class=\"line\">  onTodoClick: toggleTodo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> VisibleTodoList = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(TodoList)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> VisibleTodoList</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看到，VisibleTodoList没有界面相关的部分，仅仅是将TodoList组件进行包裹返回一个新的组件。mapStateToProps中，根据当前所有的todos和筛选条件visibilityFilter，通过getVisibleTodos函数，返回一个筛选后的todos，mapDispatchToProps则是将actionCreator方法通过props传入到UI组件。</p>\n<p>在actions文件夹下，index.js中，定义了toggleTodo如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> toggleTodo = <span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'TOGGLE_TODO'</span>,</span><br><span class=\"line\">  id</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>toggleTodo通过传入的id对当前操作的todo进行处理。</p>\n<p>下面是components下的TodoList组件，负责显示todo list。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Todo <span class=\"keyword\">from</span> <span class=\"string\">'./Todo'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> TodoList = <span class=\"function\">(<span class=\"params\">&#123; todos, onTodoClick &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;todos.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">      &lt;Todo</span><br><span class=\"line\">        key=&#123;todo.id&#125;</span><br><span class=\"line\">        &#123;...todo&#125;</span><br><span class=\"line\">        onClick=&#123;() =&gt; onTodoClick(todo.id)&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    )&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">TodoList.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  todos: PropTypes.arrayOf(PropTypes.shape(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    id: PropTypes.number.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">    completed: PropTypes.bool.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">    text: PropTypes.string.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;).isRequired).isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onTodoClick: PropTypes.func.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default TodoList</span></span><br></pre></td></tr></table></figure>\n<p>从上述代码可以看到，TodoList接收props中的todos, onTodoClick，并对todos进行渲染，每个todo又抽离成单独的Todo组件，在每个Todo上传递点击事件，点击事件中，调用onTodoClick，并传入当前todo的id，以此来改变todo的状态。</p>\n<p>Todo组件如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Todo = <span class=\"function\">(<span class=\"params\">&#123; onClick, completed, text &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">  &lt;li</span><br><span class=\"line\">    onClick=&#123;onClick&#125;</span><br><span class=\"line\">    style=&#123;&#123;</span><br><span class=\"line\">      textDecoration: completed ? <span class=\"string\">'line-through'</span> : <span class=\"string\">'none'</span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    &#123;text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Todo.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onClick: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  completed: PropTypes.bool.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  text: PropTypes.string.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Todo</span></span><br></pre></td></tr></table></figure>\n<p>在TodoList组件中，渲染所有的todo list时，将每个todo进行对象解构，传入Todo组件的props，在Todo组件中，获取到组件需要的参数onClick, completed, text，onClick用于绑定到todo的点击事件，completed用于表示todo的状态是否为完成，根据completed的值来渲染todo的样式，text渲染为todo的内容。<br>下面是components中的Footer组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> FilterLink <span class=\"keyword\">from</span> <span class=\"string\">'../containers/FilterLink'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Footer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">    Show:</span><br><span class=\"line\">    &#123;<span class=\"string\">\" \"</span>&#125;</span><br><span class=\"line\">    &lt;FilterLink filter=<span class=\"string\">\"SHOW_ALL\"</span>&gt;</span><br><span class=\"line\">      All</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/FilterLink&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#123;\", \"&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;FilterLink filter=\"SHOW_ACTIVE\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      Active</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>FilterLink&gt;</span><br><span class=\"line\">    &#123;<span class=\"string\">\", \"</span>&#125;</span><br><span class=\"line\">    &lt;FilterLink filter=<span class=\"string\">\"SHOW_COMPLETED\"</span>&gt;</span><br><span class=\"line\">      Completed</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/FilterLink&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>p&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Footer</span><br></pre></td></tr></table></figure>\n<p>Footer组件中，用于对todos的状态进行筛选，共包含三个筛选项，SHOW_ALL显示所有todos，SHOW_ACTIVE显示刚添加的todo，SHOW_COMPLETED显示已经完成的todo。每个筛选项又抽离成FilterLink组件，传入filter作为筛选参数。</p>\n<p>下面是container中FilterLink的代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; setVisibilityFilter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Link <span class=\"keyword\">from</span> <span class=\"string\">'../components/Link'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> FilterLink</span><br></pre></td></tr></table></figure>\n<p>FilterLink组件也仅仅是负责数据的逻辑，没有UI呈现。mapStateToProps中判断当前组件的props.filter与筛选条件state.visibilityFilter来计算active属性传入props，mapDispatchToProps定义onClick方法，用于dispatch一个action来改变当前的筛选条件，即state.visibilityFilter，传入当前组件的filter属性作为参数。</p>\n<p>actions的setVisibilityFilter代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> setVisibilityFilter = <span class=\"function\">(<span class=\"params\">filter</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'SET_VISIBILITY_FILTER'</span>,</span><br><span class=\"line\">  filter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>下面是Link组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Link = <span class=\"function\">(<span class=\"params\">&#123; active, children, onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (active) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// eslint-disable-next-line</span></span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span></span><br><span class=\"line\">       onClick=&#123;e =&gt; &#123;</span><br><span class=\"line\">         e.preventDefault()</span><br><span class=\"line\">         onClick()</span><br><span class=\"line\">       &#125;&#125;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">      &#123;children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Link.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  active: PropTypes.bool.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  children: PropTypes.node.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onClick: PropTypes.func.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Link</span></span><br></pre></td></tr></table></figure>\n<p>Link组件通过props接收active，children，onClick属性值，当active为true时，Link渲染为span，否则渲染为a，a标签绑定点击事件，点击时，触发props中的onClick方法。</p>\n<p>自此，界面部分的代码都已经介绍完毕，下面是reducer的编写。<br>在reducer的编写中，为了让reducer的职责更为清晰，将reducer拆分为todos和visibilityFilter，todos.js中，用于处理todo的添加，状态改变。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = [], action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: action.id,</span><br><span class=\"line\">          text: action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'TOGGLE_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">        (todo.id === action.id)</span><br><span class=\"line\">          ? &#123;...todo, <span class=\"attr\">completed</span>: !todo.completed&#125;</span><br><span class=\"line\">          : todo</span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todos</span><br></pre></td></tr></table></figure>\n<p>此处，todos初始化为一个空数组，reducer必须为纯函数，处理actions，不能直接对state进行修改，应该每次都返回一个新的state，当添加Todo时，使用数组展开运算符对state进行解构，并且，将新的todo对象作为数组的最后一个值，最终，生成一个全新的state。当修改todo状态时，使用数组的map方法，同样返回一个新的state，在map方法内部，使用三元运算符对action参数id和数组每一项的id进行判断，目的是寻找到当前被点击时的todo，将其completed值取反，否则直接返回当前todo。</p>\n<p>visibilityFilter.js中，主要是用于更改todo list的筛选条件，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> visibilityFilter = <span class=\"function\">(<span class=\"params\">state = <span class=\"string\">'SHOW_ALL'</span>, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SET_VISIBILITY_FILTER'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.filter</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> visibilityFilter</span><br></pre></td></tr></table></figure>\n<p>此时，state初始化为SHOW_ALL，即应用加载时，默认显示为全部的todos，当处理actions，直接返回action.filter。</p>\n<p>当reducer被拆分为单个文件时，上述const 命名的函数名即为全局状态树中的state值，还需要将拆分的reducer进行组合，组合reducer主要使用了redux的combineReducers API，以下为reducers文件夹下index.js代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> visibilityFilter <span class=\"keyword\">from</span> <span class=\"string\">'./visibilityFilter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp</span><br></pre></td></tr></table></figure>\n<p>最后一步，需要使用react-redux的Provider API包裹整个应用，src下index.js中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">&lt;App/&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>浏览器运行效果如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_209.png\" alt=\"image\"></p>\n<p>至此，整个To do应用就开发完毕了，对比使用redux开发，react-redux让我们开发react应用的时候更加简单。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>redux专注于状态管理，和react解耦，为了方便使用，redux的作者封装了一个react专用的库react-redux。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/bg2016092101.jpg\" alt=\"image\"></p>","more":"<p>前面通过一个简单的计数器应用来学习redux的基本原理和用法，在本篇文章，将介绍redux如何与react结合使用。<br>为了方便使用，redux的作者封装了一个react专用的库react-redux，这也是接下来的重点。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-2</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install react-redux --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h3><h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a><provider>组件</provider></h4><p>react-redux提供Provider组件，包裹在根组件最外层，用于传递store到组件内部，让应用内部的任何子孙组件非常方便地获取到全局状态，核心原理是react提供的context API。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect()\"></a>connect()</h4><p>react-redux提供connect方法用于将react组件与redux的store进行连接,通过connect方法，可以在任何react组件中，将store中的全局state和Action Creator传递到组件的props中，以供组件使用。</p>\n<p>connect方法接受两个参数，<strong>mapStateToProps</strong>和<strong>mapDispatchToProps</strong>，用于定义组件的输入输出。mapStateToProps负责输入逻辑，将state映射到组件的props，后者负责输出逻辑，将Action Creator方法传递到组件的props中，在组件内即可发起Action。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> FilterLink;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mapStateToProps\"><a href=\"#mapStateToProps\" class=\"headerlink\" title=\"mapStateToProps\"></a>mapStateToProps</h4><p>mapStateToProps是一个函数，接受两个参数，state和props，state包含整个全局对象树，props代表组件的props，一般情况下使用state情况最多。执行后返回一个对象，对象的键值对就是一个映射。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上述代码中，在mapStateToProps中，通过全局state和组件的props进行计算，得到包含键active的对象，传入组件，在组件中即可通过this.props.active来获取值。</p>\n<h4 id=\"mapDispatchToProps\"><a href=\"#mapDispatchToProps\" class=\"headerlink\" title=\"mapDispatchToProps\"></a>mapDispatchToProps</h4><p>mapDispatch是一个函数或者对象，用于将store.dispatch映射到组件的props。当mapDiapatchToProps是一个函数时，传入dispatch和ownProps两个参数，返回一个对象，对象的键值对定义了组件的props传递的方法以及对应的action。<br>示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = (</span><br><span class=\"line\">  dispatch,</span><br><span class=\"line\">  ownProps</span><br><span class=\"line\">) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: <span class=\"string\">'SET_VISIBILITY_FILTER'</span>,</span><br><span class=\"line\">        filter: ownProps.filter</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码将dispatch方法映射到组件的props参数onClick，在组件内部即可通过this.props.onClick（）进行调用。</p>\n<p>当mapDispatch是一个对象时，它的键值对分别是组件的props参数和一个作为Action Creator的函数，通常在大型应用中，会在专门的文件中定义actionCreators文件，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> setVisibilityFilter = <span class=\"function\">(<span class=\"params\">filter</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'SET_VISIBILITY_FILTER'</span>,</span><br><span class=\"line\">  filter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上述代码就是一系列actionCreator之一，返回一个Action，由Redux自动发出，上述代码使用如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; setVisibilityFilter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这种方法跟写成函数的方法其实是一样的，只是将action进行了单独的抽离，这样可以避免更多的冗余代码，如需要在多个组件中发起相同的action时。</p>\n<h3 id=\"实战To-do应用\"><a href=\"#实战To-do应用\" class=\"headerlink\" title=\"实战To do应用\"></a>实战To do应用</h3><p>前面已经了解了react-redux的核心API，下面来完成一个完整的应用。</p>\n<p>整个应用实现的界面如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_183.png\" alt=\"image\"></p>\n<p>功能主要有，输入文字添加todo事项，显示todo list，点击todo项切换状态，点击tab筛选不同的todo 状态。</p>\n<p>在应用开发过程中，使用components，首先，使用create-react-app来初始化react应用，src为主要的开发目录，src目录下，分别新建actions、components、containers、reducers文件夹，actions用于编写actionCreator，reducers文件夹下用于编写应用的reducer，component文件夹下编写UI组件，即无状态组件，只负责UI的呈现，不负责业务逻辑，数据通过props传入，也不操作redux相关的api。containers文件夹下编写容器组件，负责管理数据和业务逻辑，操作redux的api。</p>\n<p>首先，在<strong>App.js</strong>中，包含了整个应用的UI界面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Footer <span class=\"keyword\">from</span> <span class=\"string\">'./components/Footer'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> AddTodo <span class=\"keyword\">from</span> <span class=\"string\">'./containers/AddTodo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> VisibleTodoList <span class=\"keyword\">from</span> <span class=\"string\">'./containers/VisibleTodoList'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"todoapp\"</span>&gt;</span><br><span class=\"line\">          &lt;AddTodo/&gt;</span><br><span class=\"line\">          &lt;VisibleTodoList/&gt;</span><br><span class=\"line\">          &lt;Footer/&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n<p>可以看到，整个应用包含三个组件<strong>AddTodo</strong>、<strong>VisibleTodoList</strong>、<strong>Footer</strong>。</p>\n<p>下面逐步介绍整个界面的实现。<br>从containers文件夹开始，首先是AddTodo组件，用于添加todo。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; addTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> AddTodo = <span class=\"function\">(<span class=\"params\">&#123; dispatch &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> input</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class=\"line\">        e.preventDefault()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!input.value.trim()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dispatch(addTodo(input.value))</span><br><span class=\"line\">        input.value = <span class=\"string\">''</span></span><br><span class=\"line\">      &#125;&#125;&gt;</span><br><span class=\"line\">        &lt;input ref=&#123;node =&gt; &#123;</span><br><span class=\"line\">          input = node</span><br><span class=\"line\">        &#125;&#125; /&gt;</span><br><span class=\"line\">        &lt;button type=<span class=\"string\">\"submit\"</span>&gt;</span><br><span class=\"line\">          Add Todo</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>form&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">AddTodo = connect()(AddTodo)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default AddTodo</span></span><br></pre></td></tr></table></figure>\n<p>AddTodo包含一个Form表单，在Form表单的onSubmit事件中，获取输入值，提交至action，整个组件被redux的connect组件包裹，从而使得dispatch传入到组件的props中。</p>\n<p>下面是actions的addTodo方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextTodoId = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> addTodo = <span class=\"function\">(<span class=\"params\">text</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">  id: nextTodoId++,</span><br><span class=\"line\">  text</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>addTodo用于新建Todo，将todo的id加1,传入todo的text属性。</p>\n<p>下面是VisibleTodoList组件，根据当前选中的tab来显示不同状态下的todo list。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; toggleTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">'../components/TodoList'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getVisibleTodos = <span class=\"function\">(<span class=\"params\">todos, filter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SHOW_ALL'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SHOW_COMPLETED'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SHOW_ACTIVE'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> !t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Unknown filter: '</span> + filter)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = &#123;</span><br><span class=\"line\">  onTodoClick: toggleTodo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> VisibleTodoList = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(TodoList)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> VisibleTodoList</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看到，VisibleTodoList没有界面相关的部分，仅仅是将TodoList组件进行包裹返回一个新的组件。mapStateToProps中，根据当前所有的todos和筛选条件visibilityFilter，通过getVisibleTodos函数，返回一个筛选后的todos，mapDispatchToProps则是将actionCreator方法通过props传入到UI组件。</p>\n<p>在actions文件夹下，index.js中，定义了toggleTodo如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> toggleTodo = <span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'TOGGLE_TODO'</span>,</span><br><span class=\"line\">  id</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>toggleTodo通过传入的id对当前操作的todo进行处理。</p>\n<p>下面是components下的TodoList组件，负责显示todo list。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Todo <span class=\"keyword\">from</span> <span class=\"string\">'./Todo'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> TodoList = <span class=\"function\">(<span class=\"params\">&#123; todos, onTodoClick &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;todos.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">      &lt;Todo</span><br><span class=\"line\">        key=&#123;todo.id&#125;</span><br><span class=\"line\">        &#123;...todo&#125;</span><br><span class=\"line\">        onClick=&#123;() =&gt; onTodoClick(todo.id)&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    )&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">TodoList.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  todos: PropTypes.arrayOf(PropTypes.shape(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    id: PropTypes.number.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">    completed: PropTypes.bool.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">    text: PropTypes.string.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;).isRequired).isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onTodoClick: PropTypes.func.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default TodoList</span></span><br></pre></td></tr></table></figure>\n<p>从上述代码可以看到，TodoList接收props中的todos, onTodoClick，并对todos进行渲染，每个todo又抽离成单独的Todo组件，在每个Todo上传递点击事件，点击事件中，调用onTodoClick，并传入当前todo的id，以此来改变todo的状态。</p>\n<p>Todo组件如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Todo = <span class=\"function\">(<span class=\"params\">&#123; onClick, completed, text &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">  &lt;li</span><br><span class=\"line\">    onClick=&#123;onClick&#125;</span><br><span class=\"line\">    style=&#123;&#123;</span><br><span class=\"line\">      textDecoration: completed ? <span class=\"string\">'line-through'</span> : <span class=\"string\">'none'</span></span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    &#123;text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Todo.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onClick: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  completed: PropTypes.bool.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  text: PropTypes.string.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Todo</span></span><br></pre></td></tr></table></figure>\n<p>在TodoList组件中，渲染所有的todo list时，将每个todo进行对象解构，传入Todo组件的props，在Todo组件中，获取到组件需要的参数onClick, completed, text，onClick用于绑定到todo的点击事件，completed用于表示todo的状态是否为完成，根据completed的值来渲染todo的样式，text渲染为todo的内容。<br>下面是components中的Footer组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> FilterLink <span class=\"keyword\">from</span> <span class=\"string\">'../containers/FilterLink'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Footer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">    Show:</span><br><span class=\"line\">    &#123;<span class=\"string\">\" \"</span>&#125;</span><br><span class=\"line\">    &lt;FilterLink filter=<span class=\"string\">\"SHOW_ALL\"</span>&gt;</span><br><span class=\"line\">      All</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/FilterLink&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#123;\", \"&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;FilterLink filter=\"SHOW_ACTIVE\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      Active</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>FilterLink&gt;</span><br><span class=\"line\">    &#123;<span class=\"string\">\", \"</span>&#125;</span><br><span class=\"line\">    &lt;FilterLink filter=<span class=\"string\">\"SHOW_COMPLETED\"</span>&gt;</span><br><span class=\"line\">      Completed</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/FilterLink&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>p&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Footer</span><br></pre></td></tr></table></figure>\n<p>Footer组件中，用于对todos的状态进行筛选，共包含三个筛选项，SHOW_ALL显示所有todos，SHOW_ACTIVE显示刚添加的todo，SHOW_COMPLETED显示已经完成的todo。每个筛选项又抽离成FilterLink组件，传入filter作为筛选参数。</p>\n<p>下面是container中FilterLink的代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; setVisibilityFilter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Link <span class=\"keyword\">from</span> <span class=\"string\">'../components/Link'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> FilterLink</span><br></pre></td></tr></table></figure>\n<p>FilterLink组件也仅仅是负责数据的逻辑，没有UI呈现。mapStateToProps中判断当前组件的props.filter与筛选条件state.visibilityFilter来计算active属性传入props，mapDispatchToProps定义onClick方法，用于dispatch一个action来改变当前的筛选条件，即state.visibilityFilter，传入当前组件的filter属性作为参数。</p>\n<p>actions的setVisibilityFilter代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> setVisibilityFilter = <span class=\"function\">(<span class=\"params\">filter</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'SET_VISIBILITY_FILTER'</span>,</span><br><span class=\"line\">  filter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>下面是Link组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Link = <span class=\"function\">(<span class=\"params\">&#123; active, children, onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (active) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// eslint-disable-next-line</span></span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span></span><br><span class=\"line\">       onClick=&#123;e =&gt; &#123;</span><br><span class=\"line\">         e.preventDefault()</span><br><span class=\"line\">         onClick()</span><br><span class=\"line\">       &#125;&#125;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">      &#123;children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Link.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  active: PropTypes.bool.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  children: PropTypes.node.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onClick: PropTypes.func.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Link</span></span><br></pre></td></tr></table></figure>\n<p>Link组件通过props接收active，children，onClick属性值，当active为true时，Link渲染为span，否则渲染为a，a标签绑定点击事件，点击时，触发props中的onClick方法。</p>\n<p>自此，界面部分的代码都已经介绍完毕，下面是reducer的编写。<br>在reducer的编写中，为了让reducer的职责更为清晰，将reducer拆分为todos和visibilityFilter，todos.js中，用于处理todo的添加，状态改变。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = [], action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: action.id,</span><br><span class=\"line\">          text: action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'TOGGLE_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">        (todo.id === action.id)</span><br><span class=\"line\">          ? &#123;...todo, <span class=\"attr\">completed</span>: !todo.completed&#125;</span><br><span class=\"line\">          : todo</span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todos</span><br></pre></td></tr></table></figure>\n<p>此处，todos初始化为一个空数组，reducer必须为纯函数，处理actions，不能直接对state进行修改，应该每次都返回一个新的state，当添加Todo时，使用数组展开运算符对state进行解构，并且，将新的todo对象作为数组的最后一个值，最终，生成一个全新的state。当修改todo状态时，使用数组的map方法，同样返回一个新的state，在map方法内部，使用三元运算符对action参数id和数组每一项的id进行判断，目的是寻找到当前被点击时的todo，将其completed值取反，否则直接返回当前todo。</p>\n<p>visibilityFilter.js中，主要是用于更改todo list的筛选条件，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> visibilityFilter = <span class=\"function\">(<span class=\"params\">state = <span class=\"string\">'SHOW_ALL'</span>, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SET_VISIBILITY_FILTER'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.filter</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> visibilityFilter</span><br></pre></td></tr></table></figure>\n<p>此时，state初始化为SHOW_ALL，即应用加载时，默认显示为全部的todos，当处理actions，直接返回action.filter。</p>\n<p>当reducer被拆分为单个文件时，上述const 命名的函数名即为全局状态树中的state值，还需要将拆分的reducer进行组合，组合reducer主要使用了redux的combineReducers API，以下为reducers文件夹下index.js代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> visibilityFilter <span class=\"keyword\">from</span> <span class=\"string\">'./visibilityFilter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp</span><br></pre></td></tr></table></figure>\n<p>最后一步，需要使用react-redux的Provider API包裹整个应用，src下index.js中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">&lt;App/&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>浏览器运行效果如下：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_209.png\" alt=\"image\"></p>\n<p>至此，整个To do应用就开发完毕了，对比使用redux开发，react-redux让我们开发react应用的时候更加简单。</p>"},{"title":"Webpack5升级指南","date":"2020-11-05T12:05:50.000Z","_content":"\n> Webpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。\n\n![image](http://img.yanyuanfe.cn/webpack.jpeg)\n\n<!--more-->\nWebpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。\n\n本次重大发布的整体发展方向如下：\n\n- 尝试用持久性缓存来提高构建性能。\n- 尝试用更好的算法和默认值来改进长期缓存。\n- 尝试用更好的 Tree Shaking\n- 和代码生成来改善包大小。\n- 尝试改善与网络平台的兼容性。\n- 尝试在不引入任何破坏性变化的情况下，\n- 清理那些在实现 v4 功能时处于奇怪状态的内部结构。\n- 试图通过现在引入突破性的变化来为未来的功能做准备，\n- 尽可能长时间地保持在 v5 版本上。\n\n为了尝试新特性带来的变化，我对一些自己的开源项目进行了依赖升级，本文将对我升级过程中的一些问题的总结。\n\n### 使用npm-check-updates进行依赖升级\n\nnpm-check-updates 插件会自动检查package.json里的最新版本，并进行批量升级。\n\n```\nnpm install -g npm-check-updates\n\n```\n\n\n```\nncu\n```\nncu命令会自动检查package.json中的依赖的最新版本，并列出可升级依赖。\n\n\n```\nncu -u\n```\n运行此命令可对package.json中的依赖版本进行批量更新至最新版本号。\n\n然后运行yarn或者npm install安装最新版本。\n\n### Typescript 类型\n\nWebpack4使用@types/webpack来进行类型检查， Webpack 5 从源码中生成 typescript 类型文件。\n\n修改：\n\n\n```\nyarn remove @types/webpack\n```\n\n\n### webpack-cli\n\nwebpack4.x的启动项目和build命令使用：\n\n\n```\n\"scripts\": {\n    \"start\": \"webpack-dev-server --config ./config/webpack.config.dev.ts --progress --colors\",\n    \"build\": \"webpack-cli --config ./config/webpack.config.prod.ts --progress --colors\"\n  },\n```\n\n运行npm start，出现如下报错：\n\n\n```\nError: Cannot find module 'webpack-cli/bin/config-yargs' \n```\n对应issue：https://github.com/webpack/webpack-dev-server/issues/2424\n\nV5后，使用webpack-cli/serve来代替webpack-dev-server的启动命令：\n\n对应的script修改为：\n\n\n```\n\"scripts\": {\n    \"start\": \"webpack-cli serve --config ./config/webpack.config.dev.ts\",\n    \"build\": \"webpack-cli --config ./config/webpack.config.prod.ts --progress --colors\"\n  },\n```\n\n### 命令行参数\n\nwebpack-cli在webpack5的版本中删除和新增了一些命令行参数，运行时会出现如下报错：\n\n--colors\n\n\n```\n[webpack-cli] Unknown argument: --colors\n\n```\n以上报错就是--colors参数在v5版本不支持了，需要去掉。\n\n不同版本支持的参数参考官方Github：https://github.com/webpack/webpack-cli/tree/next/packages/webpack-cli#webpack-5\n\n\n### webpack loader\n\n\n使用 query 参数来设置loader的options会在启动webpack时报错如下：\n\n```\n[webpack-cli] Promise rejection: Error: Compiling RuleSet failed: Query arguments on 'loader' has been removed in favor of the 'options' property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])\n[webpack-cli] Error: Compiling RuleSet failed: Query arguments on 'loader' has been removed in favor of the 'options' property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])\n\n```\n\n\n```\n{\n        test: /\\.(png|jpg|jpeg|gif|svg)$/,\n        loader: \"file-loader\",\n        //loader: \"file-loader?name=images/[name].[hash:5].[ext]\",\n        options: {\n          name: 'images/[name].[hash:5].[ext]',\n        },\n      }\n```\n\n### devtool\n\n\n```\nwebpack-cli] Invalid configuration object. Webpack has been initialized using a configuration object that does not match the API schema.\n - configuration.devtool should match pattern \"^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$\".\n   BREAKING CHANGE since webpack 5: The devtool option is more strict.\n   Please strictly follow the order of the keywords in the pattern.\n```\n\n\n\n### 移除Node.js模块的Polyfills\n\nwebpack4及其之前的版本附带了一些node模块的polyfill，如：cypto、buffer、process等，如果你的项目中使用到这些模块，则会自动应用相应的polyfill，V5版本中，移除了这些polyfill，如果需要使用则需要手动添加到配置文件：\n\n\n```\nplugins: [\n    new ProvidePlugin({\n      Buffer: [\"buffer\", \"Buffer\"],\n      process: \"process\",\n    }),\n]\n```\n\n### 使用eslint-webpack-plugin代替eslint-loader\n\neslint-webpack-plugin的出现解决了一些eslint-loader的问题。\neslint-webpack-plugin提供了更好的配置方式，生成报告，直接从eslint使用缓存，仅仅lint修改过的文件。\n\n总的来说，eslint-webpack-plugin更好用，首次启动速度大大提升。\n\n修改：\n\n\n```\nyarn add eslint-webpack-plugin -D\n```\n\n\n```\nconst ESLintPlugin = require('eslint-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [new ESLintPlugin({\n      fix: true,\n      lintDirtyModulesOnly: true,\n    })],\n  // ...\n};\n```\n\n### babel-polyfill\n\n在 Babel > 7.4.0 之前，通常我们会安装 babel-polyfill 或 @babel/polyfill来处理实例方法和ES+新增的内置函数，从Babel 7.4.0开始，不推荐使用此软件包，而通过直接导入core-js / stable（以充实ECMAScript功能）和regenerator-runtime / runtime（需要使用转译的生成器函数）：\n\n\n```\nimport \"core-js/stable\";\nimport \"regenerator-runtime/runtime\";\n```\n\n下面直接介绍transform-runtime的方式：\n\n安装依赖：\n```\nyarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D\nyarn add @babel/runtime-corejs3\n```\n.babelrc配置文件：\n\n```\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false,\n      }\n    ]\n  ],\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-runtime\",\n      {\n        \"corejs\": {\n          \"version\": 3,\n          \"proposals\": true\n        },\n        \"useESModules\": true\n      }\n    ]\n  ]\n}\n```\n\n\n\n参考：https://segmentfault.com/a/1190000020237817\n\n\n\n\n参考：https://webpack.js.org/blog/2020-10-10-webpack-5-release/\n","source":"_posts/Webpack5升级指南.md","raw":"---\ntitle: Webpack5升级指南\ndate: 2020-11-5 20:05:50\ntags:\n  - Webpack\n---\n\n> Webpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。\n\n![image](http://img.yanyuanfe.cn/webpack.jpeg)\n\n<!--more-->\nWebpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。\n\n本次重大发布的整体发展方向如下：\n\n- 尝试用持久性缓存来提高构建性能。\n- 尝试用更好的算法和默认值来改进长期缓存。\n- 尝试用更好的 Tree Shaking\n- 和代码生成来改善包大小。\n- 尝试改善与网络平台的兼容性。\n- 尝试在不引入任何破坏性变化的情况下，\n- 清理那些在实现 v4 功能时处于奇怪状态的内部结构。\n- 试图通过现在引入突破性的变化来为未来的功能做准备，\n- 尽可能长时间地保持在 v5 版本上。\n\n为了尝试新特性带来的变化，我对一些自己的开源项目进行了依赖升级，本文将对我升级过程中的一些问题的总结。\n\n### 使用npm-check-updates进行依赖升级\n\nnpm-check-updates 插件会自动检查package.json里的最新版本，并进行批量升级。\n\n```\nnpm install -g npm-check-updates\n\n```\n\n\n```\nncu\n```\nncu命令会自动检查package.json中的依赖的最新版本，并列出可升级依赖。\n\n\n```\nncu -u\n```\n运行此命令可对package.json中的依赖版本进行批量更新至最新版本号。\n\n然后运行yarn或者npm install安装最新版本。\n\n### Typescript 类型\n\nWebpack4使用@types/webpack来进行类型检查， Webpack 5 从源码中生成 typescript 类型文件。\n\n修改：\n\n\n```\nyarn remove @types/webpack\n```\n\n\n### webpack-cli\n\nwebpack4.x的启动项目和build命令使用：\n\n\n```\n\"scripts\": {\n    \"start\": \"webpack-dev-server --config ./config/webpack.config.dev.ts --progress --colors\",\n    \"build\": \"webpack-cli --config ./config/webpack.config.prod.ts --progress --colors\"\n  },\n```\n\n运行npm start，出现如下报错：\n\n\n```\nError: Cannot find module 'webpack-cli/bin/config-yargs' \n```\n对应issue：https://github.com/webpack/webpack-dev-server/issues/2424\n\nV5后，使用webpack-cli/serve来代替webpack-dev-server的启动命令：\n\n对应的script修改为：\n\n\n```\n\"scripts\": {\n    \"start\": \"webpack-cli serve --config ./config/webpack.config.dev.ts\",\n    \"build\": \"webpack-cli --config ./config/webpack.config.prod.ts --progress --colors\"\n  },\n```\n\n### 命令行参数\n\nwebpack-cli在webpack5的版本中删除和新增了一些命令行参数，运行时会出现如下报错：\n\n--colors\n\n\n```\n[webpack-cli] Unknown argument: --colors\n\n```\n以上报错就是--colors参数在v5版本不支持了，需要去掉。\n\n不同版本支持的参数参考官方Github：https://github.com/webpack/webpack-cli/tree/next/packages/webpack-cli#webpack-5\n\n\n### webpack loader\n\n\n使用 query 参数来设置loader的options会在启动webpack时报错如下：\n\n```\n[webpack-cli] Promise rejection: Error: Compiling RuleSet failed: Query arguments on 'loader' has been removed in favor of the 'options' property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])\n[webpack-cli] Error: Compiling RuleSet failed: Query arguments on 'loader' has been removed in favor of the 'options' property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])\n\n```\n\n\n```\n{\n        test: /\\.(png|jpg|jpeg|gif|svg)$/,\n        loader: \"file-loader\",\n        //loader: \"file-loader?name=images/[name].[hash:5].[ext]\",\n        options: {\n          name: 'images/[name].[hash:5].[ext]',\n        },\n      }\n```\n\n### devtool\n\n\n```\nwebpack-cli] Invalid configuration object. Webpack has been initialized using a configuration object that does not match the API schema.\n - configuration.devtool should match pattern \"^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$\".\n   BREAKING CHANGE since webpack 5: The devtool option is more strict.\n   Please strictly follow the order of the keywords in the pattern.\n```\n\n\n\n### 移除Node.js模块的Polyfills\n\nwebpack4及其之前的版本附带了一些node模块的polyfill，如：cypto、buffer、process等，如果你的项目中使用到这些模块，则会自动应用相应的polyfill，V5版本中，移除了这些polyfill，如果需要使用则需要手动添加到配置文件：\n\n\n```\nplugins: [\n    new ProvidePlugin({\n      Buffer: [\"buffer\", \"Buffer\"],\n      process: \"process\",\n    }),\n]\n```\n\n### 使用eslint-webpack-plugin代替eslint-loader\n\neslint-webpack-plugin的出现解决了一些eslint-loader的问题。\neslint-webpack-plugin提供了更好的配置方式，生成报告，直接从eslint使用缓存，仅仅lint修改过的文件。\n\n总的来说，eslint-webpack-plugin更好用，首次启动速度大大提升。\n\n修改：\n\n\n```\nyarn add eslint-webpack-plugin -D\n```\n\n\n```\nconst ESLintPlugin = require('eslint-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [new ESLintPlugin({\n      fix: true,\n      lintDirtyModulesOnly: true,\n    })],\n  // ...\n};\n```\n\n### babel-polyfill\n\n在 Babel > 7.4.0 之前，通常我们会安装 babel-polyfill 或 @babel/polyfill来处理实例方法和ES+新增的内置函数，从Babel 7.4.0开始，不推荐使用此软件包，而通过直接导入core-js / stable（以充实ECMAScript功能）和regenerator-runtime / runtime（需要使用转译的生成器函数）：\n\n\n```\nimport \"core-js/stable\";\nimport \"regenerator-runtime/runtime\";\n```\n\n下面直接介绍transform-runtime的方式：\n\n安装依赖：\n```\nyarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D\nyarn add @babel/runtime-corejs3\n```\n.babelrc配置文件：\n\n```\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false,\n      }\n    ]\n  ],\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-runtime\",\n      {\n        \"corejs\": {\n          \"version\": 3,\n          \"proposals\": true\n        },\n        \"useESModules\": true\n      }\n    ]\n  ]\n}\n```\n\n\n\n参考：https://segmentfault.com/a/1190000020237817\n\n\n\n\n参考：https://webpack.js.org/blog/2020-10-10-webpack-5-release/\n","slug":"Webpack5升级指南","published":1,"updated":"2020-11-25T15:08:14.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennj000qp70vow0hbt43","content":"<blockquote>\n<p>Webpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/webpack.jpeg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>Webpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。</p>\n<p>本次重大发布的整体发展方向如下：</p>\n<ul>\n<li>尝试用持久性缓存来提高构建性能。</li>\n<li>尝试用更好的算法和默认值来改进长期缓存。</li>\n<li>尝试用更好的 Tree Shaking</li>\n<li>和代码生成来改善包大小。</li>\n<li>尝试改善与网络平台的兼容性。</li>\n<li>尝试在不引入任何破坏性变化的情况下，</li>\n<li>清理那些在实现 v4 功能时处于奇怪状态的内部结构。</li>\n<li>试图通过现在引入突破性的变化来为未来的功能做准备，</li>\n<li>尽可能长时间地保持在 v5 版本上。</li>\n</ul>\n<p>为了尝试新特性带来的变化，我对一些自己的开源项目进行了依赖升级，本文将对我升级过程中的一些问题的总结。</p>\n<h3 id=\"使用npm-check-updates进行依赖升级\"><a href=\"#使用npm-check-updates进行依赖升级\" class=\"headerlink\" title=\"使用npm-check-updates进行依赖升级\"></a>使用npm-check-updates进行依赖升级</h3><p>npm-check-updates 插件会自动检查package.json里的最新版本，并进行批量升级。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu</span><br></pre></td></tr></table></figure>\n<p>ncu命令会自动检查package.json中的依赖的最新版本，并列出可升级依赖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu -u</span><br></pre></td></tr></table></figure>\n<p>运行此命令可对package.json中的依赖版本进行批量更新至最新版本号。</p>\n<p>然后运行yarn或者npm install安装最新版本。</p>\n<h3 id=\"Typescript-类型\"><a href=\"#Typescript-类型\" class=\"headerlink\" title=\"Typescript 类型\"></a>Typescript 类型</h3><p>Webpack4使用@types/webpack来进行类型检查， Webpack 5 从源码中生成 typescript 类型文件。</p>\n<p>修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn remove @types/webpack</span><br></pre></td></tr></table></figure>\n<h3 id=\"webpack-cli\"><a href=\"#webpack-cli\" class=\"headerlink\" title=\"webpack-cli\"></a>webpack-cli</h3><p>webpack4.x的启动项目和build命令使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;webpack-dev-server --config ./config/webpack.config.dev.ts --progress --colors&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack-cli --config ./config/webpack.config.prod.ts --progress --colors&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>运行npm start，出现如下报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Error: Cannot find module &apos;webpack-cli/bin/config-yargs&apos;</span><br></pre></td></tr></table></figure>\n<p>对应issue：<a href=\"https://github.com/webpack/webpack-dev-server/issues/2424\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/webpack-dev-server/issues/2424</a></p>\n<p>V5后，使用webpack-cli/serve来代替webpack-dev-server的启动命令：</p>\n<p>对应的script修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;webpack-cli serve --config ./config/webpack.config.dev.ts&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack-cli --config ./config/webpack.config.prod.ts --progress --colors&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h3><p>webpack-cli在webpack5的版本中删除和新增了一些命令行参数，运行时会出现如下报错：</p>\n<p>–colors</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[webpack-cli] Unknown argument: --colors</span><br></pre></td></tr></table></figure>\n<p>以上报错就是–colors参数在v5版本不支持了，需要去掉。</p>\n<p>不同版本支持的参数参考官方Github：<a href=\"https://github.com/webpack/webpack-cli/tree/next/packages/webpack-cli#webpack-5\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/webpack-cli/tree/next/packages/webpack-cli#webpack-5</a></p>\n<h3 id=\"webpack-loader\"><a href=\"#webpack-loader\" class=\"headerlink\" title=\"webpack loader\"></a>webpack loader</h3><p>使用 query 参数来设置loader的options会在启动webpack时报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[webpack-cli] Promise rejection: Error: Compiling RuleSet failed: Query arguments on &apos;loader&apos; has been removed in favor of the &apos;options&apos; property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])</span><br><span class=\"line\">[webpack-cli] Error: Compiling RuleSet failed: Query arguments on &apos;loader&apos; has been removed in favor of the &apos;options&apos; property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.(png|jpg|jpeg|gif|svg)$/,</span><br><span class=\"line\">        loader: &quot;file-loader&quot;,</span><br><span class=\"line\">        //loader: &quot;file-loader?name=images/[name].[hash:5].[ext]&quot;,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          name: &apos;images/[name].[hash:5].[ext]&apos;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"devtool\"><a href=\"#devtool\" class=\"headerlink\" title=\"devtool\"></a>devtool</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack-cli] Invalid configuration object. Webpack has been initialized using a configuration object that does not match the API schema.</span><br><span class=\"line\"> - configuration.devtool should match pattern &quot;^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$&quot;.</span><br><span class=\"line\">   BREAKING CHANGE since webpack 5: The devtool option is more strict.</span><br><span class=\"line\">   Please strictly follow the order of the keywords in the pattern.</span><br></pre></td></tr></table></figure>\n<h3 id=\"移除Node-js模块的Polyfills\"><a href=\"#移除Node-js模块的Polyfills\" class=\"headerlink\" title=\"移除Node.js模块的Polyfills\"></a>移除Node.js模块的Polyfills</h3><p>webpack4及其之前的版本附带了一些node模块的polyfill，如：cypto、buffer、process等，如果你的项目中使用到这些模块，则会自动应用相应的polyfill，V5版本中，移除了这些polyfill，如果需要使用则需要手动添加到配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new ProvidePlugin(&#123;</span><br><span class=\"line\">      Buffer: [&quot;buffer&quot;, &quot;Buffer&quot;],</span><br><span class=\"line\">      process: &quot;process&quot;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用eslint-webpack-plugin代替eslint-loader\"><a href=\"#使用eslint-webpack-plugin代替eslint-loader\" class=\"headerlink\" title=\"使用eslint-webpack-plugin代替eslint-loader\"></a>使用eslint-webpack-plugin代替eslint-loader</h3><p>eslint-webpack-plugin的出现解决了一些eslint-loader的问题。<br>eslint-webpack-plugin提供了更好的配置方式，生成报告，直接从eslint使用缓存，仅仅lint修改过的文件。</p>\n<p>总的来说，eslint-webpack-plugin更好用，首次启动速度大大提升。</p>\n<p>修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add eslint-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const ESLintPlugin = require(&apos;eslint-webpack-plugin&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  plugins: [new ESLintPlugin(&#123;</span><br><span class=\"line\">      fix: true,</span><br><span class=\"line\">      lintDirtyModulesOnly: true,</span><br><span class=\"line\">    &#125;)],</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h3><p>在 Babel &gt; 7.4.0 之前，通常我们会安装 babel-polyfill 或 @babel/polyfill来处理实例方法和ES+新增的内置函数，从Babel 7.4.0开始，不推荐使用此软件包，而通过直接导入core-js / stable（以充实ECMAScript功能）和regenerator-runtime / runtime（需要使用转译的生成器函数）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;core-js/stable&quot;;</span><br><span class=\"line\">import &quot;regenerator-runtime/runtime&quot;;</span><br></pre></td></tr></table></figure>\n<p>下面直接介绍transform-runtime的方式：</p>\n<p>安装依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class=\"line\">yarn add @babel/runtime-corejs3</span><br></pre></td></tr></table></figure></p>\n<p>.babelrc配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;corejs&quot;: &#123;</span><br><span class=\"line\">          &quot;version&quot;: 3,</span><br><span class=\"line\">          &quot;proposals&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;useESModules&quot;: true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://segmentfault.com/a/1190000020237817\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000020237817</a></p>\n<p>参考：<a href=\"https://webpack.js.org/blog/2020-10-10-webpack-5-release/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/blog/2020-10-10-webpack-5-release/</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Webpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/webpack.jpeg\" alt=\"image\"></p>","more":"<p>Webpack5最近发布了正式版，带来了很多优化和新功能，前端工程的构建效率将会大大提升，并且，相比于Webpack4，v5的升级也更加平滑，不会有很多破坏性的变更。</p>\n<p>本次重大发布的整体发展方向如下：</p>\n<ul>\n<li>尝试用持久性缓存来提高构建性能。</li>\n<li>尝试用更好的算法和默认值来改进长期缓存。</li>\n<li>尝试用更好的 Tree Shaking</li>\n<li>和代码生成来改善包大小。</li>\n<li>尝试改善与网络平台的兼容性。</li>\n<li>尝试在不引入任何破坏性变化的情况下，</li>\n<li>清理那些在实现 v4 功能时处于奇怪状态的内部结构。</li>\n<li>试图通过现在引入突破性的变化来为未来的功能做准备，</li>\n<li>尽可能长时间地保持在 v5 版本上。</li>\n</ul>\n<p>为了尝试新特性带来的变化，我对一些自己的开源项目进行了依赖升级，本文将对我升级过程中的一些问题的总结。</p>\n<h3 id=\"使用npm-check-updates进行依赖升级\"><a href=\"#使用npm-check-updates进行依赖升级\" class=\"headerlink\" title=\"使用npm-check-updates进行依赖升级\"></a>使用npm-check-updates进行依赖升级</h3><p>npm-check-updates 插件会自动检查package.json里的最新版本，并进行批量升级。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu</span><br></pre></td></tr></table></figure>\n<p>ncu命令会自动检查package.json中的依赖的最新版本，并列出可升级依赖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu -u</span><br></pre></td></tr></table></figure>\n<p>运行此命令可对package.json中的依赖版本进行批量更新至最新版本号。</p>\n<p>然后运行yarn或者npm install安装最新版本。</p>\n<h3 id=\"Typescript-类型\"><a href=\"#Typescript-类型\" class=\"headerlink\" title=\"Typescript 类型\"></a>Typescript 类型</h3><p>Webpack4使用@types/webpack来进行类型检查， Webpack 5 从源码中生成 typescript 类型文件。</p>\n<p>修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn remove @types/webpack</span><br></pre></td></tr></table></figure>\n<h3 id=\"webpack-cli\"><a href=\"#webpack-cli\" class=\"headerlink\" title=\"webpack-cli\"></a>webpack-cli</h3><p>webpack4.x的启动项目和build命令使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;webpack-dev-server --config ./config/webpack.config.dev.ts --progress --colors&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack-cli --config ./config/webpack.config.prod.ts --progress --colors&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>运行npm start，出现如下报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Error: Cannot find module &apos;webpack-cli/bin/config-yargs&apos;</span><br></pre></td></tr></table></figure>\n<p>对应issue：<a href=\"https://github.com/webpack/webpack-dev-server/issues/2424\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/webpack-dev-server/issues/2424</a></p>\n<p>V5后，使用webpack-cli/serve来代替webpack-dev-server的启动命令：</p>\n<p>对应的script修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;webpack-cli serve --config ./config/webpack.config.dev.ts&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack-cli --config ./config/webpack.config.prod.ts --progress --colors&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h3><p>webpack-cli在webpack5的版本中删除和新增了一些命令行参数，运行时会出现如下报错：</p>\n<p>–colors</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[webpack-cli] Unknown argument: --colors</span><br></pre></td></tr></table></figure>\n<p>以上报错就是–colors参数在v5版本不支持了，需要去掉。</p>\n<p>不同版本支持的参数参考官方Github：<a href=\"https://github.com/webpack/webpack-cli/tree/next/packages/webpack-cli#webpack-5\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack/webpack-cli/tree/next/packages/webpack-cli#webpack-5</a></p>\n<h3 id=\"webpack-loader\"><a href=\"#webpack-loader\" class=\"headerlink\" title=\"webpack loader\"></a>webpack loader</h3><p>使用 query 参数来设置loader的options会在启动webpack时报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[webpack-cli] Promise rejection: Error: Compiling RuleSet failed: Query arguments on &apos;loader&apos; has been removed in favor of the &apos;options&apos; property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])</span><br><span class=\"line\">[webpack-cli] Error: Compiling RuleSet failed: Query arguments on &apos;loader&apos; has been removed in favor of the &apos;options&apos; property (at ruleSet[1].rules[5].loader: file-loader?name=images/[name].[hash:5].[ext])</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.(png|jpg|jpeg|gif|svg)$/,</span><br><span class=\"line\">        loader: &quot;file-loader&quot;,</span><br><span class=\"line\">        //loader: &quot;file-loader?name=images/[name].[hash:5].[ext]&quot;,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          name: &apos;images/[name].[hash:5].[ext]&apos;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"devtool\"><a href=\"#devtool\" class=\"headerlink\" title=\"devtool\"></a>devtool</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack-cli] Invalid configuration object. Webpack has been initialized using a configuration object that does not match the API schema.</span><br><span class=\"line\"> - configuration.devtool should match pattern &quot;^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$&quot;.</span><br><span class=\"line\">   BREAKING CHANGE since webpack 5: The devtool option is more strict.</span><br><span class=\"line\">   Please strictly follow the order of the keywords in the pattern.</span><br></pre></td></tr></table></figure>\n<h3 id=\"移除Node-js模块的Polyfills\"><a href=\"#移除Node-js模块的Polyfills\" class=\"headerlink\" title=\"移除Node.js模块的Polyfills\"></a>移除Node.js模块的Polyfills</h3><p>webpack4及其之前的版本附带了一些node模块的polyfill，如：cypto、buffer、process等，如果你的项目中使用到这些模块，则会自动应用相应的polyfill，V5版本中，移除了这些polyfill，如果需要使用则需要手动添加到配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new ProvidePlugin(&#123;</span><br><span class=\"line\">      Buffer: [&quot;buffer&quot;, &quot;Buffer&quot;],</span><br><span class=\"line\">      process: &quot;process&quot;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用eslint-webpack-plugin代替eslint-loader\"><a href=\"#使用eslint-webpack-plugin代替eslint-loader\" class=\"headerlink\" title=\"使用eslint-webpack-plugin代替eslint-loader\"></a>使用eslint-webpack-plugin代替eslint-loader</h3><p>eslint-webpack-plugin的出现解决了一些eslint-loader的问题。<br>eslint-webpack-plugin提供了更好的配置方式，生成报告，直接从eslint使用缓存，仅仅lint修改过的文件。</p>\n<p>总的来说，eslint-webpack-plugin更好用，首次启动速度大大提升。</p>\n<p>修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add eslint-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const ESLintPlugin = require(&apos;eslint-webpack-plugin&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  plugins: [new ESLintPlugin(&#123;</span><br><span class=\"line\">      fix: true,</span><br><span class=\"line\">      lintDirtyModulesOnly: true,</span><br><span class=\"line\">    &#125;)],</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h3><p>在 Babel &gt; 7.4.0 之前，通常我们会安装 babel-polyfill 或 @babel/polyfill来处理实例方法和ES+新增的内置函数，从Babel 7.4.0开始，不推荐使用此软件包，而通过直接导入core-js / stable（以充实ECMAScript功能）和regenerator-runtime / runtime（需要使用转译的生成器函数）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;core-js/stable&quot;;</span><br><span class=\"line\">import &quot;regenerator-runtime/runtime&quot;;</span><br></pre></td></tr></table></figure>\n<p>下面直接介绍transform-runtime的方式：</p>\n<p>安装依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class=\"line\">yarn add @babel/runtime-corejs3</span><br></pre></td></tr></table></figure></p>\n<p>.babelrc配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;modules&quot;: false,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;corejs&quot;: &#123;</span><br><span class=\"line\">          &quot;version&quot;: 3,</span><br><span class=\"line\">          &quot;proposals&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;useESModules&quot;: true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://segmentfault.com/a/1190000020237817\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000020237817</a></p>\n<p>参考：<a href=\"https://webpack.js.org/blog/2020-10-10-webpack-5-release/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/blog/2020-10-10-webpack-5-release/</a></p>"},{"title":"你不知道的CSS(一)","date":"2016-07-10T09:21:08.000Z","banner":"http://img.yanyuanfe.cn/css%20module.png","_content":"\n\n\n> “像是语言的进化，它让CSS更强大”。                 \n— Nicole Sullivan\n\n![image](http://img.yanyuanfe.cn/css%20module.png)\n\n<!--more-->\n\n\n   CSS（Cascading Style Sheets）指层叠样式表，我相信没有前端开发者不认识它，CSS在网页中负责样式层的展现，它只是网页样式的一种描述方法，不能算是编程语言。因此，众多的开发者都忽视了CSS的能力，认为其太过简单，是一种机械的工作。后来在CSS的发展历程中，出现了越来越高级的应用。比如CSS 3D（硬件加速）、CSS Sprites、媒体查询等等。同时，CSS也在朝着编程语言的方向发展，像LESS、SASS的出现，都表示着，前端开发者再也不能小觑CSS的力量，在某些地方，使用CSS时的性能不输于JavaScript。在这里，我想谈一谈你不知道的CSS，诸如OOCSS、SMACSS、ACSS、BEM。它们是CSS的设计模式，或者叫最佳实践。\n   \n## 一. OOCSS\n\n  OOCSS（Object-Oriented CSS）即为面向对象的CSS，关于什么是面向对象，乔布斯曾经有一句经典的解释：\n    \n>  对象就像人一样，也是活生生的生命。他们有知识，知道怎么完成任务；他们有记忆，可以把发生的事情记下来。你和他们不在低层次上交互，而是像我们现在的对话一样，在一个高度抽象的层面上交互。\n——乔布斯\n\n从这里这里看到，把所有的这些复杂流程都封装在对象内部，对象对外呈现接口，我们通过接口来使用对象，对象的接口是高层次的，抽象的。\n\n这样，你应该对OOCSS有一定的了解了，OOCSS是一种编写CSS代码的方法，它将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。OOCSS的核心思想是使用最简单的方式编写干净整洁的CSS代码，从而使CSS代码具有可重用性、可维护性、可扩展性。其关键在于在页面中识别、创建和模块化可重用的对象，并在页面中其他所有需要的地方重用，并扩展其功能。\n\n**类：**\n\n``` css\n.container{\n    overflow:hidden;\n    _overflow:visible;\n    zoom:1;\n    margin:10px;\n}\n.container .text{\n    display:table-cell;\n    zoom:1;\n}\n.container .img{\n    float:left;\n    margin-right:10px;\n}\n.container .img img{\n    display:block;\n}\n```\n**实例：**\n\n\n``` html\n<div class=\"container\">\n\t<a href=\"\" class=\"img\">\n\t\t<img src=\"myimg.png\" alt=\"\">\n\t</a>\n\t<div class=\"text\">\n\t\tCascading Style Sheets\n\t</div>\n</div>\n```\n\n\n\n\n\n\n总体来讲，使用OOCSS有这些好处：\n1. 加强代码复用以便方便维护。\n2. 减小CSS体积。\n3. 提升渲染效率。\n4. 使用组件库思想、可共用栅格布局、减少选择器、方便扩展。\n\n\n 那么，该如何使用使用面向对象的CSS？下面通过实践来编写OOCSS代码。\n\n#### 1. 不要直接定义子节点，应把共性声明放到父类。\n\n\n\n\n``` css\n\n.container .inner{...}     //container中的子元素\n\n.inner{...}    //不是很建议的声明\n```\n在这个demo里面，container定义了很多共有的属性，如color、font-size，应使用.container .inner定义特性声明。将类的属性（内部的子节点）通过联合定义类的形式（形如 .类名 .属性/子节点{}）进行封装，即子节点必须用对象名作为开头，并可通过给根元素设置多个class来实现继承（class=\"class1 class2\"）。\n\n#### 2. 结构和皮肤相分离。\n\n\n``` html\n<div class=\"container skin\">\n\t<div class=\"inner\">\n\t\t<h3>Text</h3>\n\t</div>\n</div>\n```\n所谓结构和皮肤相分离即是将页面的结构布局和皮肤样式分别又两个class分别控制，在demo里面，container类为控制结构的class，用于控制页面布局结构的样式，如展现元素的位置、浏览器bug和所有比较复杂的问题；skin类为控制皮肤的class，用于控制元素皮肤样式，处理比较简单的问题，如color、border、background等等。\n多个皮肤可以重用一种结构，使得复杂的结构可以被重用，皮肤的修改工作变得很简单。\n\n#### 3. 容器和内容相分离。\n\n\n``` html\n<div class=\"news\">\n\t<h3>今日新闻</h3>\n\t<ul>\n\t\t<li>...</li>\n\t\t....\n\t</ul>\n</div>\n```\n.\n```\n.news ul{}\n.news li{}\n```\n子元素ul依赖了父容器。\n\n\n``` html\n<div class=\"news\">\n\t<h3>今日新闻</h3>\n\t<ul class=\"list\">\n\t\t<li>...</li>\n\t\t....\n\t</ul>\n</div>\n```\n\n``` css\n.news{}\n.news .list{}\n```\n子元素list解除了与容器相关的依赖关系，便于重用，子元素可以从一个容器转移到任意容器。以此将容器和内容独立出来。\n\n#### 4. 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\n\n做一个页面就像建造一座房子一样，造房子之前我们先将房子的每一部分造好，然后一点一点将各个部分组装起来。每一个部分可看作页面的一个个组件，做页面时，需要什么组件就去组件库里面寻找相应的元素，同时页面的每个组件元素又是可重用的。\n\n#### 5. 向你想要扩展的对象本身增加Class而不是它的父节点\n\n``` html\n<div class=\"modal\">\n\t<div class=\"inner\">\n\t    <h3>...</h3>\n\t\t<p>...</p>\n\t</div>\n\t\n</div>\n```\n\n``` css\n.modal .inner{...}\n\n.modal h3{...} //h3本身就是可重用对象\n```\n\n``` html\n<div class=\"modal\">\n\t<div class=\"inner\">\n        <h3 class=\"list\">...</h3>\n    \t<p>...</p>\n\t</div>\n\t\t\n</div>\n```\n\n``` css\n\n.modal{...}\n.list{...}//如果扩展h3，直接在其本身增加class，而不是通过父节点的层叠来扩展\n```\n在同一个对象内总是使用层叠关系，一个对象内的所有子节点必须用这个对象的class名作为开头，比如：.modal .inner{...}。对象之间可以嵌套，但不要层叠。\n当需要为基础对象扩展其功能的时候，应该根据上下文，通过向父节点增加更多的类名，而不是通过父节点的层叠关系来扩展。\n\n\n#### 6. 对象应保持独立性\n\n\n``` html\n<div class=\"modal\">\n\t<div class=\"mybox\">...</div>\n</div>\n```\n\n\n``` css\n.mybox{...}\n.modal .mybox{...}\n```\n\n``` html\n<div class=\"modal mybox\">\n\t\t...\n</div>\n```\n\n``` css\n.mybox{...}\n.modal{...}\n\n```\n每个对象应该保持其独立性，每个class类名应保持自己的结构，保证自己的功能。自己的问题自己解决，而不是让父母出面。\n\n#### 7. 避免使用ID选择器，权重太高，无法重用。\n\n在CSS选择器的优先级中，ID选择器的权重仅次于内联样式，而且ID选择器在一个页面中只能出现一次，无法进行重用，容易和JS用的id混淆，不便于区分，因此应该避免使用ID选择器。\n\n#### 8. 避免位置相关的样式。\n\n``` css\n#header .linkList{...}\n#footer .linkList{...}\n#header ul{...}\n.news ul{...}\n.weather h3{...}\n.tab h4{...}\n```\n而应该写成\n\n``` css\n.linkList{...}\n.mainNav{...}\n.subNav{...}\nh3,.h3{...}\n```\n当对象的class不能满足其要求时，通过class直接在对象上面进行扩充，避免通过层叠关系来改变对象的显示。\n \n``` css\n#weather h3{color:red;}\n#tab h3{color:blue}\n```\n在这里，由于没有定义全局的h3，所以每一个新的模块里面的h3是没有样式的，开发者必须针对同样的样式写许多的CSS。\n\n\n``` css\nh3{color:black}\n#weather h3{color:red}\n#tab h3{color:blue}\n```\n这里就不一样了，为h3定义了全局的颜色样式，weather和tab重写了默认的h3，而weather和tab里面的h3也无法在外面使用。\n\n\n\n#### 9. 保证选择器相同的权重\n    \n\n``` html\n<div class=\"classA classB\"></div>\n```\n\n``` css\n.classA{color:red;}\n.classB{color:blue;}\n```\n在HTML中，class类名出现的先后顺序与优先级无关，在CSS样式表中的先后顺序与优先级有关。\n\n**推荐写法：**\n\n\n``` html\n<div class=\"media mediaExt attribution\"></div>\n```\n\n``` css\n.media{...}\n.mediaExt{...}\n.attribution{...}\n```\n\n\n``` css\n.modal .hd{...}\n.modalExt .hd{...}\n```\n\n\n而不是\n\n``` css\nhtml body .modal div .hd{...}\n```\n样式表中后出现的覆盖掉前面的，保证选择器有相同的权重。\n\n``` css\n.mod .hd{color:red;_zoom:1;}\n.weather .hd{...}\n```\n\n而不是\n\n\n``` css\n.mod .hd{...}\n.ie .mod .hd{...}\n.weather .hd{...}\n```\n这样是为了有节制地使用hack，不要让hack改变你的权重。\n\n\n\n\n\n\n#### 10. 类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\n\n**Class命名的几个目标：**\n\n简短——每一个字节都很重要，尽可能简短\n\n清晰——根据名称可以很快知道它的功能\n\n语义——对象的外观不重要，重要的是它是什么，它的功能是什么\n\n大众化——过于特殊的名字会减少它的应用场景或导致语义化的class以非语义化的方式使用\n\n使用OOCSS不妨碍HTML标签的语义，在具体的SEO场景中，搜索引擎主要看HTML代码是否语义化。但也在语义和可维护性之间做了权衡。\n\n\n\n\n","source":"_posts/你不知道的CSS-一.md","raw":"---\ntitle: 你不知道的CSS(一)\ndate: 2016-07-10 17:21:08\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/css%20module.png\ntags:\n\t- CSS\n\n\t\n---\n\n\n\n> “像是语言的进化，它让CSS更强大”。                 \n— Nicole Sullivan\n\n![image](http://img.yanyuanfe.cn/css%20module.png)\n\n<!--more-->\n\n\n   CSS（Cascading Style Sheets）指层叠样式表，我相信没有前端开发者不认识它，CSS在网页中负责样式层的展现，它只是网页样式的一种描述方法，不能算是编程语言。因此，众多的开发者都忽视了CSS的能力，认为其太过简单，是一种机械的工作。后来在CSS的发展历程中，出现了越来越高级的应用。比如CSS 3D（硬件加速）、CSS Sprites、媒体查询等等。同时，CSS也在朝着编程语言的方向发展，像LESS、SASS的出现，都表示着，前端开发者再也不能小觑CSS的力量，在某些地方，使用CSS时的性能不输于JavaScript。在这里，我想谈一谈你不知道的CSS，诸如OOCSS、SMACSS、ACSS、BEM。它们是CSS的设计模式，或者叫最佳实践。\n   \n## 一. OOCSS\n\n  OOCSS（Object-Oriented CSS）即为面向对象的CSS，关于什么是面向对象，乔布斯曾经有一句经典的解释：\n    \n>  对象就像人一样，也是活生生的生命。他们有知识，知道怎么完成任务；他们有记忆，可以把发生的事情记下来。你和他们不在低层次上交互，而是像我们现在的对话一样，在一个高度抽象的层面上交互。\n——乔布斯\n\n从这里这里看到，把所有的这些复杂流程都封装在对象内部，对象对外呈现接口，我们通过接口来使用对象，对象的接口是高层次的，抽象的。\n\n这样，你应该对OOCSS有一定的了解了，OOCSS是一种编写CSS代码的方法，它将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。OOCSS的核心思想是使用最简单的方式编写干净整洁的CSS代码，从而使CSS代码具有可重用性、可维护性、可扩展性。其关键在于在页面中识别、创建和模块化可重用的对象，并在页面中其他所有需要的地方重用，并扩展其功能。\n\n**类：**\n\n``` css\n.container{\n    overflow:hidden;\n    _overflow:visible;\n    zoom:1;\n    margin:10px;\n}\n.container .text{\n    display:table-cell;\n    zoom:1;\n}\n.container .img{\n    float:left;\n    margin-right:10px;\n}\n.container .img img{\n    display:block;\n}\n```\n**实例：**\n\n\n``` html\n<div class=\"container\">\n\t<a href=\"\" class=\"img\">\n\t\t<img src=\"myimg.png\" alt=\"\">\n\t</a>\n\t<div class=\"text\">\n\t\tCascading Style Sheets\n\t</div>\n</div>\n```\n\n\n\n\n\n\n总体来讲，使用OOCSS有这些好处：\n1. 加强代码复用以便方便维护。\n2. 减小CSS体积。\n3. 提升渲染效率。\n4. 使用组件库思想、可共用栅格布局、减少选择器、方便扩展。\n\n\n 那么，该如何使用使用面向对象的CSS？下面通过实践来编写OOCSS代码。\n\n#### 1. 不要直接定义子节点，应把共性声明放到父类。\n\n\n\n\n``` css\n\n.container .inner{...}     //container中的子元素\n\n.inner{...}    //不是很建议的声明\n```\n在这个demo里面，container定义了很多共有的属性，如color、font-size，应使用.container .inner定义特性声明。将类的属性（内部的子节点）通过联合定义类的形式（形如 .类名 .属性/子节点{}）进行封装，即子节点必须用对象名作为开头，并可通过给根元素设置多个class来实现继承（class=\"class1 class2\"）。\n\n#### 2. 结构和皮肤相分离。\n\n\n``` html\n<div class=\"container skin\">\n\t<div class=\"inner\">\n\t\t<h3>Text</h3>\n\t</div>\n</div>\n```\n所谓结构和皮肤相分离即是将页面的结构布局和皮肤样式分别又两个class分别控制，在demo里面，container类为控制结构的class，用于控制页面布局结构的样式，如展现元素的位置、浏览器bug和所有比较复杂的问题；skin类为控制皮肤的class，用于控制元素皮肤样式，处理比较简单的问题，如color、border、background等等。\n多个皮肤可以重用一种结构，使得复杂的结构可以被重用，皮肤的修改工作变得很简单。\n\n#### 3. 容器和内容相分离。\n\n\n``` html\n<div class=\"news\">\n\t<h3>今日新闻</h3>\n\t<ul>\n\t\t<li>...</li>\n\t\t....\n\t</ul>\n</div>\n```\n.\n```\n.news ul{}\n.news li{}\n```\n子元素ul依赖了父容器。\n\n\n``` html\n<div class=\"news\">\n\t<h3>今日新闻</h3>\n\t<ul class=\"list\">\n\t\t<li>...</li>\n\t\t....\n\t</ul>\n</div>\n```\n\n``` css\n.news{}\n.news .list{}\n```\n子元素list解除了与容器相关的依赖关系，便于重用，子元素可以从一个容器转移到任意容器。以此将容器和内容独立出来。\n\n#### 4. 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\n\n做一个页面就像建造一座房子一样，造房子之前我们先将房子的每一部分造好，然后一点一点将各个部分组装起来。每一个部分可看作页面的一个个组件，做页面时，需要什么组件就去组件库里面寻找相应的元素，同时页面的每个组件元素又是可重用的。\n\n#### 5. 向你想要扩展的对象本身增加Class而不是它的父节点\n\n``` html\n<div class=\"modal\">\n\t<div class=\"inner\">\n\t    <h3>...</h3>\n\t\t<p>...</p>\n\t</div>\n\t\n</div>\n```\n\n``` css\n.modal .inner{...}\n\n.modal h3{...} //h3本身就是可重用对象\n```\n\n``` html\n<div class=\"modal\">\n\t<div class=\"inner\">\n        <h3 class=\"list\">...</h3>\n    \t<p>...</p>\n\t</div>\n\t\t\n</div>\n```\n\n``` css\n\n.modal{...}\n.list{...}//如果扩展h3，直接在其本身增加class，而不是通过父节点的层叠来扩展\n```\n在同一个对象内总是使用层叠关系，一个对象内的所有子节点必须用这个对象的class名作为开头，比如：.modal .inner{...}。对象之间可以嵌套，但不要层叠。\n当需要为基础对象扩展其功能的时候，应该根据上下文，通过向父节点增加更多的类名，而不是通过父节点的层叠关系来扩展。\n\n\n#### 6. 对象应保持独立性\n\n\n``` html\n<div class=\"modal\">\n\t<div class=\"mybox\">...</div>\n</div>\n```\n\n\n``` css\n.mybox{...}\n.modal .mybox{...}\n```\n\n``` html\n<div class=\"modal mybox\">\n\t\t...\n</div>\n```\n\n``` css\n.mybox{...}\n.modal{...}\n\n```\n每个对象应该保持其独立性，每个class类名应保持自己的结构，保证自己的功能。自己的问题自己解决，而不是让父母出面。\n\n#### 7. 避免使用ID选择器，权重太高，无法重用。\n\n在CSS选择器的优先级中，ID选择器的权重仅次于内联样式，而且ID选择器在一个页面中只能出现一次，无法进行重用，容易和JS用的id混淆，不便于区分，因此应该避免使用ID选择器。\n\n#### 8. 避免位置相关的样式。\n\n``` css\n#header .linkList{...}\n#footer .linkList{...}\n#header ul{...}\n.news ul{...}\n.weather h3{...}\n.tab h4{...}\n```\n而应该写成\n\n``` css\n.linkList{...}\n.mainNav{...}\n.subNav{...}\nh3,.h3{...}\n```\n当对象的class不能满足其要求时，通过class直接在对象上面进行扩充，避免通过层叠关系来改变对象的显示。\n \n``` css\n#weather h3{color:red;}\n#tab h3{color:blue}\n```\n在这里，由于没有定义全局的h3，所以每一个新的模块里面的h3是没有样式的，开发者必须针对同样的样式写许多的CSS。\n\n\n``` css\nh3{color:black}\n#weather h3{color:red}\n#tab h3{color:blue}\n```\n这里就不一样了，为h3定义了全局的颜色样式，weather和tab重写了默认的h3，而weather和tab里面的h3也无法在外面使用。\n\n\n\n#### 9. 保证选择器相同的权重\n    \n\n``` html\n<div class=\"classA classB\"></div>\n```\n\n``` css\n.classA{color:red;}\n.classB{color:blue;}\n```\n在HTML中，class类名出现的先后顺序与优先级无关，在CSS样式表中的先后顺序与优先级有关。\n\n**推荐写法：**\n\n\n``` html\n<div class=\"media mediaExt attribution\"></div>\n```\n\n``` css\n.media{...}\n.mediaExt{...}\n.attribution{...}\n```\n\n\n``` css\n.modal .hd{...}\n.modalExt .hd{...}\n```\n\n\n而不是\n\n``` css\nhtml body .modal div .hd{...}\n```\n样式表中后出现的覆盖掉前面的，保证选择器有相同的权重。\n\n``` css\n.mod .hd{color:red;_zoom:1;}\n.weather .hd{...}\n```\n\n而不是\n\n\n``` css\n.mod .hd{...}\n.ie .mod .hd{...}\n.weather .hd{...}\n```\n这样是为了有节制地使用hack，不要让hack改变你的权重。\n\n\n\n\n\n\n#### 10. 类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\n\n**Class命名的几个目标：**\n\n简短——每一个字节都很重要，尽可能简短\n\n清晰——根据名称可以很快知道它的功能\n\n语义——对象的外观不重要，重要的是它是什么，它的功能是什么\n\n大众化——过于特殊的名字会减少它的应用场景或导致语义化的class以非语义化的方式使用\n\n使用OOCSS不妨碍HTML标签的语义，在具体的SEO场景中，搜索引擎主要看HTML代码是否语义化。但也在语义和可维护性之间做了权衡。\n\n\n\n\n","slug":"你不知道的CSS-一","published":1,"updated":"2020-07-16T13:56:47.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennk000sp70v6j1n2mis","content":"<blockquote>\n<p>“像是语言的进化，它让CSS更强大”。<br>— Nicole Sullivan</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/css%20module.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>   CSS（Cascading Style Sheets）指层叠样式表，我相信没有前端开发者不认识它，CSS在网页中负责样式层的展现，它只是网页样式的一种描述方法，不能算是编程语言。因此，众多的开发者都忽视了CSS的能力，认为其太过简单，是一种机械的工作。后来在CSS的发展历程中，出现了越来越高级的应用。比如CSS 3D（硬件加速）、CSS Sprites、媒体查询等等。同时，CSS也在朝着编程语言的方向发展，像LESS、SASS的出现，都表示着，前端开发者再也不能小觑CSS的力量，在某些地方，使用CSS时的性能不输于JavaScript。在这里，我想谈一谈你不知道的CSS，诸如OOCSS、SMACSS、ACSS、BEM。它们是CSS的设计模式，或者叫最佳实践。</p>\n<h2 id=\"一-OOCSS\"><a href=\"#一-OOCSS\" class=\"headerlink\" title=\"一. OOCSS\"></a>一. OOCSS</h2><p>  OOCSS（Object-Oriented CSS）即为面向对象的CSS，关于什么是面向对象，乔布斯曾经有一句经典的解释：</p>\n<blockquote>\n<p> 对象就像人一样，也是活生生的生命。他们有知识，知道怎么完成任务；他们有记忆，可以把发生的事情记下来。你和他们不在低层次上交互，而是像我们现在的对话一样，在一个高度抽象的层面上交互。<br>——乔布斯</p>\n</blockquote>\n<p>从这里这里看到，把所有的这些复杂流程都封装在对象内部，对象对外呈现接口，我们通过接口来使用对象，对象的接口是高层次的，抽象的。</p>\n<p>这样，你应该对OOCSS有一定的了解了，OOCSS是一种编写CSS代码的方法，它将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。OOCSS的核心思想是使用最简单的方式编写干净整洁的CSS代码，从而使CSS代码具有可重用性、可维护性、可扩展性。其关键在于在页面中识别、创建和模块化可重用的对象，并在页面中其他所有需要的地方重用，并扩展其功能。</p>\n<p><strong>类：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">    <span class=\"attribute\">_overflow</span>:visible;</span><br><span class=\"line\">    <span class=\"attribute\">zoom</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.text</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">zoom</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.img</span> <span class=\"selector-tag\">img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>实例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"myimg.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">\t\tCascading Style Sheets</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>总体来讲，使用OOCSS有这些好处：</p>\n<ol>\n<li>加强代码复用以便方便维护。</li>\n<li>减小CSS体积。</li>\n<li>提升渲染效率。</li>\n<li>使用组件库思想、可共用栅格布局、减少选择器、方便扩展。</li>\n</ol>\n<p> 那么，该如何使用使用面向对象的CSS？下面通过实践来编写OOCSS代码。</p>\n<h4 id=\"1-不要直接定义子节点，应把共性声明放到父类。\"><a href=\"#1-不要直接定义子节点，应把共性声明放到父类。\" class=\"headerlink\" title=\"1. 不要直接定义子节点，应把共性声明放到父类。\"></a>1. 不要直接定义子节点，应把共性声明放到父类。</h4><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.container .inner&#123;...&#125;     //container中的子元素</span><br><span class=\"line\"></span><br><span class=\"line\">.inner&#123;...&#125;    //不是很建议的声明</span><br></pre></td></tr></table></figure>\n<p>在这个demo里面，container定义了很多共有的属性，如color、font-size，应使用.container .inner定义特性声明。将类的属性（内部的子节点）通过联合定义类的形式（形如 .类名 .属性/子节点{}）进行封装，即子节点必须用对象名作为开头，并可通过给根元素设置多个class来实现继承（class=”class1 class2”）。</p>\n<h4 id=\"2-结构和皮肤相分离。\"><a href=\"#2-结构和皮肤相分离。\" class=\"headerlink\" title=\"2. 结构和皮肤相分离。\"></a>2. 结构和皮肤相分离。</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container skin\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Text<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>所谓结构和皮肤相分离即是将页面的结构布局和皮肤样式分别又两个class分别控制，在demo里面，container类为控制结构的class，用于控制页面布局结构的样式，如展现元素的位置、浏览器bug和所有比较复杂的问题；skin类为控制皮肤的class，用于控制元素皮肤样式，处理比较简单的问题，如color、border、background等等。<br>多个皮肤可以重用一种结构，使得复杂的结构可以被重用，皮肤的修改工作变得很简单。</p>\n<h4 id=\"3-容器和内容相分离。\"><a href=\"#3-容器和内容相分离。\" class=\"headerlink\" title=\"3. 容器和内容相分离。\"></a>3. 容器和内容相分离。</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"news\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>今日新闻<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.news ul&#123;&#125;</span><br><span class=\"line\">.news li&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>子元素ul依赖了父容器。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"news\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>今日新闻<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.news</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.news</span> <span class=\"selector-class\">.list</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>子元素list解除了与容器相关的依赖关系，便于重用，子元素可以从一个容器转移到任意容器。以此将容器和内容独立出来。</p>\n<h4 id=\"4-抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\"><a href=\"#4-抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\" class=\"headerlink\" title=\"4. 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\"></a>4. 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。</h4><p>做一个页面就像建造一座房子一样，造房子之前我们先将房子的每一部分造好，然后一点一点将各个部分组装起来。每一个部分可看作页面的一个个组件，做页面时，需要什么组件就去组件库里面寻找相应的元素，同时页面的每个组件元素又是可重用的。</p>\n<h4 id=\"5-向你想要扩展的对象本身增加Class而不是它的父节点\"><a href=\"#5-向你想要扩展的对象本身增加Class而不是它的父节点\" class=\"headerlink\" title=\"5. 向你想要扩展的对象本身增加Class而不是它的父节点\"></a>5. 向你想要扩展的对象本身增加Class而不是它的父节点</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span></span><br><span class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.modal .inner&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.modal h3&#123;...&#125; //h3本身就是可重用对象</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.modal&#123;...&#125;</span><br><span class=\"line\">.list&#123;...&#125;//如果扩展h3，直接在其本身增加class，而不是通过父节点的层叠来扩展</span><br></pre></td></tr></table></figure>\n<p>在同一个对象内总是使用层叠关系，一个对象内的所有子节点必须用这个对象的class名作为开头，比如：.modal .inner{…}。对象之间可以嵌套，但不要层叠。<br>当需要为基础对象扩展其功能的时候，应该根据上下文，通过向父节点增加更多的类名，而不是通过父节点的层叠关系来扩展。</p>\n<h4 id=\"6-对象应保持独立性\"><a href=\"#6-对象应保持独立性\" class=\"headerlink\" title=\"6. 对象应保持独立性\"></a>6. 对象应保持独立性</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mybox\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.mybox&#123;...&#125;</span><br><span class=\"line\">.modal .mybox&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal mybox\"</span>&gt;</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.mybox&#123;...&#125;</span><br><span class=\"line\">.modal&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>每个对象应该保持其独立性，每个class类名应保持自己的结构，保证自己的功能。自己的问题自己解决，而不是让父母出面。</p>\n<h4 id=\"7-避免使用ID选择器，权重太高，无法重用。\"><a href=\"#7-避免使用ID选择器，权重太高，无法重用。\" class=\"headerlink\" title=\"7. 避免使用ID选择器，权重太高，无法重用。\"></a>7. 避免使用ID选择器，权重太高，无法重用。</h4><p>在CSS选择器的优先级中，ID选择器的权重仅次于内联样式，而且ID选择器在一个页面中只能出现一次，无法进行重用，容易和JS用的id混淆，不便于区分，因此应该避免使用ID选择器。</p>\n<h4 id=\"8-避免位置相关的样式。\"><a href=\"#8-避免位置相关的样式。\" class=\"headerlink\" title=\"8. 避免位置相关的样式。\"></a>8. 避免位置相关的样式。</h4><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">#header .linkList&#123;...&#125;</span><br><span class=\"line\">#footer .linkList&#123;...&#125;</span><br><span class=\"line\">#header ul&#123;...&#125;</span><br><span class=\"line\">.news ul&#123;...&#125;</span><br><span class=\"line\">.weather h3&#123;...&#125;</span><br><span class=\"line\">.tab h4&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>而应该写成</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.linkList&#123;...&#125;</span><br><span class=\"line\">.mainNav&#123;...&#125;</span><br><span class=\"line\">.subNav&#123;...&#125;</span><br><span class=\"line\">h3,.h3&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>当对象的class不能满足其要求时，通过class直接在对象上面进行扩充，避免通过层叠关系来改变对象的显示。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#weather</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:red;&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#tab</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:blue&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，由于没有定义全局的h3，所以每一个新的模块里面的h3是没有样式的，开发者必须针对同样的样式写许多的CSS。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:black&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#weather</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:red&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#tab</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:blue&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就不一样了，为h3定义了全局的颜色样式，weather和tab重写了默认的h3，而weather和tab里面的h3也无法在外面使用。</p>\n<h4 id=\"9-保证选择器相同的权重\"><a href=\"#9-保证选择器相同的权重\" class=\"headerlink\" title=\"9. 保证选择器相同的权重\"></a>9. 保证选择器相同的权重</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"classA classB\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.classA</span>&#123;<span class=\"attribute\">color</span>:red;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.classB</span>&#123;<span class=\"attribute\">color</span>:blue;&#125;</span><br></pre></td></tr></table></figure>\n<p>在HTML中，class类名出现的先后顺序与优先级无关，在CSS样式表中的先后顺序与优先级有关。</p>\n<p><strong>推荐写法：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"media mediaExt attribution\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.media&#123;...&#125;</span><br><span class=\"line\">.mediaExt&#123;...&#125;</span><br><span class=\"line\">.attribution&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.modal .hd&#123;...&#125;</span><br><span class=\"line\">.modalExt .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>而不是</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">html body .modal div .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>样式表中后出现的覆盖掉前面的，保证选择器有相同的权重。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.mod</span> <span class=\"selector-class\">.hd</span>&#123;<span class=\"attribute\">color</span>:red;<span class=\"attribute\">_zoom</span>:<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">.weather .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>而不是</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.mod .hd&#123;...&#125;</span><br><span class=\"line\">.ie .mod .hd&#123;...&#125;</span><br><span class=\"line\">.weather .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>这样是为了有节制地使用hack，不要让hack改变你的权重。</p>\n<h4 id=\"10-类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\"><a href=\"#10-类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\" class=\"headerlink\" title=\"10. 类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\"></a>10. 类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化</h4><p><strong>Class命名的几个目标：</strong></p>\n<p>简短——每一个字节都很重要，尽可能简短</p>\n<p>清晰——根据名称可以很快知道它的功能</p>\n<p>语义——对象的外观不重要，重要的是它是什么，它的功能是什么</p>\n<p>大众化——过于特殊的名字会减少它的应用场景或导致语义化的class以非语义化的方式使用</p>\n<p>使用OOCSS不妨碍HTML标签的语义，在具体的SEO场景中，搜索引擎主要看HTML代码是否语义化。但也在语义和可维护性之间做了权衡。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>“像是语言的进化，它让CSS更强大”。<br>— Nicole Sullivan</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/css%20module.png\" alt=\"image\"></p>","more":"<p>   CSS（Cascading Style Sheets）指层叠样式表，我相信没有前端开发者不认识它，CSS在网页中负责样式层的展现，它只是网页样式的一种描述方法，不能算是编程语言。因此，众多的开发者都忽视了CSS的能力，认为其太过简单，是一种机械的工作。后来在CSS的发展历程中，出现了越来越高级的应用。比如CSS 3D（硬件加速）、CSS Sprites、媒体查询等等。同时，CSS也在朝着编程语言的方向发展，像LESS、SASS的出现，都表示着，前端开发者再也不能小觑CSS的力量，在某些地方，使用CSS时的性能不输于JavaScript。在这里，我想谈一谈你不知道的CSS，诸如OOCSS、SMACSS、ACSS、BEM。它们是CSS的设计模式，或者叫最佳实践。</p>\n<h2 id=\"一-OOCSS\"><a href=\"#一-OOCSS\" class=\"headerlink\" title=\"一. OOCSS\"></a>一. OOCSS</h2><p>  OOCSS（Object-Oriented CSS）即为面向对象的CSS，关于什么是面向对象，乔布斯曾经有一句经典的解释：</p>\n<blockquote>\n<p> 对象就像人一样，也是活生生的生命。他们有知识，知道怎么完成任务；他们有记忆，可以把发生的事情记下来。你和他们不在低层次上交互，而是像我们现在的对话一样，在一个高度抽象的层面上交互。<br>——乔布斯</p>\n</blockquote>\n<p>从这里这里看到，把所有的这些复杂流程都封装在对象内部，对象对外呈现接口，我们通过接口来使用对象，对象的接口是高层次的，抽象的。</p>\n<p>这样，你应该对OOCSS有一定的了解了，OOCSS是一种编写CSS代码的方法，它将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。OOCSS的核心思想是使用最简单的方式编写干净整洁的CSS代码，从而使CSS代码具有可重用性、可维护性、可扩展性。其关键在于在页面中识别、创建和模块化可重用的对象，并在页面中其他所有需要的地方重用，并扩展其功能。</p>\n<p><strong>类：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">    <span class=\"attribute\">_overflow</span>:visible;</span><br><span class=\"line\">    <span class=\"attribute\">zoom</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.text</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">zoom</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.container</span> <span class=\"selector-class\">.img</span> <span class=\"selector-tag\">img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>实例：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"myimg.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">\t\tCascading Style Sheets</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>总体来讲，使用OOCSS有这些好处：</p>\n<ol>\n<li>加强代码复用以便方便维护。</li>\n<li>减小CSS体积。</li>\n<li>提升渲染效率。</li>\n<li>使用组件库思想、可共用栅格布局、减少选择器、方便扩展。</li>\n</ol>\n<p> 那么，该如何使用使用面向对象的CSS？下面通过实践来编写OOCSS代码。</p>\n<h4 id=\"1-不要直接定义子节点，应把共性声明放到父类。\"><a href=\"#1-不要直接定义子节点，应把共性声明放到父类。\" class=\"headerlink\" title=\"1. 不要直接定义子节点，应把共性声明放到父类。\"></a>1. 不要直接定义子节点，应把共性声明放到父类。</h4><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.container .inner&#123;...&#125;     //container中的子元素</span><br><span class=\"line\"></span><br><span class=\"line\">.inner&#123;...&#125;    //不是很建议的声明</span><br></pre></td></tr></table></figure>\n<p>在这个demo里面，container定义了很多共有的属性，如color、font-size，应使用.container .inner定义特性声明。将类的属性（内部的子节点）通过联合定义类的形式（形如 .类名 .属性/子节点{}）进行封装，即子节点必须用对象名作为开头，并可通过给根元素设置多个class来实现继承（class=”class1 class2”）。</p>\n<h4 id=\"2-结构和皮肤相分离。\"><a href=\"#2-结构和皮肤相分离。\" class=\"headerlink\" title=\"2. 结构和皮肤相分离。\"></a>2. 结构和皮肤相分离。</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container skin\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Text<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>所谓结构和皮肤相分离即是将页面的结构布局和皮肤样式分别又两个class分别控制，在demo里面，container类为控制结构的class，用于控制页面布局结构的样式，如展现元素的位置、浏览器bug和所有比较复杂的问题；skin类为控制皮肤的class，用于控制元素皮肤样式，处理比较简单的问题，如color、border、background等等。<br>多个皮肤可以重用一种结构，使得复杂的结构可以被重用，皮肤的修改工作变得很简单。</p>\n<h4 id=\"3-容器和内容相分离。\"><a href=\"#3-容器和内容相分离。\" class=\"headerlink\" title=\"3. 容器和内容相分离。\"></a>3. 容器和内容相分离。</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"news\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>今日新闻<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.news ul&#123;&#125;</span><br><span class=\"line\">.news li&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>子元素ul依赖了父容器。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"news\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>今日新闻<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.news</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.news</span> <span class=\"selector-class\">.list</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>子元素list解除了与容器相关的依赖关系，便于重用，子元素可以从一个容器转移到任意容器。以此将容器和内容独立出来。</p>\n<h4 id=\"4-抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\"><a href=\"#4-抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\" class=\"headerlink\" title=\"4. 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。\"></a>4. 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。</h4><p>做一个页面就像建造一座房子一样，造房子之前我们先将房子的每一部分造好，然后一点一点将各个部分组装起来。每一个部分可看作页面的一个个组件，做页面时，需要什么组件就去组件库里面寻找相应的元素，同时页面的每个组件元素又是可重用的。</p>\n<h4 id=\"5-向你想要扩展的对象本身增加Class而不是它的父节点\"><a href=\"#5-向你想要扩展的对象本身增加Class而不是它的父节点\" class=\"headerlink\" title=\"5. 向你想要扩展的对象本身增加Class而不是它的父节点\"></a>5. 向你想要扩展的对象本身增加Class而不是它的父节点</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span></span><br><span class=\"line\">\t    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.modal .inner&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.modal h3&#123;...&#125; //h3本身就是可重用对象</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.modal&#123;...&#125;</span><br><span class=\"line\">.list&#123;...&#125;//如果扩展h3，直接在其本身增加class，而不是通过父节点的层叠来扩展</span><br></pre></td></tr></table></figure>\n<p>在同一个对象内总是使用层叠关系，一个对象内的所有子节点必须用这个对象的class名作为开头，比如：.modal .inner{…}。对象之间可以嵌套，但不要层叠。<br>当需要为基础对象扩展其功能的时候，应该根据上下文，通过向父节点增加更多的类名，而不是通过父节点的层叠关系来扩展。</p>\n<h4 id=\"6-对象应保持独立性\"><a href=\"#6-对象应保持独立性\" class=\"headerlink\" title=\"6. 对象应保持独立性\"></a>6. 对象应保持独立性</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mybox\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.mybox&#123;...&#125;</span><br><span class=\"line\">.modal .mybox&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"modal mybox\"</span>&gt;</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.mybox&#123;...&#125;</span><br><span class=\"line\">.modal&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>每个对象应该保持其独立性，每个class类名应保持自己的结构，保证自己的功能。自己的问题自己解决，而不是让父母出面。</p>\n<h4 id=\"7-避免使用ID选择器，权重太高，无法重用。\"><a href=\"#7-避免使用ID选择器，权重太高，无法重用。\" class=\"headerlink\" title=\"7. 避免使用ID选择器，权重太高，无法重用。\"></a>7. 避免使用ID选择器，权重太高，无法重用。</h4><p>在CSS选择器的优先级中，ID选择器的权重仅次于内联样式，而且ID选择器在一个页面中只能出现一次，无法进行重用，容易和JS用的id混淆，不便于区分，因此应该避免使用ID选择器。</p>\n<h4 id=\"8-避免位置相关的样式。\"><a href=\"#8-避免位置相关的样式。\" class=\"headerlink\" title=\"8. 避免位置相关的样式。\"></a>8. 避免位置相关的样式。</h4><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">#header .linkList&#123;...&#125;</span><br><span class=\"line\">#footer .linkList&#123;...&#125;</span><br><span class=\"line\">#header ul&#123;...&#125;</span><br><span class=\"line\">.news ul&#123;...&#125;</span><br><span class=\"line\">.weather h3&#123;...&#125;</span><br><span class=\"line\">.tab h4&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>而应该写成</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.linkList&#123;...&#125;</span><br><span class=\"line\">.mainNav&#123;...&#125;</span><br><span class=\"line\">.subNav&#123;...&#125;</span><br><span class=\"line\">h3,.h3&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>当对象的class不能满足其要求时，通过class直接在对象上面进行扩充，避免通过层叠关系来改变对象的显示。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#weather</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:red;&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#tab</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:blue&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，由于没有定义全局的h3，所以每一个新的模块里面的h3是没有样式的，开发者必须针对同样的样式写许多的CSS。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:black&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#weather</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:red&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#tab</span> <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:blue&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就不一样了，为h3定义了全局的颜色样式，weather和tab重写了默认的h3，而weather和tab里面的h3也无法在外面使用。</p>\n<h4 id=\"9-保证选择器相同的权重\"><a href=\"#9-保证选择器相同的权重\" class=\"headerlink\" title=\"9. 保证选择器相同的权重\"></a>9. 保证选择器相同的权重</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"classA classB\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.classA</span>&#123;<span class=\"attribute\">color</span>:red;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.classB</span>&#123;<span class=\"attribute\">color</span>:blue;&#125;</span><br></pre></td></tr></table></figure>\n<p>在HTML中，class类名出现的先后顺序与优先级无关，在CSS样式表中的先后顺序与优先级有关。</p>\n<p><strong>推荐写法：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"media mediaExt attribution\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.media&#123;...&#125;</span><br><span class=\"line\">.mediaExt&#123;...&#125;</span><br><span class=\"line\">.attribution&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.modal .hd&#123;...&#125;</span><br><span class=\"line\">.modalExt .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>而不是</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">html body .modal div .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>样式表中后出现的覆盖掉前面的，保证选择器有相同的权重。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.mod</span> <span class=\"selector-class\">.hd</span>&#123;<span class=\"attribute\">color</span>:red;<span class=\"attribute\">_zoom</span>:<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">.weather .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>而不是</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">.mod .hd&#123;...&#125;</span><br><span class=\"line\">.ie .mod .hd&#123;...&#125;</span><br><span class=\"line\">.weather .hd&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>这样是为了有节制地使用hack，不要让hack改变你的权重。</p>\n<h4 id=\"10-类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\"><a href=\"#10-类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\" class=\"headerlink\" title=\"10. 类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化\"></a>10. 类名要简短、清晰、语义化，OOCSS的名字并不影响HTML的语义化</h4><p><strong>Class命名的几个目标：</strong></p>\n<p>简短——每一个字节都很重要，尽可能简短</p>\n<p>清晰——根据名称可以很快知道它的功能</p>\n<p>语义——对象的外观不重要，重要的是它是什么，它的功能是什么</p>\n<p>大众化——过于特殊的名字会减少它的应用场景或导致语义化的class以非语义化的方式使用</p>\n<p>使用OOCSS不妨碍HTML标签的语义，在具体的SEO场景中，搜索引擎主要看HTML代码是否语义化。但也在语义和可维护性之间做了权衡。</p>"},{"title":"使用webpack4和react-router 4实现代码分割","date":"2018-03-30T06:05:16.000Z","banner":"http://img.yanyuanfe.cn/photo-1416339442236-8ceb164046f8.jpeg","_content":"\n> Webpack的Code Splitting特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。\n\n![image](http://img.yanyuanfe.cn/banner_1025.jpg)\n\n<!--more-->\n\n### 什么是代码分割（code splitting）\n我们知道，在使用webpack打包react应用时，webpack将整个应用打包成一个js文件，当用户访问首屏时，会一次性加载整个js文件，这就造成了首屏渲染速度变慢的问题。于是，webpack开发了代码分割的特性，\n此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。\n有三种常用的代码分离方法：\n* 入口起点：使用 entry 配置手动地分离代码。\n* 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。\n* 动态导入：通过模块的内联函数调用来分离代码。\n本文只讨论动态导入（dynamic imports）的方法。\n\n### 动态导入\n当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。让我们先尝试使用第一种……\n\n> 注意：import() 调用会在内部用到 promises。如果在旧有版本浏览器中使用 import()，记得使用 一个 polyfill 库（例如 es6-promise 或 promise-polyfill），来 shim Promise。\n\n下面结合react-router 4来实现react的代码分割。\n\n### react code splitting and lazy load\n在使用react-router4进行代码分割的路上，社区已经有成熟的第三方库进行了实现，如react-loadable。在此处将介绍如何不借助第三方库实现代码分割。\n\n此处我们假设你已经对react、react-router4、webpack有基本的了解，可以搭建简单的开发环境。下面先看一下我搭建的项目入口文件。\n\nsrc下index.js：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(<App />, document.getElementById('app'));\nsrc下App.js。\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Route, Switch, BrowserRouter } from 'react-router-dom';\nimport Routes from './routes';\n\n\n\n\nexport default () => (\n  <BrowserRouter>\n    <Switch>\n      {\n        Routes.map(({name, path, exact = true, component }) => (\n          <Route path={path} exact={exact} component={component} key={name} />\n        ))\n      }\n    </Switch>\n  </BrowserRouter>\n)\n```\n\n在App.js中，使用了react-router-dom来做路由，routes.js文件作为路由配置文件，下面使用路由配置遍历生成路由组件。\n下面来看一下路由配置routes.js。\n\n``` js\nimport AsyncComponent from './components/acync-component';\n\nexport default [\n  {\n    name: '首页',\n    icon: 'home',\n    path: '/',\n    component: AsyncComponent(() => import('./containers/home'))\n  },\n  {\n    name: '详情',\n    icon: 'detail',\n    path: '/detail',\n    component: AsyncComponent(() => import('./containers/detail'))\n  }\n]\n```\n\nroutes.js中配置了路由组件需要的参数，需要注意的是在路由参数中使用了异步组件AsyncComponent，注意这里并没有进行组件的引入，而是传给了AsyncComponent一个函数，它将在 *AsyncComponent（() => import('./containers/home')）* 组件被创建时进行动态引入。同时，这种传入一个函数作为参数，而非直接传入一个字符串的写法能够让 webpack意识到此处需要进行代码分割。\n\n使用import（）需要使用像 Babel预处理器和Syntax Dynamic Import Babel Plugin。由于 import() 会返回一个 promise，因此它可以和 async 函数一起使用，使用acync函数需要使用babel-plugin-transform-runtime。\n\n安装babel插件：\n\n\n``` bash\nnpm i -D babel-plugin-syntax-dynamic-import babel-plugin-transform-runtime\n```\n\n\n本项目使用的其他babel插件还有\nbabel-core、babel-loader、babel-preset-env、babel-preset-react等，主要用于jsx编译\n配置.babelrc\n根目录下新建.babelrc，配置如下：\n\n```\n{\n  \"presets\":[\"react\",\"env\"],\n  \"plugins\": [\"syntax-dynamic-import\", \"transform-runtime\"]\n}\n```\n\n### 异步组件AsyncComponent\n本项目的AsyncComponent放在src/components/async-component/index.js中，代码如下：\n\n``` js\nimport React, { Component } from 'react';\n\nexport default (loadComponent, placeholder = '拼命加载中。。。。') => {\n  return class AsyncComponent extends Component {\n    \n\n    constructor() {\n      super();\n\n      this.state = {\n        Child: null\n      }\n\n      this.unmount = false;\n    }\n\n    componentWillUnmount() {\n      this.unmount = true;\n    }\n\n    async componentDidMount() {\n      const { default: Child } = await loadComponent();\n\n      if (this.unmount) return;\n\n      this.setState({\n        Child\n      })\n    }\n\n    render() {\n      const { Child } = this.state;\n\n      return (\n        Child ? <Child {...this.props} /> : placeholder\n      )\n    }\n  }\n}\n```\n\n首先，这是一个高阶组件，返回一个新的组件，传入两个参数，一个是需要动态加载组件的方法，第二个是动态加载时的占位符，也可以传入一个Loading组件。\n\n在返回的AsyncComponent内部，constructor中，初始化一个state为Child，值为null，并定义this.unmount =false，用于表示组件是否被卸载。\n\n使用acync定义异步方法，componentDidMount中，使用await异步执行传入的第一个参数，用于动态加载当前路由的组件。\n\n> 注意：\n注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。\n\n故此处使用ES6的对象解构获取到模块的default并赋值到Child上。\n然后判断组件被卸载的状态，被卸载即返回。\n下面将Child设置到state上。\n在render方法中，从state中获取Child，然后使用三元运算符判断Child是否为true，为true则渲染Child组件，并注入this.props，否则渲染占位符。\n组件componentWillUnmount时，设置this.unmout为true。\n\n### 测试验证\n在containers中新建两个文件夹home和detail，在两个文件夹下编写index.js作为两个路由组件。代码如下：\nhome/index.js：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Link } from 'react-router-dom';\nimport '../../style.css';\nimport icon from '../../assets/404.png';\n\n\nexport default class Home extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>hello webpack</h1>\n        <img src={icon} alt=\"\"/>\n        <Link to=\"/detail\">详情</Link>\n      </div>\n    )\n  }\n}\n```\n\n\ndetail/index.js：\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport '../../style.css';\nimport icon from '../../assets/404.png';\n\nexport default class Detail extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>hello webpack detail</h1>\n        <img src={icon} alt=\"\"/>\n      </div>\n    )\n  }\n}\n```\n\n\n在根目录下package.json配置启动脚本：\n\n``` js\n\"scripts\": {\n    \"start\": \"webpack-dev-server --mode development\",\n    \"build\": \"webpack --mode production\"\n  },\n```\n\n\n然后运行npm start启动项目：\n打开浏览器访问localhost：8080\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_217.png)\n\n可以看到页面先加载了main.js和0.js，点击详情按钮跳转到http://localhost:8080/detail。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_218.png)\n\n马上加载了1.js，这样就实现了代码分割，每个路由都是动态加载的。提升了首屏渲染速度。","source":"_posts/使用webpack4和react-router 4实现代码分割.md","raw":"---\ntitle: 使用webpack4和react-router 4实现代码分割\ndate: 2018-03-30 14:05:16\nbanner: http://img.yanyuanfe.cn/photo-1416339442236-8ceb164046f8.jpeg\ntags:\n- React\n- react-router\n- Webpack\n---\n\n> Webpack的Code Splitting特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。\n\n![image](http://img.yanyuanfe.cn/banner_1025.jpg)\n\n<!--more-->\n\n### 什么是代码分割（code splitting）\n我们知道，在使用webpack打包react应用时，webpack将整个应用打包成一个js文件，当用户访问首屏时，会一次性加载整个js文件，这就造成了首屏渲染速度变慢的问题。于是，webpack开发了代码分割的特性，\n此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。\n有三种常用的代码分离方法：\n* 入口起点：使用 entry 配置手动地分离代码。\n* 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。\n* 动态导入：通过模块的内联函数调用来分离代码。\n本文只讨论动态导入（dynamic imports）的方法。\n\n### 动态导入\n当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。让我们先尝试使用第一种……\n\n> 注意：import() 调用会在内部用到 promises。如果在旧有版本浏览器中使用 import()，记得使用 一个 polyfill 库（例如 es6-promise 或 promise-polyfill），来 shim Promise。\n\n下面结合react-router 4来实现react的代码分割。\n\n### react code splitting and lazy load\n在使用react-router4进行代码分割的路上，社区已经有成熟的第三方库进行了实现，如react-loadable。在此处将介绍如何不借助第三方库实现代码分割。\n\n此处我们假设你已经对react、react-router4、webpack有基本的了解，可以搭建简单的开发环境。下面先看一下我搭建的项目入口文件。\n\nsrc下index.js：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(<App />, document.getElementById('app'));\nsrc下App.js。\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Route, Switch, BrowserRouter } from 'react-router-dom';\nimport Routes from './routes';\n\n\n\n\nexport default () => (\n  <BrowserRouter>\n    <Switch>\n      {\n        Routes.map(({name, path, exact = true, component }) => (\n          <Route path={path} exact={exact} component={component} key={name} />\n        ))\n      }\n    </Switch>\n  </BrowserRouter>\n)\n```\n\n在App.js中，使用了react-router-dom来做路由，routes.js文件作为路由配置文件，下面使用路由配置遍历生成路由组件。\n下面来看一下路由配置routes.js。\n\n``` js\nimport AsyncComponent from './components/acync-component';\n\nexport default [\n  {\n    name: '首页',\n    icon: 'home',\n    path: '/',\n    component: AsyncComponent(() => import('./containers/home'))\n  },\n  {\n    name: '详情',\n    icon: 'detail',\n    path: '/detail',\n    component: AsyncComponent(() => import('./containers/detail'))\n  }\n]\n```\n\nroutes.js中配置了路由组件需要的参数，需要注意的是在路由参数中使用了异步组件AsyncComponent，注意这里并没有进行组件的引入，而是传给了AsyncComponent一个函数，它将在 *AsyncComponent（() => import('./containers/home')）* 组件被创建时进行动态引入。同时，这种传入一个函数作为参数，而非直接传入一个字符串的写法能够让 webpack意识到此处需要进行代码分割。\n\n使用import（）需要使用像 Babel预处理器和Syntax Dynamic Import Babel Plugin。由于 import() 会返回一个 promise，因此它可以和 async 函数一起使用，使用acync函数需要使用babel-plugin-transform-runtime。\n\n安装babel插件：\n\n\n``` bash\nnpm i -D babel-plugin-syntax-dynamic-import babel-plugin-transform-runtime\n```\n\n\n本项目使用的其他babel插件还有\nbabel-core、babel-loader、babel-preset-env、babel-preset-react等，主要用于jsx编译\n配置.babelrc\n根目录下新建.babelrc，配置如下：\n\n```\n{\n  \"presets\":[\"react\",\"env\"],\n  \"plugins\": [\"syntax-dynamic-import\", \"transform-runtime\"]\n}\n```\n\n### 异步组件AsyncComponent\n本项目的AsyncComponent放在src/components/async-component/index.js中，代码如下：\n\n``` js\nimport React, { Component } from 'react';\n\nexport default (loadComponent, placeholder = '拼命加载中。。。。') => {\n  return class AsyncComponent extends Component {\n    \n\n    constructor() {\n      super();\n\n      this.state = {\n        Child: null\n      }\n\n      this.unmount = false;\n    }\n\n    componentWillUnmount() {\n      this.unmount = true;\n    }\n\n    async componentDidMount() {\n      const { default: Child } = await loadComponent();\n\n      if (this.unmount) return;\n\n      this.setState({\n        Child\n      })\n    }\n\n    render() {\n      const { Child } = this.state;\n\n      return (\n        Child ? <Child {...this.props} /> : placeholder\n      )\n    }\n  }\n}\n```\n\n首先，这是一个高阶组件，返回一个新的组件，传入两个参数，一个是需要动态加载组件的方法，第二个是动态加载时的占位符，也可以传入一个Loading组件。\n\n在返回的AsyncComponent内部，constructor中，初始化一个state为Child，值为null，并定义this.unmount =false，用于表示组件是否被卸载。\n\n使用acync定义异步方法，componentDidMount中，使用await异步执行传入的第一个参数，用于动态加载当前路由的组件。\n\n> 注意：\n注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。\n\n故此处使用ES6的对象解构获取到模块的default并赋值到Child上。\n然后判断组件被卸载的状态，被卸载即返回。\n下面将Child设置到state上。\n在render方法中，从state中获取Child，然后使用三元运算符判断Child是否为true，为true则渲染Child组件，并注入this.props，否则渲染占位符。\n组件componentWillUnmount时，设置this.unmout为true。\n\n### 测试验证\n在containers中新建两个文件夹home和detail，在两个文件夹下编写index.js作为两个路由组件。代码如下：\nhome/index.js：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Link } from 'react-router-dom';\nimport '../../style.css';\nimport icon from '../../assets/404.png';\n\n\nexport default class Home extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>hello webpack</h1>\n        <img src={icon} alt=\"\"/>\n        <Link to=\"/detail\">详情</Link>\n      </div>\n    )\n  }\n}\n```\n\n\ndetail/index.js：\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport '../../style.css';\nimport icon from '../../assets/404.png';\n\nexport default class Detail extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>hello webpack detail</h1>\n        <img src={icon} alt=\"\"/>\n      </div>\n    )\n  }\n}\n```\n\n\n在根目录下package.json配置启动脚本：\n\n``` js\n\"scripts\": {\n    \"start\": \"webpack-dev-server --mode development\",\n    \"build\": \"webpack --mode production\"\n  },\n```\n\n\n然后运行npm start启动项目：\n打开浏览器访问localhost：8080\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_217.png)\n\n可以看到页面先加载了main.js和0.js，点击详情按钮跳转到http://localhost:8080/detail。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_218.png)\n\n马上加载了1.js，这样就实现了代码分割，每个路由都是动态加载的。提升了首屏渲染速度。","slug":"使用webpack4和react-router 4实现代码分割","published":1,"updated":"2020-07-16T13:56:47.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennl000up70vjy59qj23","content":"<blockquote>\n<p>Webpack的Code Splitting特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/banner_1025.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"什么是代码分割（code-splitting）\"><a href=\"#什么是代码分割（code-splitting）\" class=\"headerlink\" title=\"什么是代码分割（code splitting）\"></a>什么是代码分割（code splitting）</h3><p>我们知道，在使用webpack打包react应用时，webpack将整个应用打包成一个js文件，当用户访问首屏时，会一次性加载整个js文件，这就造成了首屏渲染速度变慢的问题。于是，webpack开发了代码分割的特性，<br>此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。<br>有三种常用的代码分离方法：</p>\n<ul>\n<li>入口起点：使用 entry 配置手动地分离代码。</li>\n<li>防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。</li>\n<li>动态导入：通过模块的内联函数调用来分离代码。<br>本文只讨论动态导入（dynamic imports）的方法。</li>\n</ul>\n<h3 id=\"动态导入\"><a href=\"#动态导入\" class=\"headerlink\" title=\"动态导入\"></a>动态导入</h3><p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。让我们先尝试使用第一种……</p>\n<blockquote>\n<p>注意：import() 调用会在内部用到 promises。如果在旧有版本浏览器中使用 import()，记得使用 一个 polyfill 库（例如 es6-promise 或 promise-polyfill），来 shim Promise。</p>\n</blockquote>\n<p>下面结合react-router 4来实现react的代码分割。</p>\n<h3 id=\"react-code-splitting-and-lazy-load\"><a href=\"#react-code-splitting-and-lazy-load\" class=\"headerlink\" title=\"react code splitting and lazy load\"></a>react code splitting and lazy load</h3><p>在使用react-router4进行代码分割的路上，社区已经有成熟的第三方库进行了实现，如react-loadable。在此处将介绍如何不借助第三方库实现代码分割。</p>\n<p>此处我们假设你已经对react、react-router4、webpack有基本的了解，可以搭建简单的开发环境。下面先看一下我搭建的项目入口文件。</p>\n<p>src下index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>));</span><br><span class=\"line\">src下App.js。</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Route, Switch, BrowserRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Routes <span class=\"keyword\">from</span> <span class=\"string\">'./routes'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; (</span><br><span class=\"line\">  &lt;BrowserRouter&gt;</span><br><span class=\"line\">    &lt;Switch&gt;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        Routes.map(<span class=\"function\">(<span class=\"params\">&#123;name, path, exact = <span class=\"literal\">true</span>, component &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">          &lt;Route path=&#123;path&#125; exact=&#123;exact&#125; component=&#123;component&#125; key=&#123;name&#125; /&gt;</span><br><span class=\"line\">        ))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Switch&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>BrowserRouter&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在App.js中，使用了react-router-dom来做路由，routes.js文件作为路由配置文件，下面使用路由配置遍历生成路由组件。<br>下面来看一下路由配置routes.js。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> AsyncComponent <span class=\"keyword\">from</span> <span class=\"string\">'./components/acync-component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">    icon: <span class=\"string\">'home'</span>,</span><br><span class=\"line\">    path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">    component: AsyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./containers/home'</span>))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'详情'</span>,</span><br><span class=\"line\">    icon: <span class=\"string\">'detail'</span>,</span><br><span class=\"line\">    path: <span class=\"string\">'/detail'</span>,</span><br><span class=\"line\">    component: AsyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./containers/detail'</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>routes.js中配置了路由组件需要的参数，需要注意的是在路由参数中使用了异步组件AsyncComponent，注意这里并没有进行组件的引入，而是传给了AsyncComponent一个函数，它将在 <em>AsyncComponent（() =&gt; import(‘./containers/home’)）</em> 组件被创建时进行动态引入。同时，这种传入一个函数作为参数，而非直接传入一个字符串的写法能够让 webpack意识到此处需要进行代码分割。</p>\n<p>使用import（）需要使用像 Babel预处理器和Syntax Dynamic Import Babel Plugin。由于 import() 会返回一个 promise，因此它可以和 async 函数一起使用，使用acync函数需要使用babel-plugin-transform-runtime。</p>\n<p>安装babel插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -D babel-plugin-syntax-dynamic-import babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure>\n<p>本项目使用的其他babel插件还有<br>babel-core、babel-loader、babel-preset-env、babel-preset-react等，主要用于jsx编译<br>配置.babelrc<br>根目录下新建.babelrc，配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;],</span><br><span class=\"line\">  &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;, &quot;transform-runtime&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"异步组件AsyncComponent\"><a href=\"#异步组件AsyncComponent\" class=\"headerlink\" title=\"异步组件AsyncComponent\"></a>异步组件AsyncComponent</h3><p>本项目的AsyncComponent放在src/components/async-component/index.js中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (loadComponent, placeholder = <span class=\"string\">'拼命加载中。。。。'</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        Child: <span class=\"literal\">null</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.unmount = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.unmount = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; <span class=\"attr\">default</span>: Child &#125; = <span class=\"keyword\">await</span> loadComponent();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.unmount) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        Child</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; Child &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        Child ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span> : placeholder</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，这是一个高阶组件，返回一个新的组件，传入两个参数，一个是需要动态加载组件的方法，第二个是动态加载时的占位符，也可以传入一个Loading组件。</p>\n<p>在返回的AsyncComponent内部，constructor中，初始化一个state为Child，值为null，并定义this.unmount =false，用于表示组件是否被卸载。</p>\n<p>使用acync定义异步方法，componentDidMount中，使用await异步执行传入的第一个参数，用于动态加载当前路由的组件。</p>\n<blockquote>\n<p>注意：<br>注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。</p>\n</blockquote>\n<p>故此处使用ES6的对象解构获取到模块的default并赋值到Child上。<br>然后判断组件被卸载的状态，被卸载即返回。<br>下面将Child设置到state上。<br>在render方法中，从state中获取Child，然后使用三元运算符判断Child是否为true，为true则渲染Child组件，并注入this.props，否则渲染占位符。<br>组件componentWillUnmount时，设置this.unmout为true。</p>\n<h3 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h3><p>在containers中新建两个文件夹home和detail，在两个文件夹下编写index.js作为两个路由组件。代码如下：<br>home/index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'../../style.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> icon <span class=\"keyword\">from</span> <span class=\"string\">'../../assets/404.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;hello webpack&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;img src=&#123;icon&#125; alt=\"\"/</span>&gt;</span><br><span class=\"line\">        &lt;Link to=<span class=\"string\">\"/detail\"</span>&gt;详情&lt;<span class=\"regexp\">/Link&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>detail/index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'../../style.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> icon <span class=\"keyword\">from</span> <span class=\"string\">'../../assets/404.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Detail</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;hello webpack detail&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;img src=&#123;icon&#125; alt=\"\"/</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在根目录下package.json配置启动脚本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack-dev-server --mode development\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack --mode production\"</span></span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>然后运行npm start启动项目：<br>打开浏览器访问localhost：8080</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_217.png\" alt=\"image\"></p>\n<p>可以看到页面先加载了main.js和0.js，点击详情按钮跳转到<a href=\"http://localhost:8080/detail。\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/detail。</a></p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_218.png\" alt=\"image\"></p>\n<p>马上加载了1.js，这样就实现了代码分割，每个路由都是动态加载的。提升了首屏渲染速度。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Webpack的Code Splitting特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/banner_1025.jpg\" alt=\"image\"></p>","more":"<h3 id=\"什么是代码分割（code-splitting）\"><a href=\"#什么是代码分割（code-splitting）\" class=\"headerlink\" title=\"什么是代码分割（code splitting）\"></a>什么是代码分割（code splitting）</h3><p>我们知道，在使用webpack打包react应用时，webpack将整个应用打包成一个js文件，当用户访问首屏时，会一次性加载整个js文件，这就造成了首屏渲染速度变慢的问题。于是，webpack开发了代码分割的特性，<br>此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。<br>有三种常用的代码分离方法：</p>\n<ul>\n<li>入口起点：使用 entry 配置手动地分离代码。</li>\n<li>防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。</li>\n<li>动态导入：通过模块的内联函数调用来分离代码。<br>本文只讨论动态导入（dynamic imports）的方法。</li>\n</ul>\n<h3 id=\"动态导入\"><a href=\"#动态导入\" class=\"headerlink\" title=\"动态导入\"></a>动态导入</h3><p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。让我们先尝试使用第一种……</p>\n<blockquote>\n<p>注意：import() 调用会在内部用到 promises。如果在旧有版本浏览器中使用 import()，记得使用 一个 polyfill 库（例如 es6-promise 或 promise-polyfill），来 shim Promise。</p>\n</blockquote>\n<p>下面结合react-router 4来实现react的代码分割。</p>\n<h3 id=\"react-code-splitting-and-lazy-load\"><a href=\"#react-code-splitting-and-lazy-load\" class=\"headerlink\" title=\"react code splitting and lazy load\"></a>react code splitting and lazy load</h3><p>在使用react-router4进行代码分割的路上，社区已经有成熟的第三方库进行了实现，如react-loadable。在此处将介绍如何不借助第三方库实现代码分割。</p>\n<p>此处我们假设你已经对react、react-router4、webpack有基本的了解，可以搭建简单的开发环境。下面先看一下我搭建的项目入口文件。</p>\n<p>src下index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>));</span><br><span class=\"line\">src下App.js。</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Route, Switch, BrowserRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Routes <span class=\"keyword\">from</span> <span class=\"string\">'./routes'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; (</span><br><span class=\"line\">  &lt;BrowserRouter&gt;</span><br><span class=\"line\">    &lt;Switch&gt;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        Routes.map(<span class=\"function\">(<span class=\"params\">&#123;name, path, exact = <span class=\"literal\">true</span>, component &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">          &lt;Route path=&#123;path&#125; exact=&#123;exact&#125; component=&#123;component&#125; key=&#123;name&#125; /&gt;</span><br><span class=\"line\">        ))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Switch&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>BrowserRouter&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>在App.js中，使用了react-router-dom来做路由，routes.js文件作为路由配置文件，下面使用路由配置遍历生成路由组件。<br>下面来看一下路由配置routes.js。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> AsyncComponent <span class=\"keyword\">from</span> <span class=\"string\">'./components/acync-component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">    icon: <span class=\"string\">'home'</span>,</span><br><span class=\"line\">    path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">    component: AsyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./containers/home'</span>))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'详情'</span>,</span><br><span class=\"line\">    icon: <span class=\"string\">'detail'</span>,</span><br><span class=\"line\">    path: <span class=\"string\">'/detail'</span>,</span><br><span class=\"line\">    component: AsyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./containers/detail'</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>routes.js中配置了路由组件需要的参数，需要注意的是在路由参数中使用了异步组件AsyncComponent，注意这里并没有进行组件的引入，而是传给了AsyncComponent一个函数，它将在 <em>AsyncComponent（() =&gt; import(‘./containers/home’)）</em> 组件被创建时进行动态引入。同时，这种传入一个函数作为参数，而非直接传入一个字符串的写法能够让 webpack意识到此处需要进行代码分割。</p>\n<p>使用import（）需要使用像 Babel预处理器和Syntax Dynamic Import Babel Plugin。由于 import() 会返回一个 promise，因此它可以和 async 函数一起使用，使用acync函数需要使用babel-plugin-transform-runtime。</p>\n<p>安装babel插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -D babel-plugin-syntax-dynamic-import babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure>\n<p>本项目使用的其他babel插件还有<br>babel-core、babel-loader、babel-preset-env、babel-preset-react等，主要用于jsx编译<br>配置.babelrc<br>根目录下新建.babelrc，配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;],</span><br><span class=\"line\">  &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;, &quot;transform-runtime&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"异步组件AsyncComponent\"><a href=\"#异步组件AsyncComponent\" class=\"headerlink\" title=\"异步组件AsyncComponent\"></a>异步组件AsyncComponent</h3><p>本项目的AsyncComponent放在src/components/async-component/index.js中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (loadComponent, placeholder = <span class=\"string\">'拼命加载中。。。。'</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        Child: <span class=\"literal\">null</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.unmount = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.unmount = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; <span class=\"attr\">default</span>: Child &#125; = <span class=\"keyword\">await</span> loadComponent();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.unmount) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        Child</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; Child &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        Child ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span> : placeholder</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，这是一个高阶组件，返回一个新的组件，传入两个参数，一个是需要动态加载组件的方法，第二个是动态加载时的占位符，也可以传入一个Loading组件。</p>\n<p>在返回的AsyncComponent内部，constructor中，初始化一个state为Child，值为null，并定义this.unmount =false，用于表示组件是否被卸载。</p>\n<p>使用acync定义异步方法，componentDidMount中，使用await异步执行传入的第一个参数，用于动态加载当前路由的组件。</p>\n<blockquote>\n<p>注意：<br>注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。</p>\n</blockquote>\n<p>故此处使用ES6的对象解构获取到模块的default并赋值到Child上。<br>然后判断组件被卸载的状态，被卸载即返回。<br>下面将Child设置到state上。<br>在render方法中，从state中获取Child，然后使用三元运算符判断Child是否为true，为true则渲染Child组件，并注入this.props，否则渲染占位符。<br>组件componentWillUnmount时，设置this.unmout为true。</p>\n<h3 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h3><p>在containers中新建两个文件夹home和detail，在两个文件夹下编写index.js作为两个路由组件。代码如下：<br>home/index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'../../style.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> icon <span class=\"keyword\">from</span> <span class=\"string\">'../../assets/404.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;hello webpack&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;img src=&#123;icon&#125; alt=\"\"/</span>&gt;</span><br><span class=\"line\">        &lt;Link to=<span class=\"string\">\"/detail\"</span>&gt;详情&lt;<span class=\"regexp\">/Link&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>detail/index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'../../style.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> icon <span class=\"keyword\">from</span> <span class=\"string\">'../../assets/404.png'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Detail</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;hello webpack detail&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;img src=&#123;icon&#125; alt=\"\"/</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>在根目录下package.json配置启动脚本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack-dev-server --mode development\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack --mode production\"</span></span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>然后运行npm start启动项目：<br>打开浏览器访问localhost：8080</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_217.png\" alt=\"image\"></p>\n<p>可以看到页面先加载了main.js和0.js，点击详情按钮跳转到<a href=\"http://localhost:8080/detail。\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/detail。</a></p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_218.png\" alt=\"image\"></p>\n<p>马上加载了1.js，这样就实现了代码分割，每个路由都是动态加载的。提升了首屏渲染速度。</p>"},{"title":"关于一道字符串格式化面试题的思考","date":"2018-11-16T08:39:11.000Z","banner":"http://img.yanyuanfe.cn/string.jpg","_content":"\n---\n\n> 本文从一道简单的字符串面试题开始，记录字符串的一些方法，关注细节。\n\n![image](http://img.yanyuanfe.cn/string.jpg)\n\n<!--more-->\n\n最近遇到一道面试题，觉得挺有意思，虽然简单缺发人深省。题目大致如下：写一个字符串转成驼峰的方法,例:border.bottom.color->borderBottomColor。\n\n### 操作字符串数组\n\n大部分人应该都能写出这种方法，对字符串进行处理然后拼接成新的字符串。主要考察字符串的几个 API，使用 charAt(n)来取得字符串第 n 个下标的字符，也可以使用数组下标([])来取。\n\n```js\nfunction tranformStr(str) {\n  var strArr = str.split(\".\");\n  for (var i = 1; i < strArr.length; i++) {\n    strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);\n  }\n  return strArr.join(\"\");\n}\n```\n\n## 正则表达式\n\n第二种使用正则来解决，其实算是字符串的 replace 方法和正则的结合，难点主要还是在于 replace 方法的掌握。\n\n```js\nfunction transformStr(str) {\n  var re = /\\.(\\w)/g;\n  return str.replace(re, function(match, p1) {\n    return p1.toUpperCase();\n  });\n}\n```\n\n从以上两种方法可以看出，使用正则的代码量更少，但是对正则的理解和 replace 用法的要求也更高，下面总结一下 replace 这个字符串方法的一些 api。\n\n### replace 使用\n\n```js\nstr.replace(regexp|substr, newSubStr|function)\n```\n\nreplace 方法的第一个参数可以是一个正则或者字符串。\n\n- regexp (pattern)\n\n一个正则表达式（RegExp） 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。\n\n- substr (pattern)\n\n一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。\n\nreplace 方法的第二个参数可以是一个字符串或者函数。\n\n- newSubStr (replacement)\n\n用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。\n\n- function (replacement)\n\n一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。\n\nreplace 方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。\n在进行全局的搜索替换时，正则表达式需包含 g 标志。\n\n### 使用字符串作为参数\n\n当第二个参数是字符串时，替换字符串可以插入下面的特殊变量名：\n\n| 变量名                               | 代表的值                                                                                        |\n| ------------------------------------ | ----------------------------------------------------------------------------------------------- |\n| \\$\\$                                 | 插入一个 \"\\$\"。                                                                                 |\n| \\$&                                  | 插入匹配的子串。                                                                                |\n| \\$` | 插入当前匹配的子串左边的内容。 |\n| \\$'                                  | 插入当前匹配的子串右边的内容。                                                                  |\n| \\$n                                  | 假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。 |\n\n下面是特殊变量名的具体使用：\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$$\");\n// border$ottom$olor\n```\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$&\");\n// border.bottom.color\n```\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$`\");\n// borderborderottomborder.bottomolor\n```\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$1\");\n// borderbottomcolor\n```\n\n### 指定一个函数作为参数\n\n当第二个参数是一个函数时，在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。\n\n| 变量名     | 代表的值                                                                                                         |\n| ---------- | ---------------------------------------------------------------------------------------------------------------- |\n| match      | 匹配的子串。（对应于上述的\\$&。）                                                                                |\n| p1,p2, ... | 假如 replace()方法的第一个参数是一个 RegExp 对象，则代表第 n 个括号匹配的字符串。（对应于上述的$1，$2 等。）     |\n| offset     | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是 1） |\n| string     | 被匹配的原字符串。                                                                                               |\n\n注意：精确的参数个数依赖于 replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。\n\n在文章最开始的题目中，我们需要匹配.后面跟着的第一个字母，并且将其替换为大写字母。具体实现代码如下：\n\n```js\nfunction transformStr(str) {\n  var re = /\\.(\\w)/g;\n  return str.replace(re, function(match, p1) {\n    return p1.toUpperCase();\n  });\n}\n```\n\n首先，声明一个正则 re，匹配一个.后面跟着一个括号，这个括号称为捕获括号，匹配的内容会被记住以供第二个参数使用，捕获括号内的\\w 匹配一个单字字符（字母、数字或者下划线），等价于[A-Za-z0-9]。第二个参数为函数，第一个字符串 match 是每次匹配到的字符串，在上述例子中就是.b 和.c，p1 则对应第一个括号匹配的字符串，对应 b 和 c，在函数内部对 p1 进行大写转换，因为 replace 产生的是一个全新的字符串，所以需要 return 出去。\n","source":"_posts/关于一道字符串格式化面试题的思考.md","raw":"---\ntitle: 关于一道字符串格式化面试题的思考\ndate: 2018-11-16 16:39:11\nbanner: http://img.yanyuanfe.cn/string.jpg\ntags:\n  - JavaScript\n---\n\n---\n\n> 本文从一道简单的字符串面试题开始，记录字符串的一些方法，关注细节。\n\n![image](http://img.yanyuanfe.cn/string.jpg)\n\n<!--more-->\n\n最近遇到一道面试题，觉得挺有意思，虽然简单缺发人深省。题目大致如下：写一个字符串转成驼峰的方法,例:border.bottom.color->borderBottomColor。\n\n### 操作字符串数组\n\n大部分人应该都能写出这种方法，对字符串进行处理然后拼接成新的字符串。主要考察字符串的几个 API，使用 charAt(n)来取得字符串第 n 个下标的字符，也可以使用数组下标([])来取。\n\n```js\nfunction tranformStr(str) {\n  var strArr = str.split(\".\");\n  for (var i = 1; i < strArr.length; i++) {\n    strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);\n  }\n  return strArr.join(\"\");\n}\n```\n\n## 正则表达式\n\n第二种使用正则来解决，其实算是字符串的 replace 方法和正则的结合，难点主要还是在于 replace 方法的掌握。\n\n```js\nfunction transformStr(str) {\n  var re = /\\.(\\w)/g;\n  return str.replace(re, function(match, p1) {\n    return p1.toUpperCase();\n  });\n}\n```\n\n从以上两种方法可以看出，使用正则的代码量更少，但是对正则的理解和 replace 用法的要求也更高，下面总结一下 replace 这个字符串方法的一些 api。\n\n### replace 使用\n\n```js\nstr.replace(regexp|substr, newSubStr|function)\n```\n\nreplace 方法的第一个参数可以是一个正则或者字符串。\n\n- regexp (pattern)\n\n一个正则表达式（RegExp） 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。\n\n- substr (pattern)\n\n一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。\n\nreplace 方法的第二个参数可以是一个字符串或者函数。\n\n- newSubStr (replacement)\n\n用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。\n\n- function (replacement)\n\n一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。\n\nreplace 方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。\n在进行全局的搜索替换时，正则表达式需包含 g 标志。\n\n### 使用字符串作为参数\n\n当第二个参数是字符串时，替换字符串可以插入下面的特殊变量名：\n\n| 变量名                               | 代表的值                                                                                        |\n| ------------------------------------ | ----------------------------------------------------------------------------------------------- |\n| \\$\\$                                 | 插入一个 \"\\$\"。                                                                                 |\n| \\$&                                  | 插入匹配的子串。                                                                                |\n| \\$` | 插入当前匹配的子串左边的内容。 |\n| \\$'                                  | 插入当前匹配的子串右边的内容。                                                                  |\n| \\$n                                  | 假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。 |\n\n下面是特殊变量名的具体使用：\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$$\");\n// border$ottom$olor\n```\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$&\");\n// border.bottom.color\n```\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$`\");\n// borderborderottomborder.bottomolor\n```\n\n```js\n\"border.bottom.color\".replace(/\\.(\\w)/g, \"$1\");\n// borderbottomcolor\n```\n\n### 指定一个函数作为参数\n\n当第二个参数是一个函数时，在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。\n\n| 变量名     | 代表的值                                                                                                         |\n| ---------- | ---------------------------------------------------------------------------------------------------------------- |\n| match      | 匹配的子串。（对应于上述的\\$&。）                                                                                |\n| p1,p2, ... | 假如 replace()方法的第一个参数是一个 RegExp 对象，则代表第 n 个括号匹配的字符串。（对应于上述的$1，$2 等。）     |\n| offset     | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是 1） |\n| string     | 被匹配的原字符串。                                                                                               |\n\n注意：精确的参数个数依赖于 replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。\n\n在文章最开始的题目中，我们需要匹配.后面跟着的第一个字母，并且将其替换为大写字母。具体实现代码如下：\n\n```js\nfunction transformStr(str) {\n  var re = /\\.(\\w)/g;\n  return str.replace(re, function(match, p1) {\n    return p1.toUpperCase();\n  });\n}\n```\n\n首先，声明一个正则 re，匹配一个.后面跟着一个括号，这个括号称为捕获括号，匹配的内容会被记住以供第二个参数使用，捕获括号内的\\w 匹配一个单字字符（字母、数字或者下划线），等价于[A-Za-z0-9]。第二个参数为函数，第一个字符串 match 是每次匹配到的字符串，在上述例子中就是.b 和.c，p1 则对应第一个括号匹配的字符串，对应 b 和 c，在函数内部对 p1 进行大写转换，因为 replace 产生的是一个全新的字符串，所以需要 return 出去。\n","slug":"关于一道字符串格式化面试题的思考","published":1,"updated":"2020-07-16T13:56:47.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennn000wp70vrc9ifsgi","content":"<hr>\n<blockquote>\n<p>本文从一道简单的字符串面试题开始，记录字符串的一些方法，关注细节。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/string.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>最近遇到一道面试题，觉得挺有意思，虽然简单缺发人深省。题目大致如下：写一个字符串转成驼峰的方法,例:border.bottom.color-&gt;borderBottomColor。</p>\n<h3 id=\"操作字符串数组\"><a href=\"#操作字符串数组\" class=\"headerlink\" title=\"操作字符串数组\"></a>操作字符串数组</h3><p>大部分人应该都能写出这种方法，对字符串进行处理然后拼接成新的字符串。主要考察字符串的几个 API，使用 charAt(n)来取得字符串第 n 个下标的字符，也可以使用数组下标([])来取。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tranformStr</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> strArr = str.split(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; strArr.length; i++) &#123;</span><br><span class=\"line\">    strArr[i] = strArr[i].charAt(<span class=\"number\">0</span>).toUpperCase() + strArr[i].substring(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> strArr.join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>第二种使用正则来解决，其实算是字符串的 replace 方法和正则的结合，难点主要还是在于 replace 方法的掌握。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transformStr</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\.(\\w)/g</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(re, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match, p1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1.toUpperCase();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从以上两种方法可以看出，使用正则的代码量更少，但是对正则的理解和 replace 用法的要求也更高，下面总结一下 replace 这个字符串方法的一些 api。</p>\n<h3 id=\"replace-使用\"><a href=\"#replace-使用\" class=\"headerlink\" title=\"replace 使用\"></a>replace 使用</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">str.replace(regexp|substr, newSubStr|<span class=\"function\"><span class=\"keyword\">function</span>)</span></span><br></pre></td></tr></table></figure>\n<p>replace 方法的第一个参数可以是一个正则或者字符串。</p>\n<ul>\n<li>regexp (pattern)</li>\n</ul>\n<p>一个正则表达式（RegExp） 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</p>\n<ul>\n<li>substr (pattern)</li>\n</ul>\n<p>一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。</p>\n<p>replace 方法的第二个参数可以是一个字符串或者函数。</p>\n<ul>\n<li>newSubStr (replacement)</li>\n</ul>\n<p>用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。</p>\n<ul>\n<li>function (replacement)</li>\n</ul>\n<p>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。</p>\n<p>replace 方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。<br>在进行全局的搜索替换时，正则表达式需包含 g 标志。</p>\n<h3 id=\"使用字符串作为参数\"><a href=\"#使用字符串作为参数\" class=\"headerlink\" title=\"使用字符串作为参数\"></a>使用字符串作为参数</h3><p>当第二个参数是字符串时，替换字符串可以插入下面的特殊变量名：</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>代表的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\$\\$</td>\n<td>插入一个 “\\$”。</td>\n</tr>\n<tr>\n<td>\\$&amp;</td>\n<td>插入匹配的子串。</td>\n</tr>\n<tr>\n<td>\\$`</td>\n<td>插入当前匹配的子串左边的内容。</td>\n</tr>\n<tr>\n<td>\\$’</td>\n<td>插入当前匹配的子串右边的内容。</td>\n</tr>\n<tr>\n<td>\\$n</td>\n<td>假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。</td>\n</tr>\n</tbody>\n</table>\n<p>下面是特殊变量名的具体使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$$\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// border$ottom$olor</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$&amp;\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// border.bottom.color</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$`\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// borderborderottomborder.bottomolor</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$1\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// borderbottomcolor</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"指定一个函数作为参数\"><a href=\"#指定一个函数作为参数\" class=\"headerlink\" title=\"指定一个函数作为参数\"></a>指定一个函数作为参数</h3><p>当第二个参数是一个函数时，在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>代表的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>match</td>\n<td>匹配的子串。（对应于上述的\\$&amp;。）</td>\n</tr>\n<tr>\n<td>p1,p2, …</td>\n<td>假如 replace()方法的第一个参数是一个 RegExp 对象，则代表第 n 个括号匹配的字符串。（对应于上述的$1，$2 等。）</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是 1）</td>\n</tr>\n<tr>\n<td>string</td>\n<td>被匹配的原字符串。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：精确的参数个数依赖于 replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。</p>\n<p>在文章最开始的题目中，我们需要匹配.后面跟着的第一个字母，并且将其替换为大写字母。具体实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transformStr</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\.(\\w)/g</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(re, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match, p1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1.toUpperCase();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，声明一个正则 re，匹配一个.后面跟着一个括号，这个括号称为捕获括号，匹配的内容会被记住以供第二个参数使用，捕获括号内的\\w 匹配一个单字字符（字母、数字或者下划线），等价于[A-Za-z0-9]。第二个参数为函数，第一个字符串 match 是每次匹配到的字符串，在上述例子中就是.b 和.c，p1 则对应第一个括号匹配的字符串，对应 b 和 c，在函数内部对 p1 进行大写转换，因为 replace 产生的是一个全新的字符串，所以需要 return 出去。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<blockquote>\n<p>本文从一道简单的字符串面试题开始，记录字符串的一些方法，关注细节。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/string.jpg\" alt=\"image\"></p>","more":"<p>最近遇到一道面试题，觉得挺有意思，虽然简单缺发人深省。题目大致如下：写一个字符串转成驼峰的方法,例:border.bottom.color-&gt;borderBottomColor。</p>\n<h3 id=\"操作字符串数组\"><a href=\"#操作字符串数组\" class=\"headerlink\" title=\"操作字符串数组\"></a>操作字符串数组</h3><p>大部分人应该都能写出这种方法，对字符串进行处理然后拼接成新的字符串。主要考察字符串的几个 API，使用 charAt(n)来取得字符串第 n 个下标的字符，也可以使用数组下标([])来取。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tranformStr</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> strArr = str.split(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; strArr.length; i++) &#123;</span><br><span class=\"line\">    strArr[i] = strArr[i].charAt(<span class=\"number\">0</span>).toUpperCase() + strArr[i].substring(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> strArr.join(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>第二种使用正则来解决，其实算是字符串的 replace 方法和正则的结合，难点主要还是在于 replace 方法的掌握。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transformStr</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\.(\\w)/g</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(re, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match, p1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1.toUpperCase();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从以上两种方法可以看出，使用正则的代码量更少，但是对正则的理解和 replace 用法的要求也更高，下面总结一下 replace 这个字符串方法的一些 api。</p>\n<h3 id=\"replace-使用\"><a href=\"#replace-使用\" class=\"headerlink\" title=\"replace 使用\"></a>replace 使用</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">str.replace(regexp|substr, newSubStr|<span class=\"function\"><span class=\"keyword\">function</span>)</span></span><br></pre></td></tr></table></figure>\n<p>replace 方法的第一个参数可以是一个正则或者字符串。</p>\n<ul>\n<li>regexp (pattern)</li>\n</ul>\n<p>一个正则表达式（RegExp） 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</p>\n<ul>\n<li>substr (pattern)</li>\n</ul>\n<p>一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。</p>\n<p>replace 方法的第二个参数可以是一个字符串或者函数。</p>\n<ul>\n<li>newSubStr (replacement)</li>\n</ul>\n<p>用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。</p>\n<ul>\n<li>function (replacement)</li>\n</ul>\n<p>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。</p>\n<p>replace 方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。<br>在进行全局的搜索替换时，正则表达式需包含 g 标志。</p>\n<h3 id=\"使用字符串作为参数\"><a href=\"#使用字符串作为参数\" class=\"headerlink\" title=\"使用字符串作为参数\"></a>使用字符串作为参数</h3><p>当第二个参数是字符串时，替换字符串可以插入下面的特殊变量名：</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>代表的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\$\\$</td>\n<td>插入一个 “\\$”。</td>\n</tr>\n<tr>\n<td>\\$&amp;</td>\n<td>插入匹配的子串。</td>\n</tr>\n<tr>\n<td>\\$`</td>\n<td>插入当前匹配的子串左边的内容。</td>\n</tr>\n<tr>\n<td>\\$’</td>\n<td>插入当前匹配的子串右边的内容。</td>\n</tr>\n<tr>\n<td>\\$n</td>\n<td>假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。</td>\n</tr>\n</tbody>\n</table>\n<p>下面是特殊变量名的具体使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$$\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// border$ottom$olor</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$&amp;\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// border.bottom.color</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$`\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// borderborderottomborder.bottomolor</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"border.bottom.color\"</span>.replace(<span class=\"regexp\">/\\.(\\w)/g</span>, <span class=\"string\">\"$1\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// borderbottomcolor</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"指定一个函数作为参数\"><a href=\"#指定一个函数作为参数\" class=\"headerlink\" title=\"指定一个函数作为参数\"></a>指定一个函数作为参数</h3><p>当第二个参数是一个函数时，在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>代表的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>match</td>\n<td>匹配的子串。（对应于上述的\\$&amp;。）</td>\n</tr>\n<tr>\n<td>p1,p2, …</td>\n<td>假如 replace()方法的第一个参数是一个 RegExp 对象，则代表第 n 个括号匹配的字符串。（对应于上述的$1，$2 等。）</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是 1）</td>\n</tr>\n<tr>\n<td>string</td>\n<td>被匹配的原字符串。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：精确的参数个数依赖于 replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。</p>\n<p>在文章最开始的题目中，我们需要匹配.后面跟着的第一个字母，并且将其替换为大写字母。具体实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transformStr</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\.(\\w)/g</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(re, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match, p1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1.toUpperCase();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，声明一个正则 re，匹配一个.后面跟着一个括号，这个括号称为捕获括号，匹配的内容会被记住以供第二个参数使用，捕获括号内的\\w 匹配一个单字字符（字母、数字或者下划线），等价于[A-Za-z0-9]。第二个参数为函数，第一个字符串 match 是每次匹配到的字符串，在上述例子中就是.b 和.c，p1 则对应第一个括号匹配的字符串，对应 b 和 c，在函数内部对 p1 进行大写转换，因为 replace 产生的是一个全新的字符串，所以需要 return 出去。</p>"},{"title":"初识Node.js","date":"2016-10-06T00:53:52.000Z","banner":"http://img.yanyuanfe.cn/nodejs.png","_content":"\n> 任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。\n\n![image](http://img.yanyuanfe.cn/nodejs.png)\n\n<!--more-->\n\n### 什么是Node.js\n2009年年末，Ryan Dahl在柏林的一个JavaScript大会上宣布了一项名为Node.js的新技术。出乎所有人意料，这项关于JavaScript的技术居然不是运行在浏览器端的，要知道浏览器端对于JavaScript来说是拥有霸主地位的，毋庸置疑。\n \t       \n这项技术是关于在服务端运行JavaScript的。当时，这简单的一句描述，瞬间让听众眼前一亮，同时也宣告了这项技术的发布大获成功。\n    \n刚开始听到Node.js这个名字，你可能会以为它是一个JavaScript应用或者库。事实上，Node.js采用C++语言编写而成，是一个Javascript的运行环境。为什么采用C++语言呢？据Node.js创始人Ryan Dahl回忆，他最初希望采用Ruby来写Node.js，但是后来发现Ruby虚拟机的性能不能满足他的要求，后来他尝试采用Chorme的V8引擎（Google的Chrome浏览器使用的JavaScript执行环境），所以选择了C++语言。Node.js对Google V8引擎进行了封装。V8引擎执行JavaScript的速度非常快，性能非常好。同时还提供了很多系统级的API，如文件操作、网络编程等。浏览器端的Javascript代码在运行时会受到各种安全性的限制，对客户系统的操作有限。相比之下，Node.js则是一个全面的后台运行时，为JavaScript提供了其他语言能够实现的许多功能。\n    \nNode.js采用事件驱动、非阻塞I/O模型而得以轻量和高效，One More Thing,Node.js以单进程、单线程、高并发的方式运行。故而，Node.js可用于方便地搭建响应速度快、易于扩展的网络应用。非常适合在分布式设备上运行数据密集型的实时应用。\n\t\n在本篇文章中，我想简单的谈一下Node.js的适用场景和特性而不仅仅是一个hello world。\n \n\n\n\n### 并发连接\nNode.js在解决并发连接的问题时为我们提供了新的思路，我们先来看一个传统的解决方案。\n    \n这里我们引入一个例子，想象一下我们在银行排队办理业务的场景。\n    \n1. 系统线程模型\n\n只有一个业务员，用户排队办理业务，业务员一次处理一个用户，无法接待下一个用户，除非业务办理完成。基于系统线程模型（Thread-Based）。\n这种模型的问题显而易见，服务端只有一个线程，并发请求（用户）到达时只能处理一个，其他的请求要排队等待，从而产生阻塞，正在享受服务的请求阻塞后面等待的请求。\n2. 多线程——线程池模型\n\t\n有多个业务员处理业务，每个业务员依然只能同时处理一个用户，其余的排队等待。在高并发时仍然需要排队等待。这是基于多线程模型（Multi-Thread）。\n这个模型比上一个有很大进步，它通过增加服务端线程的数量来提高对并发请求的接收和响应，但在高并发的业务场景下，请求仍然需要等待，同时，它还有一个严重的问题：\n服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以PHP为例，维护一个连接大约需要20M的内存，所以，并发量一大，就需要多开服务器。\n    \n下面来看一下Node.js的解决方案。\n    \n- 异步、事件驱动模型\n    \n还是银行办理业务的场景，用户依然需要排队（发起请求），等待响应，但是这次我们是先拿到一个排队号码。拿到号码后我们会找个位置坐下，而在我们后面的用户（请求）会继续得到处理，同样是拿到一个号码到一边等待，业务员能一直进行处理。每当业务员处理完前一个业务时，会依次喊号码，这次被喊到号码的开始办理业务，进行处理请求。\n    \n在这个模型里，喊号码的动作在Node.js里叫做回调函数（Callback），能在事件I/O（前面一个业务）处理完成后继续执行后面的逻辑（下一个业务）。\n    \n这体现了Node.js的特性：异步机制、事件驱动。\n    \n在业务过程中，没有阻塞新用户的连接（拿号码），也不需要维护拿到号码的用户与业务员的连接。\n    \n基于这样的机制，理论上陆续有用户请求连接，Node.js都可以进行响应，因此Node.js能支持比Java、PHP程序更高的并发量。\n    \nNode.js的设计思想中以事件驱动为核心，它提供的绝大多数API都是基于事件的、异步的风格。以Net模块为例，其中的net.Socket对象就有以下事件：connect、data、end、timeout、drain、error、close等，使用Node.js的开发者需要根据自己的业务逻辑注册相应的回调函数。这些回调函数都是异步执行的，这意味着虽然在代码结构中，这些函数看似是依次注册的，但是它们并不依赖于自身出现的顺序，而是等待相应的事件触发。事件驱动、异步编程的设计，重要的优势在于，充分利用了系统资源，执行代码无须阻塞等待某种操作完成，有限的资源可以用于其他的任务。此类设计非常适合于后端的网络服务编程，Node.js的目标也在于此。在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。\n    \n事件驱动机制是Node.js通过内部单线程高效率地维护事件循环队列来实现的，没有多线程的资源占用和上下文切换，这意味着面对大规模的http请求，Node.js凭借事件驱动搞定一切。\n    \n虽然维护事件队列也需要成本，但由于Node.js是单线程，事件队列越长，得到响应的时间就越长，当并发量达到一定上限还是会力不从心。\n    \n总结一下Node.js解决并发连接的思路：\n更改连接到服务器的方式，每个连接发射（emit）一个在Node.js引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程，并为其分配一些配套内存。\n    \n### I/O阻塞\n    \nNode.js解决的另外一个问题是I/O阻塞，假设这样一个业务场景：需要从多个数据源拉取数据，然后进行处理。\n    \n1. 串行获取数据，这是我们一般的解决方案，以PHP为例\n    \n\n``` php\n//Get the Profile\n$profile=$userProfileModel->getProfile($_userid);\n//Get the Timeline\n$timeline=$userTimelineModel->getTimeline($_userid);\n\n//ToDo\n//....\necho $return\n```\n从上面的代码中可以看出，假如获取profile和timeline的操作各需要1s，那么串行获取就需要2s。\n\n2. Node.js的非阻塞I/O，通过发射/监听事件来控制执行过程\n    \n\n\n``` js\nvar proxy=new EventProxy();\n\nproxy.all(\"profile\",\"timeline\",function(profile,timeline){\n\t//ToDo\n});\n\napi.getUser(\"username\",function(profile){\n\tproxy.emit(\"profile\",profile);\n});\n\napi.getTimeline(\"username\",function(timeline){\n\tproxy.emit(\"timeline\",timeline);\n});\n```\nNode.js遇到I/O事件时会创建一个线程去执行，然后主线程会继续向下执行。因此，获取profile的动作触发一个I/O事件，马上会执行获取timeline的动作。两个动作并发执行，假如各需要1s，那么总的时间也是1s，它们的I/O事件执行完毕后，发射一个事件：profile和timeline，事件代理接收后继续执行后面的逻辑，这就是Node.js的非阻塞I/O的特性。\n    \nNode.js所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，该线程负责在 I/O 执行完毕后，将结果返回给回调函数。这里要注意的是 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求。\n    \nNode.js从推出至今，充满赞美和饱受诟病的都是其单线程模型，所有的任务都在一个线程中完成（I/O等例外），优势的地方自然是免去了频繁切换线程的开销，以及减少资源互抢的问题等等。\n    \nNode.js使用单线程执行，客户发起 I/O 请求的同时传入一个函数，该函数会在 I/O 结果返回后被自动调用，而且该请求不会阻塞后续操作。\n    \n总结下，Java和PHP通过子线程的方式实现并行请求，Node.js通过回调函数（Callback）和异步机制实现并行请求。\n    \n### Node.js优缺点\n\n- 优点\n    1. 高并发\n    2. I/O密集型应用\n- 缺点\n    1. 不适合CPU密集型应用\n    \nCPU密集型应用给Node.js带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；","source":"_posts/初识Node-js.md","raw":"---\ntitle: 初识Node.js\ndate: 2016-10-06 08:53:52\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/nodejs.png\ntags:\n\t- Node\n---\n\n> 任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。\n\n![image](http://img.yanyuanfe.cn/nodejs.png)\n\n<!--more-->\n\n### 什么是Node.js\n2009年年末，Ryan Dahl在柏林的一个JavaScript大会上宣布了一项名为Node.js的新技术。出乎所有人意料，这项关于JavaScript的技术居然不是运行在浏览器端的，要知道浏览器端对于JavaScript来说是拥有霸主地位的，毋庸置疑。\n \t       \n这项技术是关于在服务端运行JavaScript的。当时，这简单的一句描述，瞬间让听众眼前一亮，同时也宣告了这项技术的发布大获成功。\n    \n刚开始听到Node.js这个名字，你可能会以为它是一个JavaScript应用或者库。事实上，Node.js采用C++语言编写而成，是一个Javascript的运行环境。为什么采用C++语言呢？据Node.js创始人Ryan Dahl回忆，他最初希望采用Ruby来写Node.js，但是后来发现Ruby虚拟机的性能不能满足他的要求，后来他尝试采用Chorme的V8引擎（Google的Chrome浏览器使用的JavaScript执行环境），所以选择了C++语言。Node.js对Google V8引擎进行了封装。V8引擎执行JavaScript的速度非常快，性能非常好。同时还提供了很多系统级的API，如文件操作、网络编程等。浏览器端的Javascript代码在运行时会受到各种安全性的限制，对客户系统的操作有限。相比之下，Node.js则是一个全面的后台运行时，为JavaScript提供了其他语言能够实现的许多功能。\n    \nNode.js采用事件驱动、非阻塞I/O模型而得以轻量和高效，One More Thing,Node.js以单进程、单线程、高并发的方式运行。故而，Node.js可用于方便地搭建响应速度快、易于扩展的网络应用。非常适合在分布式设备上运行数据密集型的实时应用。\n\t\n在本篇文章中，我想简单的谈一下Node.js的适用场景和特性而不仅仅是一个hello world。\n \n\n\n\n### 并发连接\nNode.js在解决并发连接的问题时为我们提供了新的思路，我们先来看一个传统的解决方案。\n    \n这里我们引入一个例子，想象一下我们在银行排队办理业务的场景。\n    \n1. 系统线程模型\n\n只有一个业务员，用户排队办理业务，业务员一次处理一个用户，无法接待下一个用户，除非业务办理完成。基于系统线程模型（Thread-Based）。\n这种模型的问题显而易见，服务端只有一个线程，并发请求（用户）到达时只能处理一个，其他的请求要排队等待，从而产生阻塞，正在享受服务的请求阻塞后面等待的请求。\n2. 多线程——线程池模型\n\t\n有多个业务员处理业务，每个业务员依然只能同时处理一个用户，其余的排队等待。在高并发时仍然需要排队等待。这是基于多线程模型（Multi-Thread）。\n这个模型比上一个有很大进步，它通过增加服务端线程的数量来提高对并发请求的接收和响应，但在高并发的业务场景下，请求仍然需要等待，同时，它还有一个严重的问题：\n服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以PHP为例，维护一个连接大约需要20M的内存，所以，并发量一大，就需要多开服务器。\n    \n下面来看一下Node.js的解决方案。\n    \n- 异步、事件驱动模型\n    \n还是银行办理业务的场景，用户依然需要排队（发起请求），等待响应，但是这次我们是先拿到一个排队号码。拿到号码后我们会找个位置坐下，而在我们后面的用户（请求）会继续得到处理，同样是拿到一个号码到一边等待，业务员能一直进行处理。每当业务员处理完前一个业务时，会依次喊号码，这次被喊到号码的开始办理业务，进行处理请求。\n    \n在这个模型里，喊号码的动作在Node.js里叫做回调函数（Callback），能在事件I/O（前面一个业务）处理完成后继续执行后面的逻辑（下一个业务）。\n    \n这体现了Node.js的特性：异步机制、事件驱动。\n    \n在业务过程中，没有阻塞新用户的连接（拿号码），也不需要维护拿到号码的用户与业务员的连接。\n    \n基于这样的机制，理论上陆续有用户请求连接，Node.js都可以进行响应，因此Node.js能支持比Java、PHP程序更高的并发量。\n    \nNode.js的设计思想中以事件驱动为核心，它提供的绝大多数API都是基于事件的、异步的风格。以Net模块为例，其中的net.Socket对象就有以下事件：connect、data、end、timeout、drain、error、close等，使用Node.js的开发者需要根据自己的业务逻辑注册相应的回调函数。这些回调函数都是异步执行的，这意味着虽然在代码结构中，这些函数看似是依次注册的，但是它们并不依赖于自身出现的顺序，而是等待相应的事件触发。事件驱动、异步编程的设计，重要的优势在于，充分利用了系统资源，执行代码无须阻塞等待某种操作完成，有限的资源可以用于其他的任务。此类设计非常适合于后端的网络服务编程，Node.js的目标也在于此。在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。\n    \n事件驱动机制是Node.js通过内部单线程高效率地维护事件循环队列来实现的，没有多线程的资源占用和上下文切换，这意味着面对大规模的http请求，Node.js凭借事件驱动搞定一切。\n    \n虽然维护事件队列也需要成本，但由于Node.js是单线程，事件队列越长，得到响应的时间就越长，当并发量达到一定上限还是会力不从心。\n    \n总结一下Node.js解决并发连接的思路：\n更改连接到服务器的方式，每个连接发射（emit）一个在Node.js引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程，并为其分配一些配套内存。\n    \n### I/O阻塞\n    \nNode.js解决的另外一个问题是I/O阻塞，假设这样一个业务场景：需要从多个数据源拉取数据，然后进行处理。\n    \n1. 串行获取数据，这是我们一般的解决方案，以PHP为例\n    \n\n``` php\n//Get the Profile\n$profile=$userProfileModel->getProfile($_userid);\n//Get the Timeline\n$timeline=$userTimelineModel->getTimeline($_userid);\n\n//ToDo\n//....\necho $return\n```\n从上面的代码中可以看出，假如获取profile和timeline的操作各需要1s，那么串行获取就需要2s。\n\n2. Node.js的非阻塞I/O，通过发射/监听事件来控制执行过程\n    \n\n\n``` js\nvar proxy=new EventProxy();\n\nproxy.all(\"profile\",\"timeline\",function(profile,timeline){\n\t//ToDo\n});\n\napi.getUser(\"username\",function(profile){\n\tproxy.emit(\"profile\",profile);\n});\n\napi.getTimeline(\"username\",function(timeline){\n\tproxy.emit(\"timeline\",timeline);\n});\n```\nNode.js遇到I/O事件时会创建一个线程去执行，然后主线程会继续向下执行。因此，获取profile的动作触发一个I/O事件，马上会执行获取timeline的动作。两个动作并发执行，假如各需要1s，那么总的时间也是1s，它们的I/O事件执行完毕后，发射一个事件：profile和timeline，事件代理接收后继续执行后面的逻辑，这就是Node.js的非阻塞I/O的特性。\n    \nNode.js所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，该线程负责在 I/O 执行完毕后，将结果返回给回调函数。这里要注意的是 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求。\n    \nNode.js从推出至今，充满赞美和饱受诟病的都是其单线程模型，所有的任务都在一个线程中完成（I/O等例外），优势的地方自然是免去了频繁切换线程的开销，以及减少资源互抢的问题等等。\n    \nNode.js使用单线程执行，客户发起 I/O 请求的同时传入一个函数，该函数会在 I/O 结果返回后被自动调用，而且该请求不会阻塞后续操作。\n    \n总结下，Java和PHP通过子线程的方式实现并行请求，Node.js通过回调函数（Callback）和异步机制实现并行请求。\n    \n### Node.js优缺点\n\n- 优点\n    1. 高并发\n    2. I/O密集型应用\n- 缺点\n    1. 不适合CPU密集型应用\n    \nCPU密集型应用给Node.js带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；","slug":"初识Node-js","published":1,"updated":"2020-07-16T13:56:47.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenno000xp70vanv4u6ls","content":"<blockquote>\n<p>任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/nodejs.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"什么是Node-js\"><a href=\"#什么是Node-js\" class=\"headerlink\" title=\"什么是Node.js\"></a>什么是Node.js</h3><p>2009年年末，Ryan Dahl在柏林的一个JavaScript大会上宣布了一项名为Node.js的新技术。出乎所有人意料，这项关于JavaScript的技术居然不是运行在浏览器端的，要知道浏览器端对于JavaScript来说是拥有霸主地位的，毋庸置疑。</p>\n<p>这项技术是关于在服务端运行JavaScript的。当时，这简单的一句描述，瞬间让听众眼前一亮，同时也宣告了这项技术的发布大获成功。</p>\n<p>刚开始听到Node.js这个名字，你可能会以为它是一个JavaScript应用或者库。事实上，Node.js采用C++语言编写而成，是一个Javascript的运行环境。为什么采用C++语言呢？据Node.js创始人Ryan Dahl回忆，他最初希望采用Ruby来写Node.js，但是后来发现Ruby虚拟机的性能不能满足他的要求，后来他尝试采用Chorme的V8引擎（Google的Chrome浏览器使用的JavaScript执行环境），所以选择了C++语言。Node.js对Google V8引擎进行了封装。V8引擎执行JavaScript的速度非常快，性能非常好。同时还提供了很多系统级的API，如文件操作、网络编程等。浏览器端的Javascript代码在运行时会受到各种安全性的限制，对客户系统的操作有限。相比之下，Node.js则是一个全面的后台运行时，为JavaScript提供了其他语言能够实现的许多功能。</p>\n<p>Node.js采用事件驱动、非阻塞I/O模型而得以轻量和高效，One More Thing,Node.js以单进程、单线程、高并发的方式运行。故而，Node.js可用于方便地搭建响应速度快、易于扩展的网络应用。非常适合在分布式设备上运行数据密集型的实时应用。</p>\n<p>在本篇文章中，我想简单的谈一下Node.js的适用场景和特性而不仅仅是一个hello world。</p>\n<h3 id=\"并发连接\"><a href=\"#并发连接\" class=\"headerlink\" title=\"并发连接\"></a>并发连接</h3><p>Node.js在解决并发连接的问题时为我们提供了新的思路，我们先来看一个传统的解决方案。</p>\n<p>这里我们引入一个例子，想象一下我们在银行排队办理业务的场景。</p>\n<ol>\n<li>系统线程模型</li>\n</ol>\n<p>只有一个业务员，用户排队办理业务，业务员一次处理一个用户，无法接待下一个用户，除非业务办理完成。基于系统线程模型（Thread-Based）。<br>这种模型的问题显而易见，服务端只有一个线程，并发请求（用户）到达时只能处理一个，其他的请求要排队等待，从而产生阻塞，正在享受服务的请求阻塞后面等待的请求。</p>\n<ol start=\"2\">\n<li>多线程——线程池模型</li>\n</ol>\n<p>有多个业务员处理业务，每个业务员依然只能同时处理一个用户，其余的排队等待。在高并发时仍然需要排队等待。这是基于多线程模型（Multi-Thread）。<br>这个模型比上一个有很大进步，它通过增加服务端线程的数量来提高对并发请求的接收和响应，但在高并发的业务场景下，请求仍然需要等待，同时，它还有一个严重的问题：<br>服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以PHP为例，维护一个连接大约需要20M的内存，所以，并发量一大，就需要多开服务器。</p>\n<p>下面来看一下Node.js的解决方案。</p>\n<ul>\n<li>异步、事件驱动模型</li>\n</ul>\n<p>还是银行办理业务的场景，用户依然需要排队（发起请求），等待响应，但是这次我们是先拿到一个排队号码。拿到号码后我们会找个位置坐下，而在我们后面的用户（请求）会继续得到处理，同样是拿到一个号码到一边等待，业务员能一直进行处理。每当业务员处理完前一个业务时，会依次喊号码，这次被喊到号码的开始办理业务，进行处理请求。</p>\n<p>在这个模型里，喊号码的动作在Node.js里叫做回调函数（Callback），能在事件I/O（前面一个业务）处理完成后继续执行后面的逻辑（下一个业务）。</p>\n<p>这体现了Node.js的特性：异步机制、事件驱动。</p>\n<p>在业务过程中，没有阻塞新用户的连接（拿号码），也不需要维护拿到号码的用户与业务员的连接。</p>\n<p>基于这样的机制，理论上陆续有用户请求连接，Node.js都可以进行响应，因此Node.js能支持比Java、PHP程序更高的并发量。</p>\n<p>Node.js的设计思想中以事件驱动为核心，它提供的绝大多数API都是基于事件的、异步的风格。以Net模块为例，其中的net.Socket对象就有以下事件：connect、data、end、timeout、drain、error、close等，使用Node.js的开发者需要根据自己的业务逻辑注册相应的回调函数。这些回调函数都是异步执行的，这意味着虽然在代码结构中，这些函数看似是依次注册的，但是它们并不依赖于自身出现的顺序，而是等待相应的事件触发。事件驱动、异步编程的设计，重要的优势在于，充分利用了系统资源，执行代码无须阻塞等待某种操作完成，有限的资源可以用于其他的任务。此类设计非常适合于后端的网络服务编程，Node.js的目标也在于此。在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。</p>\n<p>事件驱动机制是Node.js通过内部单线程高效率地维护事件循环队列来实现的，没有多线程的资源占用和上下文切换，这意味着面对大规模的http请求，Node.js凭借事件驱动搞定一切。</p>\n<p>虽然维护事件队列也需要成本，但由于Node.js是单线程，事件队列越长，得到响应的时间就越长，当并发量达到一定上限还是会力不从心。</p>\n<p>总结一下Node.js解决并发连接的思路：<br>更改连接到服务器的方式，每个连接发射（emit）一个在Node.js引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程，并为其分配一些配套内存。</p>\n<h3 id=\"I-O阻塞\"><a href=\"#I-O阻塞\" class=\"headerlink\" title=\"I/O阻塞\"></a>I/O阻塞</h3><p>Node.js解决的另外一个问题是I/O阻塞，假设这样一个业务场景：需要从多个数据源拉取数据，然后进行处理。</p>\n<ol>\n<li>串行获取数据，这是我们一般的解决方案，以PHP为例</li>\n</ol>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Get the Profile</span></span><br><span class=\"line\">$profile=$userProfileModel-&gt;getProfile($_userid);</span><br><span class=\"line\"><span class=\"comment\">//Get the Timeline</span></span><br><span class=\"line\">$timeline=$userTimelineModel-&gt;getTimeline($_userid);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ToDo</span></span><br><span class=\"line\"><span class=\"comment\">//....</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> $return</span><br></pre></td></tr></table></figure>\n<p>从上面的代码中可以看出，假如获取profile和timeline的操作各需要1s，那么串行获取就需要2s。</p>\n<ol start=\"2\">\n<li>Node.js的非阻塞I/O，通过发射/监听事件来控制执行过程</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy=<span class=\"keyword\">new</span> EventProxy();</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.all(<span class=\"string\">\"profile\"</span>,<span class=\"string\">\"timeline\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">profile,timeline</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//ToDo</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">api.getUser(<span class=\"string\">\"username\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">profile</span>)</span>&#123;</span><br><span class=\"line\">\tproxy.emit(<span class=\"string\">\"profile\"</span>,profile);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">api.getTimeline(<span class=\"string\">\"username\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">timeline</span>)</span>&#123;</span><br><span class=\"line\">\tproxy.emit(<span class=\"string\">\"timeline\"</span>,timeline);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Node.js遇到I/O事件时会创建一个线程去执行，然后主线程会继续向下执行。因此，获取profile的动作触发一个I/O事件，马上会执行获取timeline的动作。两个动作并发执行，假如各需要1s，那么总的时间也是1s，它们的I/O事件执行完毕后，发射一个事件：profile和timeline，事件代理接收后继续执行后面的逻辑，这就是Node.js的非阻塞I/O的特性。</p>\n<p>Node.js所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，该线程负责在 I/O 执行完毕后，将结果返回给回调函数。这里要注意的是 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求。</p>\n<p>Node.js从推出至今，充满赞美和饱受诟病的都是其单线程模型，所有的任务都在一个线程中完成（I/O等例外），优势的地方自然是免去了频繁切换线程的开销，以及减少资源互抢的问题等等。</p>\n<p>Node.js使用单线程执行，客户发起 I/O 请求的同时传入一个函数，该函数会在 I/O 结果返回后被自动调用，而且该请求不会阻塞后续操作。</p>\n<p>总结下，Java和PHP通过子线程的方式实现并行请求，Node.js通过回调函数（Callback）和异步机制实现并行请求。</p>\n<h3 id=\"Node-js优缺点\"><a href=\"#Node-js优缺点\" class=\"headerlink\" title=\"Node.js优缺点\"></a>Node.js优缺点</h3><ul>\n<li>优点<ol>\n<li>高并发</li>\n<li>I/O密集型应用</li>\n</ol>\n</li>\n<li>缺点<ol>\n<li>不适合CPU密集型应用</li>\n</ol>\n</li>\n</ul>\n<p>CPU密集型应用给Node.js带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/nodejs.png\" alt=\"image\"></p>","more":"<h3 id=\"什么是Node-js\"><a href=\"#什么是Node-js\" class=\"headerlink\" title=\"什么是Node.js\"></a>什么是Node.js</h3><p>2009年年末，Ryan Dahl在柏林的一个JavaScript大会上宣布了一项名为Node.js的新技术。出乎所有人意料，这项关于JavaScript的技术居然不是运行在浏览器端的，要知道浏览器端对于JavaScript来说是拥有霸主地位的，毋庸置疑。</p>\n<p>这项技术是关于在服务端运行JavaScript的。当时，这简单的一句描述，瞬间让听众眼前一亮，同时也宣告了这项技术的发布大获成功。</p>\n<p>刚开始听到Node.js这个名字，你可能会以为它是一个JavaScript应用或者库。事实上，Node.js采用C++语言编写而成，是一个Javascript的运行环境。为什么采用C++语言呢？据Node.js创始人Ryan Dahl回忆，他最初希望采用Ruby来写Node.js，但是后来发现Ruby虚拟机的性能不能满足他的要求，后来他尝试采用Chorme的V8引擎（Google的Chrome浏览器使用的JavaScript执行环境），所以选择了C++语言。Node.js对Google V8引擎进行了封装。V8引擎执行JavaScript的速度非常快，性能非常好。同时还提供了很多系统级的API，如文件操作、网络编程等。浏览器端的Javascript代码在运行时会受到各种安全性的限制，对客户系统的操作有限。相比之下，Node.js则是一个全面的后台运行时，为JavaScript提供了其他语言能够实现的许多功能。</p>\n<p>Node.js采用事件驱动、非阻塞I/O模型而得以轻量和高效，One More Thing,Node.js以单进程、单线程、高并发的方式运行。故而，Node.js可用于方便地搭建响应速度快、易于扩展的网络应用。非常适合在分布式设备上运行数据密集型的实时应用。</p>\n<p>在本篇文章中，我想简单的谈一下Node.js的适用场景和特性而不仅仅是一个hello world。</p>\n<h3 id=\"并发连接\"><a href=\"#并发连接\" class=\"headerlink\" title=\"并发连接\"></a>并发连接</h3><p>Node.js在解决并发连接的问题时为我们提供了新的思路，我们先来看一个传统的解决方案。</p>\n<p>这里我们引入一个例子，想象一下我们在银行排队办理业务的场景。</p>\n<ol>\n<li>系统线程模型</li>\n</ol>\n<p>只有一个业务员，用户排队办理业务，业务员一次处理一个用户，无法接待下一个用户，除非业务办理完成。基于系统线程模型（Thread-Based）。<br>这种模型的问题显而易见，服务端只有一个线程，并发请求（用户）到达时只能处理一个，其他的请求要排队等待，从而产生阻塞，正在享受服务的请求阻塞后面等待的请求。</p>\n<ol start=\"2\">\n<li>多线程——线程池模型</li>\n</ol>\n<p>有多个业务员处理业务，每个业务员依然只能同时处理一个用户，其余的排队等待。在高并发时仍然需要排队等待。这是基于多线程模型（Multi-Thread）。<br>这个模型比上一个有很大进步，它通过增加服务端线程的数量来提高对并发请求的接收和响应，但在高并发的业务场景下，请求仍然需要等待，同时，它还有一个严重的问题：<br>服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以PHP为例，维护一个连接大约需要20M的内存，所以，并发量一大，就需要多开服务器。</p>\n<p>下面来看一下Node.js的解决方案。</p>\n<ul>\n<li>异步、事件驱动模型</li>\n</ul>\n<p>还是银行办理业务的场景，用户依然需要排队（发起请求），等待响应，但是这次我们是先拿到一个排队号码。拿到号码后我们会找个位置坐下，而在我们后面的用户（请求）会继续得到处理，同样是拿到一个号码到一边等待，业务员能一直进行处理。每当业务员处理完前一个业务时，会依次喊号码，这次被喊到号码的开始办理业务，进行处理请求。</p>\n<p>在这个模型里，喊号码的动作在Node.js里叫做回调函数（Callback），能在事件I/O（前面一个业务）处理完成后继续执行后面的逻辑（下一个业务）。</p>\n<p>这体现了Node.js的特性：异步机制、事件驱动。</p>\n<p>在业务过程中，没有阻塞新用户的连接（拿号码），也不需要维护拿到号码的用户与业务员的连接。</p>\n<p>基于这样的机制，理论上陆续有用户请求连接，Node.js都可以进行响应，因此Node.js能支持比Java、PHP程序更高的并发量。</p>\n<p>Node.js的设计思想中以事件驱动为核心，它提供的绝大多数API都是基于事件的、异步的风格。以Net模块为例，其中的net.Socket对象就有以下事件：connect、data、end、timeout、drain、error、close等，使用Node.js的开发者需要根据自己的业务逻辑注册相应的回调函数。这些回调函数都是异步执行的，这意味着虽然在代码结构中，这些函数看似是依次注册的，但是它们并不依赖于自身出现的顺序，而是等待相应的事件触发。事件驱动、异步编程的设计，重要的优势在于，充分利用了系统资源，执行代码无须阻塞等待某种操作完成，有限的资源可以用于其他的任务。此类设计非常适合于后端的网络服务编程，Node.js的目标也在于此。在服务器开发中，并发的请求处理是个大问题，阻塞式的函数会导致资源浪费和时间延迟。通过事件注册、异步函数，开发人员可以提高资源的利用率，性能也会改善。</p>\n<p>事件驱动机制是Node.js通过内部单线程高效率地维护事件循环队列来实现的，没有多线程的资源占用和上下文切换，这意味着面对大规模的http请求，Node.js凭借事件驱动搞定一切。</p>\n<p>虽然维护事件队列也需要成本，但由于Node.js是单线程，事件队列越长，得到响应的时间就越长，当并发量达到一定上限还是会力不从心。</p>\n<p>总结一下Node.js解决并发连接的思路：<br>更改连接到服务器的方式，每个连接发射（emit）一个在Node.js引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程，并为其分配一些配套内存。</p>\n<h3 id=\"I-O阻塞\"><a href=\"#I-O阻塞\" class=\"headerlink\" title=\"I/O阻塞\"></a>I/O阻塞</h3><p>Node.js解决的另外一个问题是I/O阻塞，假设这样一个业务场景：需要从多个数据源拉取数据，然后进行处理。</p>\n<ol>\n<li>串行获取数据，这是我们一般的解决方案，以PHP为例</li>\n</ol>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Get the Profile</span></span><br><span class=\"line\">$profile=$userProfileModel-&gt;getProfile($_userid);</span><br><span class=\"line\"><span class=\"comment\">//Get the Timeline</span></span><br><span class=\"line\">$timeline=$userTimelineModel-&gt;getTimeline($_userid);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ToDo</span></span><br><span class=\"line\"><span class=\"comment\">//....</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> $return</span><br></pre></td></tr></table></figure>\n<p>从上面的代码中可以看出，假如获取profile和timeline的操作各需要1s，那么串行获取就需要2s。</p>\n<ol start=\"2\">\n<li>Node.js的非阻塞I/O，通过发射/监听事件来控制执行过程</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy=<span class=\"keyword\">new</span> EventProxy();</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.all(<span class=\"string\">\"profile\"</span>,<span class=\"string\">\"timeline\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">profile,timeline</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//ToDo</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">api.getUser(<span class=\"string\">\"username\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">profile</span>)</span>&#123;</span><br><span class=\"line\">\tproxy.emit(<span class=\"string\">\"profile\"</span>,profile);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">api.getTimeline(<span class=\"string\">\"username\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">timeline</span>)</span>&#123;</span><br><span class=\"line\">\tproxy.emit(<span class=\"string\">\"timeline\"</span>,timeline);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Node.js遇到I/O事件时会创建一个线程去执行，然后主线程会继续向下执行。因此，获取profile的动作触发一个I/O事件，马上会执行获取timeline的动作。两个动作并发执行，假如各需要1s，那么总的时间也是1s，它们的I/O事件执行完毕后，发射一个事件：profile和timeline，事件代理接收后继续执行后面的逻辑，这就是Node.js的非阻塞I/O的特性。</p>\n<p>Node.js所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，该线程负责在 I/O 执行完毕后，将结果返回给回调函数。这里要注意的是 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求。</p>\n<p>Node.js从推出至今，充满赞美和饱受诟病的都是其单线程模型，所有的任务都在一个线程中完成（I/O等例外），优势的地方自然是免去了频繁切换线程的开销，以及减少资源互抢的问题等等。</p>\n<p>Node.js使用单线程执行，客户发起 I/O 请求的同时传入一个函数，该函数会在 I/O 结果返回后被自动调用，而且该请求不会阻塞后续操作。</p>\n<p>总结下，Java和PHP通过子线程的方式实现并行请求，Node.js通过回调函数（Callback）和异步机制实现并行请求。</p>\n<h3 id=\"Node-js优缺点\"><a href=\"#Node-js优缺点\" class=\"headerlink\" title=\"Node.js优缺点\"></a>Node.js优缺点</h3><ul>\n<li>优点<ol>\n<li>高并发</li>\n<li>I/O密集型应用</li>\n</ol>\n</li>\n<li>缺点<ol>\n<li>不适合CPU密集型应用</li>\n</ol>\n</li>\n</ul>\n<p>CPU密集型应用给Node.js带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；</p>"},{"title":"前端代码规范工程化实践指南","date":"2018-07-27T14:25:47.000Z","banner":"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg","_content":"\n> 代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本。本文介绍了ESLint规范、EditorConfig配置、Git控制代码规范等工程化实践在代码规范中的运用。\n\n![image](http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg)\n\n<!--more-->\n\n现代前端技术飞速发展，前端已进入了以效率和质量为核心的工程化时代，各种自动化工具和技术的使用大大提高了开发效率。在团队协作中，编码规范至关重要，统一的编码规范可以降低代码维护的成本，但是，纯手工检查代码规范费时费力且难以保证准确性，因此，针对代码规范的自动化工具应运而生，从最早的JSLint，到JSHint，再到今天的ESLint，代码规范工具变得越来越成熟。再结合WebStorm、VSCode等编辑器可以在编写代码的时候自动提醒错误，在开发阶段就避免错误，提高开发效率。本文主要讨论前端工程化在代码规范上的一些实践。\n\n\n### ESLint\nESLint是当前最流行的代码规范检查工具，随着ECMAScript版本一直更新，通过配置检查规则来对代码进行规范检查，具有丰富的插件生态，也可以使用已有的规范以及进行自定义规则，可以满足大部分团队的需求。\n\n下面介绍在react项目中如何使用ESLint。\n\n首先，使用webpack搭建一个react的项目，在此不对具体搭建过程做具体介绍，然后使用npm安装eslint：\n\n``` bash\nnpm install eslint babel-eslint --save-dev\n```\n\n在项目根目录下新建.eslintrc文件，用于配置eslint进行代码规范检查的规则，下面是用于react项目的基本配置示例：\n\n``` json\n{\n  \"parser\": \"babel-eslint\",\n  \"env\": {\n    \"browser\": true,\n    \"es6\": true,\n    \"node\": true\n  },\n  \"parserOptions\": {\n    \"ecmaVersion\": 6,\n    \"sourceType\": \"module\"\n  },\n  \"extends\": \"airbnb\",\n  \"rules\": {\n    \"react/jsx-filename-extension\": [0]\n  }\n}\n```\n\n其中，parser用于指定eslint用来解析代码的解析器，babel-eslint是一个用于兼容ESLint的babel解析器的封装。env用于配置预定义的环境变量，此处指定了浏览器和Node.js以及ES6语法中所有的环境变量。parserOptions用于想要支持的JavaScript语言选项，此处指定了ecmaVersion和sourceType，分别表示启用ES6语法以及ECMAScript模块。extends用于当前配置继承何种规范，此处，使用airbnb公司开源的eslint-config-airbnb规范，\neslint-config-airbnb规范默认包含了ES6+的语法以及React的语法，它依赖于eslint、eslint-plugin-import、eslint-plugin-react以及eslint-plugin-jsx-i11y等npm包，安装时需要一起安装。\n使用npm5+的版本安装eslint-config-airbnb：\n\n``` bash\nnpx install-peerdeps --dev eslint-config-airbnb\n```\n\nrules即是配置的一系列规则，如果你不想使用airbnb中的某项规范，你可以在rules进行配置。下面列举示例：\n\n```\n\"rules\": {\n  \"semi\": [\"error\", \"always\"],\n  \"quotes\": [\"error\", \"double\"]\n}\n```\n\n“semi”和“quotes”是ESLint中规则的名称，第一个词是错误级别，可以使用下面的值之一：\n\n\"off\" or 0 ：关闭规则;\n\n\"warn\" or 1 ：将规则视为一个警告（不会影响退出码）;\n\n\"error\" or 2 ：将规则视为一个错误 (退出码为1);\n\n也可以写成如下的形式：\n\n```\n\"rules\": {\n  \"semi\": [2],\n  \"quotes\": [2]\n}\n```\n\n除了继承，你还可以使用第三方插件来配置规则，通过plugins来配置需要的插件列表，以eslint-plugin-react为例，配置如下：\n\n```\n{\n  \"plugins\": [\n     \"react\"\n   ]\n}\n```\n配置完成后，我们希望能在每次修改代码后再次编译之前，能够对代码进行自动检查，先安装eslint-loader：\n``` bash\nnpm install eslint-loader --save-dev\n```\n增加Webpack配置：\n``` js\nmodule: {\n    rules: [\n      {\n        enforce: 'pre',\n        test: /.(js|jsx)$/,\n        loader: 'eslint-loader',\n        exclude: [\n          path.resolve(__dirname, '../node_modules')\n        ]\n      },\n    ]\n}\n```\nWebpack使用babel-loader解析React的代码，增加eslint-loader的配置，enforce设置为pre可以让Webpack在使用babel编译之前运行eslint进行代码检查。\n\neslint还提供了自动修复代码错误的能力，执行以下命令：\n\n\n```\neslint --fix\n```\neslint会自动修复代码中的问题，但不是所有的问题都能被修复，剩余未被修复的问题会列出。\n\nESLint还可以结合编辑器进行使用，首先保证使用了npm安装了eslint以及生成了.eslintrc配置文件，以WebStorm编辑器为例，\n配置：\n\n> File -> Settings\n> Languages & Frameworks -> JavaScript -> Code Quality Tools -> ESLint\n\n勾选Enable即可。WebStorm就会在编写代码的时候进行提示，如果不符合ESLint规则则会进行颜色标注，让你更早发现代码问题。\n![eslint](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_472.png)\nVSCode需要安装eslint插件才能对代码进行提示，在此不做赘述。\n\n\n\n\n### EditorConfig\n不同的操作系统和编辑器对于文本的格式的支持会有一定的区别，如果不统一一些规范，可能在团队协作的时候每次更新下来别人的代码就会一大堆报错。\nEditorConfig是一种多编辑器插件，用于帮助开发者在不同的操作系统、编辑器和IDE之间定义和维护统一的代码风格。EditorConfig包含一个用于定义代码风格的配置文件和对应的编辑器插件，编辑器插件可以读取配置文件并对代码进行格式化。\nEditorConfig的配置文件是.editorconfig，通常放置在项目根目录下。EdtorConfig插件对在文件夹的每一级目录下查找.editorconfig文件，直到查找到.editorconfig中包含root=true。\n下面是一份.editorconfig配置文件：（注意：不是每种插件都支持下列所有属性）\n\n```\nroot = true\n\n[*]\ncharset = utf-8\nindent_style = space\nindent_size = 2\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n```\n\nroot为true表示是最顶层的配置文件，\n[*]用于匹配需要格式化的代码，charset指定编码格式为utf-8,intent_style指定缩进风格为空格，还可以选择tab，indent_size用于指定缩进的列数，end_of_line指定换行符为lf，在Linux和Windows下可能会因为换行符lf和crlf的不一致导致代码在版本管理工具下报错，insert_final_newline设为true表示文件以一个空白行结尾，\ntrim_trailing_whitespace设为true会去除换行行首的任意空白字符。\n\nWebstorm编辑器默认已经内置了EditorConfig的插件支持，只需要编写配置文件即可，VSCode需要下载EditorConfig的插件使用。\n\n### 与版本管理工具结合\n以版本管理工具Git为例，当版本库中出现commit、push等特殊事件时，都会触发执行一个或者多个的Shell脚本，称之为git钩子，存放在.git/hooks目录下，钩子从执行顺序上分为两类，前置（pre）和后置（post），分别发生在动作调用前后。\nESLint结合版本管理工具Git可以最大程度控制每个人的规范，在git commit代码的时候，使用git hook调用ESLint进行代码规范验证，这样可以保证团队协作的代码是符合代码规范的，不规范的代码无法提交到仓库。\n\n配置Git钩子的过程比较繁琐，我们可以使用husky这个工具来简化配置，husky使用如下：\n\n安装依赖：\n\n``` bash\nnpm i husky --save-dev\n```\n\n修改package.json，增加script配置：\n\n```\n{\n  \"scripts\": {\n      \"precommit\": \"eslint client/**/*.js\"\n  }\n}\n```\n\n\n尝试Git提交，会自动使用eslint进行校验：\n\n![husky](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_468.png)\n\n但是这样会出现新的问题：如果一个老项目刚开始使用这种方式进行代码校验，势必会出现很多代码校验不通过的情况。那么最好的实现应该是开发者在commit代码的时候只校验自己提交的部分，lint-staged解决了这个问题，statged指Git中的待提交区，使用git add然后git commit的时候，你的代码会经过待提交区。\nlint-staged使用方法如下：\n\n``` bash\nnpm install lint-staged --save-dev\n```\n\n修改package.json中的script配置：\n\n```\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  },\n  \"lint-staged\": {\n    \"client/**/*.js\": \"eslint\"\n  }\n} \n```\n\n也可以使用如下配置自动修复错误：\n\n```\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  },\n  \"lint-staged\": {\n    \"client/**/*.js\": [\"eslint --fix\", \"git add\"]\n  }\n}\n```\n\nhusky会在.git/hooks中添加pre-commit钩子，当开发者执行git add将代码提交到暂存区后，再执行git commit操作时，触发pre-commit钩子，开始执行npm run precommit命令，即lint-staged命令，lint-staged利用配置的文件过滤路径如（src/**/*.js），对暂存区文件依次进行匹配，运行eslint --fix自动修复错误，并将修改添加到暂存区。\n\n![lint](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_473.png)\n\n\n### 总结\n代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本，而前端工程化可以让这件事情变得更简单。\n\n","source":"_posts/前端代码规范工程化实践指南.md","raw":"---\ntitle: 前端代码规范工程化实践指南\ndate: 2018-07-27 22:25:47\nbanner: http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\ntags:\n\t- 前端\n---\n\n> 代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本。本文介绍了ESLint规范、EditorConfig配置、Git控制代码规范等工程化实践在代码规范中的运用。\n\n![image](http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg)\n\n<!--more-->\n\n现代前端技术飞速发展，前端已进入了以效率和质量为核心的工程化时代，各种自动化工具和技术的使用大大提高了开发效率。在团队协作中，编码规范至关重要，统一的编码规范可以降低代码维护的成本，但是，纯手工检查代码规范费时费力且难以保证准确性，因此，针对代码规范的自动化工具应运而生，从最早的JSLint，到JSHint，再到今天的ESLint，代码规范工具变得越来越成熟。再结合WebStorm、VSCode等编辑器可以在编写代码的时候自动提醒错误，在开发阶段就避免错误，提高开发效率。本文主要讨论前端工程化在代码规范上的一些实践。\n\n\n### ESLint\nESLint是当前最流行的代码规范检查工具，随着ECMAScript版本一直更新，通过配置检查规则来对代码进行规范检查，具有丰富的插件生态，也可以使用已有的规范以及进行自定义规则，可以满足大部分团队的需求。\n\n下面介绍在react项目中如何使用ESLint。\n\n首先，使用webpack搭建一个react的项目，在此不对具体搭建过程做具体介绍，然后使用npm安装eslint：\n\n``` bash\nnpm install eslint babel-eslint --save-dev\n```\n\n在项目根目录下新建.eslintrc文件，用于配置eslint进行代码规范检查的规则，下面是用于react项目的基本配置示例：\n\n``` json\n{\n  \"parser\": \"babel-eslint\",\n  \"env\": {\n    \"browser\": true,\n    \"es6\": true,\n    \"node\": true\n  },\n  \"parserOptions\": {\n    \"ecmaVersion\": 6,\n    \"sourceType\": \"module\"\n  },\n  \"extends\": \"airbnb\",\n  \"rules\": {\n    \"react/jsx-filename-extension\": [0]\n  }\n}\n```\n\n其中，parser用于指定eslint用来解析代码的解析器，babel-eslint是一个用于兼容ESLint的babel解析器的封装。env用于配置预定义的环境变量，此处指定了浏览器和Node.js以及ES6语法中所有的环境变量。parserOptions用于想要支持的JavaScript语言选项，此处指定了ecmaVersion和sourceType，分别表示启用ES6语法以及ECMAScript模块。extends用于当前配置继承何种规范，此处，使用airbnb公司开源的eslint-config-airbnb规范，\neslint-config-airbnb规范默认包含了ES6+的语法以及React的语法，它依赖于eslint、eslint-plugin-import、eslint-plugin-react以及eslint-plugin-jsx-i11y等npm包，安装时需要一起安装。\n使用npm5+的版本安装eslint-config-airbnb：\n\n``` bash\nnpx install-peerdeps --dev eslint-config-airbnb\n```\n\nrules即是配置的一系列规则，如果你不想使用airbnb中的某项规范，你可以在rules进行配置。下面列举示例：\n\n```\n\"rules\": {\n  \"semi\": [\"error\", \"always\"],\n  \"quotes\": [\"error\", \"double\"]\n}\n```\n\n“semi”和“quotes”是ESLint中规则的名称，第一个词是错误级别，可以使用下面的值之一：\n\n\"off\" or 0 ：关闭规则;\n\n\"warn\" or 1 ：将规则视为一个警告（不会影响退出码）;\n\n\"error\" or 2 ：将规则视为一个错误 (退出码为1);\n\n也可以写成如下的形式：\n\n```\n\"rules\": {\n  \"semi\": [2],\n  \"quotes\": [2]\n}\n```\n\n除了继承，你还可以使用第三方插件来配置规则，通过plugins来配置需要的插件列表，以eslint-plugin-react为例，配置如下：\n\n```\n{\n  \"plugins\": [\n     \"react\"\n   ]\n}\n```\n配置完成后，我们希望能在每次修改代码后再次编译之前，能够对代码进行自动检查，先安装eslint-loader：\n``` bash\nnpm install eslint-loader --save-dev\n```\n增加Webpack配置：\n``` js\nmodule: {\n    rules: [\n      {\n        enforce: 'pre',\n        test: /.(js|jsx)$/,\n        loader: 'eslint-loader',\n        exclude: [\n          path.resolve(__dirname, '../node_modules')\n        ]\n      },\n    ]\n}\n```\nWebpack使用babel-loader解析React的代码，增加eslint-loader的配置，enforce设置为pre可以让Webpack在使用babel编译之前运行eslint进行代码检查。\n\neslint还提供了自动修复代码错误的能力，执行以下命令：\n\n\n```\neslint --fix\n```\neslint会自动修复代码中的问题，但不是所有的问题都能被修复，剩余未被修复的问题会列出。\n\nESLint还可以结合编辑器进行使用，首先保证使用了npm安装了eslint以及生成了.eslintrc配置文件，以WebStorm编辑器为例，\n配置：\n\n> File -> Settings\n> Languages & Frameworks -> JavaScript -> Code Quality Tools -> ESLint\n\n勾选Enable即可。WebStorm就会在编写代码的时候进行提示，如果不符合ESLint规则则会进行颜色标注，让你更早发现代码问题。\n![eslint](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_472.png)\nVSCode需要安装eslint插件才能对代码进行提示，在此不做赘述。\n\n\n\n\n### EditorConfig\n不同的操作系统和编辑器对于文本的格式的支持会有一定的区别，如果不统一一些规范，可能在团队协作的时候每次更新下来别人的代码就会一大堆报错。\nEditorConfig是一种多编辑器插件，用于帮助开发者在不同的操作系统、编辑器和IDE之间定义和维护统一的代码风格。EditorConfig包含一个用于定义代码风格的配置文件和对应的编辑器插件，编辑器插件可以读取配置文件并对代码进行格式化。\nEditorConfig的配置文件是.editorconfig，通常放置在项目根目录下。EdtorConfig插件对在文件夹的每一级目录下查找.editorconfig文件，直到查找到.editorconfig中包含root=true。\n下面是一份.editorconfig配置文件：（注意：不是每种插件都支持下列所有属性）\n\n```\nroot = true\n\n[*]\ncharset = utf-8\nindent_style = space\nindent_size = 2\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n```\n\nroot为true表示是最顶层的配置文件，\n[*]用于匹配需要格式化的代码，charset指定编码格式为utf-8,intent_style指定缩进风格为空格，还可以选择tab，indent_size用于指定缩进的列数，end_of_line指定换行符为lf，在Linux和Windows下可能会因为换行符lf和crlf的不一致导致代码在版本管理工具下报错，insert_final_newline设为true表示文件以一个空白行结尾，\ntrim_trailing_whitespace设为true会去除换行行首的任意空白字符。\n\nWebstorm编辑器默认已经内置了EditorConfig的插件支持，只需要编写配置文件即可，VSCode需要下载EditorConfig的插件使用。\n\n### 与版本管理工具结合\n以版本管理工具Git为例，当版本库中出现commit、push等特殊事件时，都会触发执行一个或者多个的Shell脚本，称之为git钩子，存放在.git/hooks目录下，钩子从执行顺序上分为两类，前置（pre）和后置（post），分别发生在动作调用前后。\nESLint结合版本管理工具Git可以最大程度控制每个人的规范，在git commit代码的时候，使用git hook调用ESLint进行代码规范验证，这样可以保证团队协作的代码是符合代码规范的，不规范的代码无法提交到仓库。\n\n配置Git钩子的过程比较繁琐，我们可以使用husky这个工具来简化配置，husky使用如下：\n\n安装依赖：\n\n``` bash\nnpm i husky --save-dev\n```\n\n修改package.json，增加script配置：\n\n```\n{\n  \"scripts\": {\n      \"precommit\": \"eslint client/**/*.js\"\n  }\n}\n```\n\n\n尝试Git提交，会自动使用eslint进行校验：\n\n![husky](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_468.png)\n\n但是这样会出现新的问题：如果一个老项目刚开始使用这种方式进行代码校验，势必会出现很多代码校验不通过的情况。那么最好的实现应该是开发者在commit代码的时候只校验自己提交的部分，lint-staged解决了这个问题，statged指Git中的待提交区，使用git add然后git commit的时候，你的代码会经过待提交区。\nlint-staged使用方法如下：\n\n``` bash\nnpm install lint-staged --save-dev\n```\n\n修改package.json中的script配置：\n\n```\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  },\n  \"lint-staged\": {\n    \"client/**/*.js\": \"eslint\"\n  }\n} \n```\n\n也可以使用如下配置自动修复错误：\n\n```\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  },\n  \"lint-staged\": {\n    \"client/**/*.js\": [\"eslint --fix\", \"git add\"]\n  }\n}\n```\n\nhusky会在.git/hooks中添加pre-commit钩子，当开发者执行git add将代码提交到暂存区后，再执行git commit操作时，触发pre-commit钩子，开始执行npm run precommit命令，即lint-staged命令，lint-staged利用配置的文件过滤路径如（src/**/*.js），对暂存区文件依次进行匹配，运行eslint --fix自动修复错误，并将修改添加到暂存区。\n\n![lint](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_473.png)\n\n\n### 总结\n代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本，而前端工程化可以让这件事情变得更简单。\n\n","slug":"前端代码规范工程化实践指南","published":1,"updated":"2020-07-16T13:56:47.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennq0011p70vvgnn9bz6","content":"<blockquote>\n<p>代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本。本文介绍了ESLint规范、EditorConfig配置、Git控制代码规范等工程化实践在代码规范中的运用。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>现代前端技术飞速发展，前端已进入了以效率和质量为核心的工程化时代，各种自动化工具和技术的使用大大提高了开发效率。在团队协作中，编码规范至关重要，统一的编码规范可以降低代码维护的成本，但是，纯手工检查代码规范费时费力且难以保证准确性，因此，针对代码规范的自动化工具应运而生，从最早的JSLint，到JSHint，再到今天的ESLint，代码规范工具变得越来越成熟。再结合WebStorm、VSCode等编辑器可以在编写代码的时候自动提醒错误，在开发阶段就避免错误，提高开发效率。本文主要讨论前端工程化在代码规范上的一些实践。</p>\n<h3 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p>ESLint是当前最流行的代码规范检查工具，随着ECMAScript版本一直更新，通过配置检查规则来对代码进行规范检查，具有丰富的插件生态，也可以使用已有的规范以及进行自定义规则，可以满足大部分团队的需求。</p>\n<p>下面介绍在react项目中如何使用ESLint。</p>\n<p>首先，使用webpack搭建一个react的项目，在此不对具体搭建过程做具体介绍，然后使用npm安装eslint：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install eslint babel-eslint --save-dev</span><br></pre></td></tr></table></figure>\n<p>在项目根目录下新建.eslintrc文件，用于配置eslint进行代码规范检查的规则，下面是用于react项目的基本配置示例：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"parser\"</span>: <span class=\"string\">\"babel-eslint\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"env\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"browser\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"es6\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"node\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"extends\"</span>: <span class=\"string\">\"airbnb\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"react/jsx-filename-extension\"</span>: [<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，parser用于指定eslint用来解析代码的解析器，babel-eslint是一个用于兼容ESLint的babel解析器的封装。env用于配置预定义的环境变量，此处指定了浏览器和Node.js以及ES6语法中所有的环境变量。parserOptions用于想要支持的JavaScript语言选项，此处指定了ecmaVersion和sourceType，分别表示启用ES6语法以及ECMAScript模块。extends用于当前配置继承何种规范，此处，使用airbnb公司开源的eslint-config-airbnb规范，<br>eslint-config-airbnb规范默认包含了ES6+的语法以及React的语法，它依赖于eslint、eslint-plugin-import、eslint-plugin-react以及eslint-plugin-jsx-i11y等npm包，安装时需要一起安装。<br>使用npm5+的版本安装eslint-config-airbnb：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npx install-peerdeps --dev eslint-config-airbnb</span><br></pre></td></tr></table></figure>\n<p>rules即是配置的一系列规则，如果你不想使用airbnb中的某项规范，你可以在rules进行配置。下面列举示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;rules&quot;: &#123;</span><br><span class=\"line\">  &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class=\"line\">  &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>“semi”和“quotes”是ESLint中规则的名称，第一个词是错误级别，可以使用下面的值之一：</p>\n<p>“off” or 0 ：关闭规则;</p>\n<p>“warn” or 1 ：将规则视为一个警告（不会影响退出码）;</p>\n<p>“error” or 2 ：将规则视为一个错误 (退出码为1);</p>\n<p>也可以写成如下的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;rules&quot;: &#123;</span><br><span class=\"line\">  &quot;semi&quot;: [2],</span><br><span class=\"line\">  &quot;quotes&quot;: [2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了继承，你还可以使用第三方插件来配置规则，通过plugins来配置需要的插件列表，以eslint-plugin-react为例，配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">     &quot;react&quot;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置完成后，我们希望能在每次修改代码后再次编译之前，能够对代码进行自动检查，先安装eslint-loader：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install eslint-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>增加Webpack配置：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>,</span><br><span class=\"line\">        test: <span class=\"regexp\">/.(js|jsx)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">        exclude: [</span><br><span class=\"line\">          path.resolve(__dirname, <span class=\"string\">'../node_modules'</span>)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Webpack使用babel-loader解析React的代码，增加eslint-loader的配置，enforce设置为pre可以让Webpack在使用babel编译之前运行eslint进行代码检查。</p>\n<p>eslint还提供了自动修复代码错误的能力，执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">eslint --fix</span><br></pre></td></tr></table></figure>\n<p>eslint会自动修复代码中的问题，但不是所有的问题都能被修复，剩余未被修复的问题会列出。</p>\n<p>ESLint还可以结合编辑器进行使用，首先保证使用了npm安装了eslint以及生成了.eslintrc配置文件，以WebStorm编辑器为例，<br>配置：</p>\n<blockquote>\n<p>File -&gt; Settings<br>Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; ESLint</p>\n</blockquote>\n<p>勾选Enable即可。WebStorm就会在编写代码的时候进行提示，如果不符合ESLint规则则会进行颜色标注，让你更早发现代码问题。<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_472.png\" alt=\"eslint\"><br>VSCode需要安装eslint插件才能对代码进行提示，在此不做赘述。</p>\n<h3 id=\"EditorConfig\"><a href=\"#EditorConfig\" class=\"headerlink\" title=\"EditorConfig\"></a>EditorConfig</h3><p>不同的操作系统和编辑器对于文本的格式的支持会有一定的区别，如果不统一一些规范，可能在团队协作的时候每次更新下来别人的代码就会一大堆报错。<br>EditorConfig是一种多编辑器插件，用于帮助开发者在不同的操作系统、编辑器和IDE之间定义和维护统一的代码风格。EditorConfig包含一个用于定义代码风格的配置文件和对应的编辑器插件，编辑器插件可以读取配置文件并对代码进行格式化。<br>EditorConfig的配置文件是.editorconfig，通常放置在项目根目录下。EdtorConfig插件对在文件夹的每一级目录下查找.editorconfig文件，直到查找到.editorconfig中包含root=true。<br>下面是一份.editorconfig配置文件：（注意：不是每种插件都支持下列所有属性）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">root = true</span><br><span class=\"line\"></span><br><span class=\"line\">[*]</span><br><span class=\"line\">charset = utf-8</span><br><span class=\"line\">indent_style = space</span><br><span class=\"line\">indent_size = 2</span><br><span class=\"line\">end_of_line = lf</span><br><span class=\"line\">insert_final_newline = true</span><br><span class=\"line\">trim_trailing_whitespace = true</span><br></pre></td></tr></table></figure>\n<p>root为true表示是最顶层的配置文件，<br>[*]用于匹配需要格式化的代码，charset指定编码格式为utf-8,intent_style指定缩进风格为空格，还可以选择tab，indent_size用于指定缩进的列数，end_of_line指定换行符为lf，在Linux和Windows下可能会因为换行符lf和crlf的不一致导致代码在版本管理工具下报错，insert_final_newline设为true表示文件以一个空白行结尾，<br>trim_trailing_whitespace设为true会去除换行行首的任意空白字符。</p>\n<p>Webstorm编辑器默认已经内置了EditorConfig的插件支持，只需要编写配置文件即可，VSCode需要下载EditorConfig的插件使用。</p>\n<h3 id=\"与版本管理工具结合\"><a href=\"#与版本管理工具结合\" class=\"headerlink\" title=\"与版本管理工具结合\"></a>与版本管理工具结合</h3><p>以版本管理工具Git为例，当版本库中出现commit、push等特殊事件时，都会触发执行一个或者多个的Shell脚本，称之为git钩子，存放在.git/hooks目录下，钩子从执行顺序上分为两类，前置（pre）和后置（post），分别发生在动作调用前后。<br>ESLint结合版本管理工具Git可以最大程度控制每个人的规范，在git commit代码的时候，使用git hook调用ESLint进行代码规范验证，这样可以保证团队协作的代码是符合代码规范的，不规范的代码无法提交到仓库。</p>\n<p>配置Git钩子的过程比较繁琐，我们可以使用husky这个工具来简化配置，husky使用如下：</p>\n<p>安装依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i husky --save-dev</span><br></pre></td></tr></table></figure>\n<p>修改package.json，增加script配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">      &quot;precommit&quot;: &quot;eslint client/**/*.js&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尝试Git提交，会自动使用eslint进行校验：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_468.png\" alt=\"husky\"></p>\n<p>但是这样会出现新的问题：如果一个老项目刚开始使用这种方式进行代码校验，势必会出现很多代码校验不通过的情况。那么最好的实现应该是开发者在commit代码的时候只校验自己提交的部分，lint-staged解决了这个问题，statged指Git中的待提交区，使用git add然后git commit的时候，你的代码会经过待提交区。<br>lint-staged使用方法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install lint-staged --save-dev</span><br></pre></td></tr></table></figure>\n<p>修改package.json中的script配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;precommit&quot;: &quot;lint-staged&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;client/**/*.js&quot;: &quot;eslint&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用如下配置自动修复错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;precommit&quot;: &quot;lint-staged&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;client/**/*.js&quot;: [&quot;eslint --fix&quot;, &quot;git add&quot;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>husky会在.git/hooks中添加pre-commit钩子，当开发者执行git add将代码提交到暂存区后，再执行git commit操作时，触发pre-commit钩子，开始执行npm run precommit命令，即lint-staged命令，lint-staged利用配置的文件过滤路径如（src/*<em>/</em>.js），对暂存区文件依次进行匹配，运行eslint –fix自动修复错误，并将修改添加到暂存区。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_473.png\" alt=\"lint\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本，而前端工程化可以让这件事情变得更简单。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本。本文介绍了ESLint规范、EditorConfig配置、Git控制代码规范等工程化实践在代码规范中的运用。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\" alt=\"image\"></p>","more":"<p>现代前端技术飞速发展，前端已进入了以效率和质量为核心的工程化时代，各种自动化工具和技术的使用大大提高了开发效率。在团队协作中，编码规范至关重要，统一的编码规范可以降低代码维护的成本，但是，纯手工检查代码规范费时费力且难以保证准确性，因此，针对代码规范的自动化工具应运而生，从最早的JSLint，到JSHint，再到今天的ESLint，代码规范工具变得越来越成熟。再结合WebStorm、VSCode等编辑器可以在编写代码的时候自动提醒错误，在开发阶段就避免错误，提高开发效率。本文主要讨论前端工程化在代码规范上的一些实践。</p>\n<h3 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p>ESLint是当前最流行的代码规范检查工具，随着ECMAScript版本一直更新，通过配置检查规则来对代码进行规范检查，具有丰富的插件生态，也可以使用已有的规范以及进行自定义规则，可以满足大部分团队的需求。</p>\n<p>下面介绍在react项目中如何使用ESLint。</p>\n<p>首先，使用webpack搭建一个react的项目，在此不对具体搭建过程做具体介绍，然后使用npm安装eslint：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install eslint babel-eslint --save-dev</span><br></pre></td></tr></table></figure>\n<p>在项目根目录下新建.eslintrc文件，用于配置eslint进行代码规范检查的规则，下面是用于react项目的基本配置示例：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"parser\"</span>: <span class=\"string\">\"babel-eslint\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"env\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"browser\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"es6\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"node\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"extends\"</span>: <span class=\"string\">\"airbnb\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"react/jsx-filename-extension\"</span>: [<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，parser用于指定eslint用来解析代码的解析器，babel-eslint是一个用于兼容ESLint的babel解析器的封装。env用于配置预定义的环境变量，此处指定了浏览器和Node.js以及ES6语法中所有的环境变量。parserOptions用于想要支持的JavaScript语言选项，此处指定了ecmaVersion和sourceType，分别表示启用ES6语法以及ECMAScript模块。extends用于当前配置继承何种规范，此处，使用airbnb公司开源的eslint-config-airbnb规范，<br>eslint-config-airbnb规范默认包含了ES6+的语法以及React的语法，它依赖于eslint、eslint-plugin-import、eslint-plugin-react以及eslint-plugin-jsx-i11y等npm包，安装时需要一起安装。<br>使用npm5+的版本安装eslint-config-airbnb：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npx install-peerdeps --dev eslint-config-airbnb</span><br></pre></td></tr></table></figure>\n<p>rules即是配置的一系列规则，如果你不想使用airbnb中的某项规范，你可以在rules进行配置。下面列举示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;rules&quot;: &#123;</span><br><span class=\"line\">  &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class=\"line\">  &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>“semi”和“quotes”是ESLint中规则的名称，第一个词是错误级别，可以使用下面的值之一：</p>\n<p>“off” or 0 ：关闭规则;</p>\n<p>“warn” or 1 ：将规则视为一个警告（不会影响退出码）;</p>\n<p>“error” or 2 ：将规则视为一个错误 (退出码为1);</p>\n<p>也可以写成如下的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;rules&quot;: &#123;</span><br><span class=\"line\">  &quot;semi&quot;: [2],</span><br><span class=\"line\">  &quot;quotes&quot;: [2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了继承，你还可以使用第三方插件来配置规则，通过plugins来配置需要的插件列表，以eslint-plugin-react为例，配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">     &quot;react&quot;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置完成后，我们希望能在每次修改代码后再次编译之前，能够对代码进行自动检查，先安装eslint-loader：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install eslint-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>增加Webpack配置：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>,</span><br><span class=\"line\">        test: <span class=\"regexp\">/.(js|jsx)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">        exclude: [</span><br><span class=\"line\">          path.resolve(__dirname, <span class=\"string\">'../node_modules'</span>)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Webpack使用babel-loader解析React的代码，增加eslint-loader的配置，enforce设置为pre可以让Webpack在使用babel编译之前运行eslint进行代码检查。</p>\n<p>eslint还提供了自动修复代码错误的能力，执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">eslint --fix</span><br></pre></td></tr></table></figure>\n<p>eslint会自动修复代码中的问题，但不是所有的问题都能被修复，剩余未被修复的问题会列出。</p>\n<p>ESLint还可以结合编辑器进行使用，首先保证使用了npm安装了eslint以及生成了.eslintrc配置文件，以WebStorm编辑器为例，<br>配置：</p>\n<blockquote>\n<p>File -&gt; Settings<br>Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; ESLint</p>\n</blockquote>\n<p>勾选Enable即可。WebStorm就会在编写代码的时候进行提示，如果不符合ESLint规则则会进行颜色标注，让你更早发现代码问题。<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_472.png\" alt=\"eslint\"><br>VSCode需要安装eslint插件才能对代码进行提示，在此不做赘述。</p>\n<h3 id=\"EditorConfig\"><a href=\"#EditorConfig\" class=\"headerlink\" title=\"EditorConfig\"></a>EditorConfig</h3><p>不同的操作系统和编辑器对于文本的格式的支持会有一定的区别，如果不统一一些规范，可能在团队协作的时候每次更新下来别人的代码就会一大堆报错。<br>EditorConfig是一种多编辑器插件，用于帮助开发者在不同的操作系统、编辑器和IDE之间定义和维护统一的代码风格。EditorConfig包含一个用于定义代码风格的配置文件和对应的编辑器插件，编辑器插件可以读取配置文件并对代码进行格式化。<br>EditorConfig的配置文件是.editorconfig，通常放置在项目根目录下。EdtorConfig插件对在文件夹的每一级目录下查找.editorconfig文件，直到查找到.editorconfig中包含root=true。<br>下面是一份.editorconfig配置文件：（注意：不是每种插件都支持下列所有属性）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">root = true</span><br><span class=\"line\"></span><br><span class=\"line\">[*]</span><br><span class=\"line\">charset = utf-8</span><br><span class=\"line\">indent_style = space</span><br><span class=\"line\">indent_size = 2</span><br><span class=\"line\">end_of_line = lf</span><br><span class=\"line\">insert_final_newline = true</span><br><span class=\"line\">trim_trailing_whitespace = true</span><br></pre></td></tr></table></figure>\n<p>root为true表示是最顶层的配置文件，<br>[*]用于匹配需要格式化的代码，charset指定编码格式为utf-8,intent_style指定缩进风格为空格，还可以选择tab，indent_size用于指定缩进的列数，end_of_line指定换行符为lf，在Linux和Windows下可能会因为换行符lf和crlf的不一致导致代码在版本管理工具下报错，insert_final_newline设为true表示文件以一个空白行结尾，<br>trim_trailing_whitespace设为true会去除换行行首的任意空白字符。</p>\n<p>Webstorm编辑器默认已经内置了EditorConfig的插件支持，只需要编写配置文件即可，VSCode需要下载EditorConfig的插件使用。</p>\n<h3 id=\"与版本管理工具结合\"><a href=\"#与版本管理工具结合\" class=\"headerlink\" title=\"与版本管理工具结合\"></a>与版本管理工具结合</h3><p>以版本管理工具Git为例，当版本库中出现commit、push等特殊事件时，都会触发执行一个或者多个的Shell脚本，称之为git钩子，存放在.git/hooks目录下，钩子从执行顺序上分为两类，前置（pre）和后置（post），分别发生在动作调用前后。<br>ESLint结合版本管理工具Git可以最大程度控制每个人的规范，在git commit代码的时候，使用git hook调用ESLint进行代码规范验证，这样可以保证团队协作的代码是符合代码规范的，不规范的代码无法提交到仓库。</p>\n<p>配置Git钩子的过程比较繁琐，我们可以使用husky这个工具来简化配置，husky使用如下：</p>\n<p>安装依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i husky --save-dev</span><br></pre></td></tr></table></figure>\n<p>修改package.json，增加script配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">      &quot;precommit&quot;: &quot;eslint client/**/*.js&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尝试Git提交，会自动使用eslint进行校验：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_468.png\" alt=\"husky\"></p>\n<p>但是这样会出现新的问题：如果一个老项目刚开始使用这种方式进行代码校验，势必会出现很多代码校验不通过的情况。那么最好的实现应该是开发者在commit代码的时候只校验自己提交的部分，lint-staged解决了这个问题，statged指Git中的待提交区，使用git add然后git commit的时候，你的代码会经过待提交区。<br>lint-staged使用方法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install lint-staged --save-dev</span><br></pre></td></tr></table></figure>\n<p>修改package.json中的script配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;precommit&quot;: &quot;lint-staged&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;client/**/*.js&quot;: &quot;eslint&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用如下配置自动修复错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;precommit&quot;: &quot;lint-staged&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;client/**/*.js&quot;: [&quot;eslint --fix&quot;, &quot;git add&quot;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>husky会在.git/hooks中添加pre-commit钩子，当开发者执行git add将代码提交到暂存区后，再执行git commit操作时，触发pre-commit钩子，开始执行npm run precommit命令，即lint-staged命令，lint-staged利用配置的文件过滤路径如（src/*<em>/</em>.js），对暂存区文件依次进行匹配，运行eslint –fix自动修复错误，并将修改添加到暂存区。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_473.png\" alt=\"lint\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>代码是写给人看的，顺便让机器运行。遵循统一的代码规范在团队协作中可以极大提高开发效率，降低代码维护成本，而前端工程化可以让这件事情变得更简单。</p>"},{"title":"基于HTML5实现跨文档通信","date":"2017-08-25T12:56:14.000Z","banner":"http://img.yanyuanfe.cn/Creating-a-HTML5-Flipbook.jpg","_content":"\n\n> 当我们谈论Web通信的时候，实际上谈论的是两个略有不同的系统：跨文档通信(cross-document messaging)和通道通信(channel messaging)。跨文档通信就是我们国内更为熟知的HTML5 window.postMessage()应用的那种通信；通道通信也被称为”MessageChannel”. 伴随着server-sent事件以及web sockets, 跨文档通信和通道通信成为HTML5 通信接口“套件”中有用的一部分。\n\n![image](http://img.yanyuanfe.cn/Creating-a-HTML5-Flipbook.jpg)\n\n<!--more-->\n\n### 写在前面\n曾经在Web开发中遇到这样一个需求，你的网页中需要嵌入一个跨域的iframe页面，iframe提供了点击的按钮，点击按钮触发事件，需要调用你的网页的一个方法来处理点击事件。但是，基于浏览器的同源策略，Web浏览器不允许窗口间的通信。同源策略指的是：在页面中，从某一个域加载的脚本不能访问从另一个域加载的窗口内容。虽说同源策略在很多情况下能保护我们的信息安全，但是在很多情况下，我们确实需要在网页中嵌入来自其他网站的内容。HTML5利用跨文档通信满足了这种复杂需求。借助跨文档通信API中的postMessage方法与message事件，能在两个页面之间创建一个受控制的通信通道。\n\n### 用法\n从MDN(https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)的文档里可以详细了解postMessage的用法：\n\notherWindow.postMessage（message, targetOrigin, [transfer]）;\n\npostMessage属于window的一个方法。\notherWindow: 代表其他窗口的一个引用，其值可以是iframe的contentWindow属性、执行window.open返回的窗口对象、命名过或数值索引的window.iframes。\n\nmessage: 指将要发送的消息本身。大部分浏览器都支持发送各种数据类型的消息。\n\ntargetOrigin: 发送消息的目标窗口的域名，它可以是一个URI或者是通配符'*'。消息发送时，如果目标窗口的协议、主机地址或端口三者任意一项与targetOrigin的值不匹配，那么消息将不会被发送。这也是HTML5对于跨文档通信的一种安全防御措施。\n\ntransfer：可选参数，基本不会使用到，在此不做说明。\n\n当目标窗口接收到消息时，message事件将会触发。对于DOM事件，可以使用body元素的onmessage属性来进行处理，或者直接利用addEventListener：\n\n\n``` js\nwindow.addEventListener('message', handleMessage, false);\n\nfunction handleMessage(event) {\n    console.log(event);\n    var origin = event.origin || event.originalEvent.orgin;\n    if(origin ! == 'http://example.org:8080') return;\n}\n\n```\n\n \n事件对象event的属性包括：\n\ndata：从其他窗口传递过来的消息。\n\norigin： 调用postMessage时消息发送方窗口的origin。这个字符串由协议、'://'、域名、':端口号'拼接而成。\n\nsource: 对发送消息的窗口对象的引用，可以使用它来建立两个不同origin的窗口之间的双向通信。\n\n### 示例\n在本地建立app.html文件，内嵌一个位于云服务器上的跨域iframe页面page.html，iframe中包含一个按钮，在示例中，实现iframe页面和本地页面的跨文档通信。\n\n> page.html\n \n \n``` html\n<body>\n    <div class=\"container\">\n        \n        <div class=\"column-2\">\n            \n            <div class=\"button\">\n                <button class=\"order-but\" onClick=\"orderNow()\">立即预订</button>\n            </div>\n        </div>\n    </div>\n</body>\n```\n``` js\n<script type=\"text/javascript\">\n\nvar orderNow = function() {  \n    console.log(window.parent)\n    window.parent.postMessage('order', '*')\n}\n\nwindow.addEventListener('message', handleMessage, false);\n\nfunction handleMessage(event) {\n    console.log(event);\n    var origin = event.origin || event.originalEvent.orgin;\n    if(origin ! == 'http://example.org:8080') return;\n}\n</script>\n```\n \n在page.html中，点击按钮触发点击事件，在点击事件的方法中，将会执行postMessage向iframe的父页面发送一条消息。在这里，window.parent是iframe的父级页面，字符串'order'为将要发送的消息，目标窗口域名为通配符'*'，表示任何域名。\n同时，在window上绑定事件监听器，监听其他页面发送的消息。\n\n> app.html\n\n\n``` html\n<body>\n    <div class=\"container\">\n        <iframe src=\"http://123.206.14.146/postmessage.page.html\" frameborder=\"0\" id=\"external-frame\" width=\"100%\" height=\"500px\"></iframe>\n    </div>\n    <script>\n        window.addEventListener('message', handleMessage, false)\n\n        function handleMessage(event) {\n            console.log(event);\n            var origin = event.origin;\n            window.frames[0].postmessage('ok', origin);\n        }\n    </script>\n</body>\n```\n\napp.html位于本地localhost，在此文件中，嵌入位于云服务器上的iframe页面page.html,iframe向app.html发送消息，那么app.html该如何接收消息呢？在window上监听message事件。当接收到消息时，使用postMessage对iframe再发送一个回复消息。\n\n在WebStorm中预览app.html，点击iframe中的按钮，控制台打印出如下信息。\n \n从控制台打印出的log可以看到，MessageEvent主要有三个属性：\n![image](http://img.yanyuanfe.cn/console.png)\n\ndata： 传递的消息；\n\norigin： 发送消息的源，由协议+主机名+端口号组成；\n\nsource： 发送消息的窗口对象；\n\n在上面的示例，使用postMessage简单地实现了跨文档的消息传递。\n \n### 注意\n\npostMessage是一个很实用的功能，但是使用不当也会暴露许多安全问题，所以在使用的时候需要注意：\n\n1、 otherWindow.postMessage（message, targetOrigin, [transfer]）;\ntargetOrigin参数最好不要使用通配符\"*\",应该使用受信任的域名；\n\n2、处理message事件时，需要对发送消息的源event.origin进行校验 ，避免产生安全问题。\n\n\n``` js\nwindow.addEventListener('message', handleMessage, false);\n\nfunction handleMessage(event) {\n    console.log(event);\n    var origin = event.origin || event.originalEvent.orgin;\n    if(origin ! == 'http://example.org:8080') return;\n}\n\n```\n\n \n### 最后\nHTML5的postMessage不仅仅可以实现跨文档通信，跨域通信、多窗口通信、当前页和新窗口之间的通信都可以用如此简单的方式实现。如此强大的功能，那么其兼容性如何呢？如下：\n![image](http://img.yanyuanfe.cn/caniuse.png)\n \n可以看出，postMessage已经支持大部分浏览器，需要注意的是，在IE8、9和Firefox6及其以下版本只支持字符串作为传递的消息数据。\n","source":"_posts/基于HTML5实现跨文档通信.md","raw":"---\ntitle: 基于HTML5实现跨文档通信\ndate: 2017-8-25 20:56:14\nbanner: http://img.yanyuanfe.cn/Creating-a-HTML5-Flipbook.jpg\ntags:\n\t- HTML5\n---\n\n\n> 当我们谈论Web通信的时候，实际上谈论的是两个略有不同的系统：跨文档通信(cross-document messaging)和通道通信(channel messaging)。跨文档通信就是我们国内更为熟知的HTML5 window.postMessage()应用的那种通信；通道通信也被称为”MessageChannel”. 伴随着server-sent事件以及web sockets, 跨文档通信和通道通信成为HTML5 通信接口“套件”中有用的一部分。\n\n![image](http://img.yanyuanfe.cn/Creating-a-HTML5-Flipbook.jpg)\n\n<!--more-->\n\n### 写在前面\n曾经在Web开发中遇到这样一个需求，你的网页中需要嵌入一个跨域的iframe页面，iframe提供了点击的按钮，点击按钮触发事件，需要调用你的网页的一个方法来处理点击事件。但是，基于浏览器的同源策略，Web浏览器不允许窗口间的通信。同源策略指的是：在页面中，从某一个域加载的脚本不能访问从另一个域加载的窗口内容。虽说同源策略在很多情况下能保护我们的信息安全，但是在很多情况下，我们确实需要在网页中嵌入来自其他网站的内容。HTML5利用跨文档通信满足了这种复杂需求。借助跨文档通信API中的postMessage方法与message事件，能在两个页面之间创建一个受控制的通信通道。\n\n### 用法\n从MDN(https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)的文档里可以详细了解postMessage的用法：\n\notherWindow.postMessage（message, targetOrigin, [transfer]）;\n\npostMessage属于window的一个方法。\notherWindow: 代表其他窗口的一个引用，其值可以是iframe的contentWindow属性、执行window.open返回的窗口对象、命名过或数值索引的window.iframes。\n\nmessage: 指将要发送的消息本身。大部分浏览器都支持发送各种数据类型的消息。\n\ntargetOrigin: 发送消息的目标窗口的域名，它可以是一个URI或者是通配符'*'。消息发送时，如果目标窗口的协议、主机地址或端口三者任意一项与targetOrigin的值不匹配，那么消息将不会被发送。这也是HTML5对于跨文档通信的一种安全防御措施。\n\ntransfer：可选参数，基本不会使用到，在此不做说明。\n\n当目标窗口接收到消息时，message事件将会触发。对于DOM事件，可以使用body元素的onmessage属性来进行处理，或者直接利用addEventListener：\n\n\n``` js\nwindow.addEventListener('message', handleMessage, false);\n\nfunction handleMessage(event) {\n    console.log(event);\n    var origin = event.origin || event.originalEvent.orgin;\n    if(origin ! == 'http://example.org:8080') return;\n}\n\n```\n\n \n事件对象event的属性包括：\n\ndata：从其他窗口传递过来的消息。\n\norigin： 调用postMessage时消息发送方窗口的origin。这个字符串由协议、'://'、域名、':端口号'拼接而成。\n\nsource: 对发送消息的窗口对象的引用，可以使用它来建立两个不同origin的窗口之间的双向通信。\n\n### 示例\n在本地建立app.html文件，内嵌一个位于云服务器上的跨域iframe页面page.html，iframe中包含一个按钮，在示例中，实现iframe页面和本地页面的跨文档通信。\n\n> page.html\n \n \n``` html\n<body>\n    <div class=\"container\">\n        \n        <div class=\"column-2\">\n            \n            <div class=\"button\">\n                <button class=\"order-but\" onClick=\"orderNow()\">立即预订</button>\n            </div>\n        </div>\n    </div>\n</body>\n```\n``` js\n<script type=\"text/javascript\">\n\nvar orderNow = function() {  \n    console.log(window.parent)\n    window.parent.postMessage('order', '*')\n}\n\nwindow.addEventListener('message', handleMessage, false);\n\nfunction handleMessage(event) {\n    console.log(event);\n    var origin = event.origin || event.originalEvent.orgin;\n    if(origin ! == 'http://example.org:8080') return;\n}\n</script>\n```\n \n在page.html中，点击按钮触发点击事件，在点击事件的方法中，将会执行postMessage向iframe的父页面发送一条消息。在这里，window.parent是iframe的父级页面，字符串'order'为将要发送的消息，目标窗口域名为通配符'*'，表示任何域名。\n同时，在window上绑定事件监听器，监听其他页面发送的消息。\n\n> app.html\n\n\n``` html\n<body>\n    <div class=\"container\">\n        <iframe src=\"http://123.206.14.146/postmessage.page.html\" frameborder=\"0\" id=\"external-frame\" width=\"100%\" height=\"500px\"></iframe>\n    </div>\n    <script>\n        window.addEventListener('message', handleMessage, false)\n\n        function handleMessage(event) {\n            console.log(event);\n            var origin = event.origin;\n            window.frames[0].postmessage('ok', origin);\n        }\n    </script>\n</body>\n```\n\napp.html位于本地localhost，在此文件中，嵌入位于云服务器上的iframe页面page.html,iframe向app.html发送消息，那么app.html该如何接收消息呢？在window上监听message事件。当接收到消息时，使用postMessage对iframe再发送一个回复消息。\n\n在WebStorm中预览app.html，点击iframe中的按钮，控制台打印出如下信息。\n \n从控制台打印出的log可以看到，MessageEvent主要有三个属性：\n![image](http://img.yanyuanfe.cn/console.png)\n\ndata： 传递的消息；\n\norigin： 发送消息的源，由协议+主机名+端口号组成；\n\nsource： 发送消息的窗口对象；\n\n在上面的示例，使用postMessage简单地实现了跨文档的消息传递。\n \n### 注意\n\npostMessage是一个很实用的功能，但是使用不当也会暴露许多安全问题，所以在使用的时候需要注意：\n\n1、 otherWindow.postMessage（message, targetOrigin, [transfer]）;\ntargetOrigin参数最好不要使用通配符\"*\",应该使用受信任的域名；\n\n2、处理message事件时，需要对发送消息的源event.origin进行校验 ，避免产生安全问题。\n\n\n``` js\nwindow.addEventListener('message', handleMessage, false);\n\nfunction handleMessage(event) {\n    console.log(event);\n    var origin = event.origin || event.originalEvent.orgin;\n    if(origin ! == 'http://example.org:8080') return;\n}\n\n```\n\n \n### 最后\nHTML5的postMessage不仅仅可以实现跨文档通信，跨域通信、多窗口通信、当前页和新窗口之间的通信都可以用如此简单的方式实现。如此强大的功能，那么其兼容性如何呢？如下：\n![image](http://img.yanyuanfe.cn/caniuse.png)\n \n可以看出，postMessage已经支持大部分浏览器，需要注意的是，在IE8、9和Firefox6及其以下版本只支持字符串作为传递的消息数据。\n","slug":"基于HTML5实现跨文档通信","published":1,"updated":"2020-07-16T13:56:47.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenns0013p70vifdugm17","content":"<blockquote>\n<p>当我们谈论Web通信的时候，实际上谈论的是两个略有不同的系统：跨文档通信(cross-document messaging)和通道通信(channel messaging)。跨文档通信就是我们国内更为熟知的HTML5 window.postMessage()应用的那种通信；通道通信也被称为”MessageChannel”. 伴随着server-sent事件以及web sockets, 跨文档通信和通道通信成为HTML5 通信接口“套件”中有用的一部分。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/Creating-a-HTML5-Flipbook.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>曾经在Web开发中遇到这样一个需求，你的网页中需要嵌入一个跨域的iframe页面，iframe提供了点击的按钮，点击按钮触发事件，需要调用你的网页的一个方法来处理点击事件。但是，基于浏览器的同源策略，Web浏览器不允许窗口间的通信。同源策略指的是：在页面中，从某一个域加载的脚本不能访问从另一个域加载的窗口内容。虽说同源策略在很多情况下能保护我们的信息安全，但是在很多情况下，我们确实需要在网页中嵌入来自其他网站的内容。HTML5利用跨文档通信满足了这种复杂需求。借助跨文档通信API中的postMessage方法与message事件，能在两个页面之间创建一个受控制的通信通道。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>从MDN(<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)的文档里可以详细了解postMessage的用法：\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)的文档里可以详细了解postMessage的用法：</a></p>\n<p>otherWindow.postMessage（message, targetOrigin, [transfer]）;</p>\n<p>postMessage属于window的一个方法。<br>otherWindow: 代表其他窗口的一个引用，其值可以是iframe的contentWindow属性、执行window.open返回的窗口对象、命名过或数值索引的window.iframes。</p>\n<p>message: 指将要发送的消息本身。大部分浏览器都支持发送各种数据类型的消息。</p>\n<p>targetOrigin: 发送消息的目标窗口的域名，它可以是一个URI或者是通配符’*’。消息发送时，如果目标窗口的协议、主机地址或端口三者任意一项与targetOrigin的值不匹配，那么消息将不会被发送。这也是HTML5对于跨文档通信的一种安全防御措施。</p>\n<p>transfer：可选参数，基本不会使用到，在此不做说明。</p>\n<p>当目标窗口接收到消息时，message事件将会触发。对于DOM事件，可以使用body元素的onmessage属性来进行处理，或者直接利用addEventListener：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> origin = event.origin || event.originalEvent.orgin;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(origin ! == <span class=\"string\">'http://example.org:8080'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事件对象event的属性包括：</p>\n<p>data：从其他窗口传递过来的消息。</p>\n<p>origin： 调用postMessage时消息发送方窗口的origin。这个字符串由协议、’://‘、域名、’:端口号’拼接而成。</p>\n<p>source: 对发送消息的窗口对象的引用，可以使用它来建立两个不同origin的窗口之间的双向通信。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>在本地建立app.html文件，内嵌一个位于云服务器上的跨域iframe页面page.html，iframe中包含一个按钮，在示例中，实现iframe页面和本地页面的跨文档通信。</p>\n<blockquote>\n<p>page.html</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"column-2\"</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"button\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-but\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">\"orderNow()\"</span>&gt;</span>立即预订<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> orderNow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.parent)</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.parent.postMessage(<span class=\"string\">'order'</span>, <span class=\"string\">'*'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> origin = event.origin || event.originalEvent.orgin;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(origin ! == <span class=\"string\">'http://example.org:8080'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在page.html中，点击按钮触发点击事件，在点击事件的方法中，将会执行postMessage向iframe的父页面发送一条消息。在这里，window.parent是iframe的父级页面，字符串’order’为将要发送的消息，目标窗口域名为通配符’*’，表示任何域名。<br>同时，在window上绑定事件监听器，监听其他页面发送的消息。</p>\n<blockquote>\n<p>app.html</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://123.206.14.146/postmessage.page.html\"</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"external-frame\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500px\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(event);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> origin = event.origin;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.frames[<span class=\"number\">0</span>].postmessage(<span class=\"string\">'ok'</span>, origin);</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>app.html位于本地localhost，在此文件中，嵌入位于云服务器上的iframe页面page.html,iframe向app.html发送消息，那么app.html该如何接收消息呢？在window上监听message事件。当接收到消息时，使用postMessage对iframe再发送一个回复消息。</p>\n<p>在WebStorm中预览app.html，点击iframe中的按钮，控制台打印出如下信息。</p>\n<p>从控制台打印出的log可以看到，MessageEvent主要有三个属性：<br><img src=\"http://img.yanyuanfe.cn/console.png\" alt=\"image\"></p>\n<p>data： 传递的消息；</p>\n<p>origin： 发送消息的源，由协议+主机名+端口号组成；</p>\n<p>source： 发送消息的窗口对象；</p>\n<p>在上面的示例，使用postMessage简单地实现了跨文档的消息传递。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>postMessage是一个很实用的功能，但是使用不当也会暴露许多安全问题，所以在使用的时候需要注意：</p>\n<p>1、 otherWindow.postMessage（message, targetOrigin, [transfer]）;<br>targetOrigin参数最好不要使用通配符”*”,应该使用受信任的域名；</p>\n<p>2、处理message事件时，需要对发送消息的源event.origin进行校验 ，避免产生安全问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> origin = event.origin || event.originalEvent.orgin;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(origin ! == <span class=\"string\">'http://example.org:8080'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>HTML5的postMessage不仅仅可以实现跨文档通信，跨域通信、多窗口通信、当前页和新窗口之间的通信都可以用如此简单的方式实现。如此强大的功能，那么其兼容性如何呢？如下：<br><img src=\"http://img.yanyuanfe.cn/caniuse.png\" alt=\"image\"></p>\n<p>可以看出，postMessage已经支持大部分浏览器，需要注意的是，在IE8、9和Firefox6及其以下版本只支持字符串作为传递的消息数据。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>当我们谈论Web通信的时候，实际上谈论的是两个略有不同的系统：跨文档通信(cross-document messaging)和通道通信(channel messaging)。跨文档通信就是我们国内更为熟知的HTML5 window.postMessage()应用的那种通信；通道通信也被称为”MessageChannel”. 伴随着server-sent事件以及web sockets, 跨文档通信和通道通信成为HTML5 通信接口“套件”中有用的一部分。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/Creating-a-HTML5-Flipbook.jpg\" alt=\"image\"></p>","more":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>曾经在Web开发中遇到这样一个需求，你的网页中需要嵌入一个跨域的iframe页面，iframe提供了点击的按钮，点击按钮触发事件，需要调用你的网页的一个方法来处理点击事件。但是，基于浏览器的同源策略，Web浏览器不允许窗口间的通信。同源策略指的是：在页面中，从某一个域加载的脚本不能访问从另一个域加载的窗口内容。虽说同源策略在很多情况下能保护我们的信息安全，但是在很多情况下，我们确实需要在网页中嵌入来自其他网站的内容。HTML5利用跨文档通信满足了这种复杂需求。借助跨文档通信API中的postMessage方法与message事件，能在两个页面之间创建一个受控制的通信通道。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>从MDN(<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)的文档里可以详细了解postMessage的用法：\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)的文档里可以详细了解postMessage的用法：</a></p>\n<p>otherWindow.postMessage（message, targetOrigin, [transfer]）;</p>\n<p>postMessage属于window的一个方法。<br>otherWindow: 代表其他窗口的一个引用，其值可以是iframe的contentWindow属性、执行window.open返回的窗口对象、命名过或数值索引的window.iframes。</p>\n<p>message: 指将要发送的消息本身。大部分浏览器都支持发送各种数据类型的消息。</p>\n<p>targetOrigin: 发送消息的目标窗口的域名，它可以是一个URI或者是通配符’*’。消息发送时，如果目标窗口的协议、主机地址或端口三者任意一项与targetOrigin的值不匹配，那么消息将不会被发送。这也是HTML5对于跨文档通信的一种安全防御措施。</p>\n<p>transfer：可选参数，基本不会使用到，在此不做说明。</p>\n<p>当目标窗口接收到消息时，message事件将会触发。对于DOM事件，可以使用body元素的onmessage属性来进行处理，或者直接利用addEventListener：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> origin = event.origin || event.originalEvent.orgin;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(origin ! == <span class=\"string\">'http://example.org:8080'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事件对象event的属性包括：</p>\n<p>data：从其他窗口传递过来的消息。</p>\n<p>origin： 调用postMessage时消息发送方窗口的origin。这个字符串由协议、’://‘、域名、’:端口号’拼接而成。</p>\n<p>source: 对发送消息的窗口对象的引用，可以使用它来建立两个不同origin的窗口之间的双向通信。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>在本地建立app.html文件，内嵌一个位于云服务器上的跨域iframe页面page.html，iframe中包含一个按钮，在示例中，实现iframe页面和本地页面的跨文档通信。</p>\n<blockquote>\n<p>page.html</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"column-2\"</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"button\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-but\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">\"orderNow()\"</span>&gt;</span>立即预订<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> orderNow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.parent)</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.parent.postMessage(<span class=\"string\">'order'</span>, <span class=\"string\">'*'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> origin = event.origin || event.originalEvent.orgin;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(origin ! == <span class=\"string\">'http://example.org:8080'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在page.html中，点击按钮触发点击事件，在点击事件的方法中，将会执行postMessage向iframe的父页面发送一条消息。在这里，window.parent是iframe的父级页面，字符串’order’为将要发送的消息，目标窗口域名为通配符’*’，表示任何域名。<br>同时，在window上绑定事件监听器，监听其他页面发送的消息。</p>\n<blockquote>\n<p>app.html</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://123.206.14.146/postmessage.page.html\"</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"external-frame\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500px\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(event);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> origin = event.origin;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.frames[<span class=\"number\">0</span>].postmessage(<span class=\"string\">'ok'</span>, origin);</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>app.html位于本地localhost，在此文件中，嵌入位于云服务器上的iframe页面page.html,iframe向app.html发送消息，那么app.html该如何接收消息呢？在window上监听message事件。当接收到消息时，使用postMessage对iframe再发送一个回复消息。</p>\n<p>在WebStorm中预览app.html，点击iframe中的按钮，控制台打印出如下信息。</p>\n<p>从控制台打印出的log可以看到，MessageEvent主要有三个属性：<br><img src=\"http://img.yanyuanfe.cn/console.png\" alt=\"image\"></p>\n<p>data： 传递的消息；</p>\n<p>origin： 发送消息的源，由协议+主机名+端口号组成；</p>\n<p>source： 发送消息的窗口对象；</p>\n<p>在上面的示例，使用postMessage简单地实现了跨文档的消息传递。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>postMessage是一个很实用的功能，但是使用不当也会暴露许多安全问题，所以在使用的时候需要注意：</p>\n<p>1、 otherWindow.postMessage（message, targetOrigin, [transfer]）;<br>targetOrigin参数最好不要使用通配符”*”,应该使用受信任的域名；</p>\n<p>2、处理message事件时，需要对发送消息的源event.origin进行校验 ，避免产生安全问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, handleMessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMessage</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> origin = event.origin || event.originalEvent.orgin;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(origin ! == <span class=\"string\">'http://example.org:8080'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>HTML5的postMessage不仅仅可以实现跨文档通信，跨域通信、多窗口通信、当前页和新窗口之间的通信都可以用如此简单的方式实现。如此强大的功能，那么其兼容性如何呢？如下：<br><img src=\"http://img.yanyuanfe.cn/caniuse.png\" alt=\"image\"></p>\n<p>可以看出，postMessage已经支持大部分浏览器，需要注意的是，在IE8、9和Firefox6及其以下版本只支持字符串作为传递的消息数据。</p>"},{"title":"微信网页授权功能开发总结","date":"2017-03-05T14:46:56.000Z","banner":"http://img.yanyuanfe.cn/wechat.png","_content":"\n\n\n> 在进行微信开发的时候，必须要输入外网域名，我们本地没法进行调试，这给我们造成很大的不方便，系统在开发阶段容易出现bug，如果服务器上的版本已经在运行了，我们不能在那基础上进行开发调试，所以能够在本地进行微信开发很重要。\n\n![image](http://img.yanyuanfe.cn/wechat.png)\n\n<!--more-->\n\n<div class=\"tip\">\n    最近h5项目中需要增加微信网页授权用户登陆的功能，在开发过程中遇到的一些问题总结如下。\n</div>\n\n### 微信web开发者工具\n微信推出了一个web开发工具，支持在本地开发环境调试授权登录、 模拟JSSDK权限校验、移动调试，用过之后感觉方便。\n\n微信web开发者工具地址：https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html\n\n下面推荐一个Linux用户的微信开发者工具，虽然没有微信自家的功能完备，基本的功能还是有的，使用过也不错。  \n\n[微信开发者工具（wechat_web_devtools）Linux版，微信小程序Linux版，支持最新微信小程序开发和微信网页开发](https://github.com/yuan1994/wechat_web_devtools)\n\n\n微信官方讲解很详细了，这里分享一些自己遇到的坑和技巧。\n\n### 关注公众号\n\n如果你使用微信Web调试工具进行网页开发，首先你需要关注你所调试的公众号和公众号安全助手两个公众号。\n\n### 绑定开发者账号\n\n你必须成为相应公众号的开发者才能进行调试。\n\n这个可能容易忘记，如果要用该工具，需要绑定开发者账号。\n\n登录微信公众平台，在微信公众号后台的左下侧进入开发者工具，进入微信Web开发者工具后，点击绑定开发者微信号，就可以绑定开发者账号了。\n\n### 网页授权域名\n\n这次开发的功能是用户通过微信授权进行登录，需要在公众平台配置网页授权域名。  \n\n登录微信公众平台，在微信公众号后台的左下侧进入开发>接口权限,找到网页授权获取用户基本信息的接口，点击修改，设置网页授权，首先需要上传微信提供的一个验证文件，然后才能填写域名。\n\n\n微信的授权回调域名的设置有一些限制：\n\n用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。\n注意事项：\n1. 回调页面域名或路径需使用字母、数字及“-”的组合（例：wx.qq.com或wx.qq.com/mp），不支持IP地址、端口号及短链域名。填写的域名或路径需与实际回调URL中的域名或路径相同。\n2. 填写的域名须通过ICP备案的验证。\n3. 将文件MP_verify_j9vcNn6PYoEcuoBT.txt（点击下载）上传至填写域名或路径指向的web服务器（或虚拟主机）的目录（若填写域名，将文件放置在域名根目录下，例如wx.qq.com/MP_verify_j9vcNn6PYoEcuoBT.txt；若填写路径，将文件放置在路径目录下，例如wx.qq.com/mp/MP_verify_j9vcNn6PYoEcuoBT.txt），并确保可以访问。\n如果要结合web开发工具在本地测试授权登录，需要将回调域名指向到本地，在类unix系统下可以通过修改/etc/hosts实现。\n\n### 修改 host 文件\n\n微信有JS接口安全域名和网页授权域名的限制，所以想要本地调试最重要的是解决这个问题。具体在右上角公众号名称-公众号设置-功能设置里面。\n\n想要把域名映射到本地显然是改 host 文件方便一些，因为你不太可能把线上的域名改成本地。\n\nLinux 下修改host：\n\n\n``` bash\n$ sudo vi /etc/hosts\n```\n\n```\n#127.0.0.1\tlocalhost\n127.0.0.1   ***.com\n```\n\n改完 host 之后保存，你就可以在微信Web开发者工具中调试本地代码了，如果是HTTPS的域名，你还需要在本机安装相关证书，然后再项目目录下的nginx.conf文件中设置:\n\n\n\n```\nhttp{\n\tserver {\n\t\tlisten       443 ssl;\n\t}\n}\n```\n\n\n### ngrok\n这是什么鬼？它是国外开源的一款可实现内网穿透工具（服务端+客户端），即，开启后，访问公网ip或域名，将TCP链接转发到内网。所以，通过ngrok，可实现：\n访问域名，最终指向本地服务，那么修改本地代码，立即就可以看到效果，微信SDK要求的域名也能够满足了，微信SDK终于可以舒服的调试了。\n另外，ngrok可以和微信开发者工具一起使用。\n国内   [http://qydev.com/](http://qydev.com/)  \n 这个站点提供了免费服务，但还是希望大家能适当捐助，以帮助作者维持服务器费用，或者选择自行搭建ngrok服务。\n\n优点：\n\n任何人访问ngrok绑定的域名，都可以看到效果  \n\n缺点：\n\n公众号后台需要设置域名为ngrok绑定的域名\n依赖ngrok服务端+客户端，搭建这样一个调试环境成本略高\n\n[NATAPP](https://natapp.cn/)  \n  \n  一个基于ngrok的国内高速内网穿透服务,适用于微信开发调试,简单方便。\n\n\n### 如何区分微信浏览器\n\n\n``` js\nfunction isWexin() {\nconst ua = navigator.userAgent.toLowerCase();\n\nif (/micromessenger/.test(ua)) {\n  return true;\n}\n  return false;\n}\n```\n","source":"_posts/微信网页授权功能开发总结.md","raw":"---\ntitle: 微信网页授权功能开发总结\ndate: 2017-03-05 22:46:56\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/wechat.png\ntags:\n\t- 微信\n---\n\n\n\n> 在进行微信开发的时候，必须要输入外网域名，我们本地没法进行调试，这给我们造成很大的不方便，系统在开发阶段容易出现bug，如果服务器上的版本已经在运行了，我们不能在那基础上进行开发调试，所以能够在本地进行微信开发很重要。\n\n![image](http://img.yanyuanfe.cn/wechat.png)\n\n<!--more-->\n\n<div class=\"tip\">\n    最近h5项目中需要增加微信网页授权用户登陆的功能，在开发过程中遇到的一些问题总结如下。\n</div>\n\n### 微信web开发者工具\n微信推出了一个web开发工具，支持在本地开发环境调试授权登录、 模拟JSSDK权限校验、移动调试，用过之后感觉方便。\n\n微信web开发者工具地址：https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html\n\n下面推荐一个Linux用户的微信开发者工具，虽然没有微信自家的功能完备，基本的功能还是有的，使用过也不错。  \n\n[微信开发者工具（wechat_web_devtools）Linux版，微信小程序Linux版，支持最新微信小程序开发和微信网页开发](https://github.com/yuan1994/wechat_web_devtools)\n\n\n微信官方讲解很详细了，这里分享一些自己遇到的坑和技巧。\n\n### 关注公众号\n\n如果你使用微信Web调试工具进行网页开发，首先你需要关注你所调试的公众号和公众号安全助手两个公众号。\n\n### 绑定开发者账号\n\n你必须成为相应公众号的开发者才能进行调试。\n\n这个可能容易忘记，如果要用该工具，需要绑定开发者账号。\n\n登录微信公众平台，在微信公众号后台的左下侧进入开发者工具，进入微信Web开发者工具后，点击绑定开发者微信号，就可以绑定开发者账号了。\n\n### 网页授权域名\n\n这次开发的功能是用户通过微信授权进行登录，需要在公众平台配置网页授权域名。  \n\n登录微信公众平台，在微信公众号后台的左下侧进入开发>接口权限,找到网页授权获取用户基本信息的接口，点击修改，设置网页授权，首先需要上传微信提供的一个验证文件，然后才能填写域名。\n\n\n微信的授权回调域名的设置有一些限制：\n\n用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。\n注意事项：\n1. 回调页面域名或路径需使用字母、数字及“-”的组合（例：wx.qq.com或wx.qq.com/mp），不支持IP地址、端口号及短链域名。填写的域名或路径需与实际回调URL中的域名或路径相同。\n2. 填写的域名须通过ICP备案的验证。\n3. 将文件MP_verify_j9vcNn6PYoEcuoBT.txt（点击下载）上传至填写域名或路径指向的web服务器（或虚拟主机）的目录（若填写域名，将文件放置在域名根目录下，例如wx.qq.com/MP_verify_j9vcNn6PYoEcuoBT.txt；若填写路径，将文件放置在路径目录下，例如wx.qq.com/mp/MP_verify_j9vcNn6PYoEcuoBT.txt），并确保可以访问。\n如果要结合web开发工具在本地测试授权登录，需要将回调域名指向到本地，在类unix系统下可以通过修改/etc/hosts实现。\n\n### 修改 host 文件\n\n微信有JS接口安全域名和网页授权域名的限制，所以想要本地调试最重要的是解决这个问题。具体在右上角公众号名称-公众号设置-功能设置里面。\n\n想要把域名映射到本地显然是改 host 文件方便一些，因为你不太可能把线上的域名改成本地。\n\nLinux 下修改host：\n\n\n``` bash\n$ sudo vi /etc/hosts\n```\n\n```\n#127.0.0.1\tlocalhost\n127.0.0.1   ***.com\n```\n\n改完 host 之后保存，你就可以在微信Web开发者工具中调试本地代码了，如果是HTTPS的域名，你还需要在本机安装相关证书，然后再项目目录下的nginx.conf文件中设置:\n\n\n\n```\nhttp{\n\tserver {\n\t\tlisten       443 ssl;\n\t}\n}\n```\n\n\n### ngrok\n这是什么鬼？它是国外开源的一款可实现内网穿透工具（服务端+客户端），即，开启后，访问公网ip或域名，将TCP链接转发到内网。所以，通过ngrok，可实现：\n访问域名，最终指向本地服务，那么修改本地代码，立即就可以看到效果，微信SDK要求的域名也能够满足了，微信SDK终于可以舒服的调试了。\n另外，ngrok可以和微信开发者工具一起使用。\n国内   [http://qydev.com/](http://qydev.com/)  \n 这个站点提供了免费服务，但还是希望大家能适当捐助，以帮助作者维持服务器费用，或者选择自行搭建ngrok服务。\n\n优点：\n\n任何人访问ngrok绑定的域名，都可以看到效果  \n\n缺点：\n\n公众号后台需要设置域名为ngrok绑定的域名\n依赖ngrok服务端+客户端，搭建这样一个调试环境成本略高\n\n[NATAPP](https://natapp.cn/)  \n  \n  一个基于ngrok的国内高速内网穿透服务,适用于微信开发调试,简单方便。\n\n\n### 如何区分微信浏览器\n\n\n``` js\nfunction isWexin() {\nconst ua = navigator.userAgent.toLowerCase();\n\nif (/micromessenger/.test(ua)) {\n  return true;\n}\n  return false;\n}\n```\n","slug":"微信网页授权功能开发总结","published":1,"updated":"2020-07-16T13:56:47.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennt0015p70vjbd2epgs","content":"<blockquote>\n<p>在进行微信开发的时候，必须要输入外网域名，我们本地没法进行调试，这给我们造成很大的不方便，系统在开发阶段容易出现bug，如果服务器上的版本已经在运行了，我们不能在那基础上进行开发调试，所以能够在本地进行微信开发很重要。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/wechat.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<div class=\"tip\"><br>    最近h5项目中需要增加微信网页授权用户登陆的功能，在开发过程中遇到的一些问题总结如下。<br></div>\n\n<h3 id=\"微信web开发者工具\"><a href=\"#微信web开发者工具\" class=\"headerlink\" title=\"微信web开发者工具\"></a>微信web开发者工具</h3><p>微信推出了一个web开发工具，支持在本地开发环境调试授权登录、 模拟JSSDK权限校验、移动调试，用过之后感觉方便。</p>\n<p>微信web开发者工具地址：<a href=\"https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html</a></p>\n<p>下面推荐一个Linux用户的微信开发者工具，虽然没有微信自家的功能完备，基本的功能还是有的，使用过也不错。  </p>\n<p><a href=\"https://github.com/yuan1994/wechat_web_devtools\" target=\"_blank\" rel=\"noopener\">微信开发者工具（wechat_web_devtools）Linux版，微信小程序Linux版，支持最新微信小程序开发和微信网页开发</a></p>\n<p>微信官方讲解很详细了，这里分享一些自己遇到的坑和技巧。</p>\n<h3 id=\"关注公众号\"><a href=\"#关注公众号\" class=\"headerlink\" title=\"关注公众号\"></a>关注公众号</h3><p>如果你使用微信Web调试工具进行网页开发，首先你需要关注你所调试的公众号和公众号安全助手两个公众号。</p>\n<h3 id=\"绑定开发者账号\"><a href=\"#绑定开发者账号\" class=\"headerlink\" title=\"绑定开发者账号\"></a>绑定开发者账号</h3><p>你必须成为相应公众号的开发者才能进行调试。</p>\n<p>这个可能容易忘记，如果要用该工具，需要绑定开发者账号。</p>\n<p>登录微信公众平台，在微信公众号后台的左下侧进入开发者工具，进入微信Web开发者工具后，点击绑定开发者微信号，就可以绑定开发者账号了。</p>\n<h3 id=\"网页授权域名\"><a href=\"#网页授权域名\" class=\"headerlink\" title=\"网页授权域名\"></a>网页授权域名</h3><p>这次开发的功能是用户通过微信授权进行登录，需要在公众平台配置网页授权域名。  </p>\n<p>登录微信公众平台，在微信公众号后台的左下侧进入开发&gt;接口权限,找到网页授权获取用户基本信息的接口，点击修改，设置网页授权，首先需要上传微信提供的一个验证文件，然后才能填写域名。</p>\n<p>微信的授权回调域名的设置有一些限制：</p>\n<p>用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。<br>注意事项：</p>\n<ol>\n<li>回调页面域名或路径需使用字母、数字及“-”的组合（例：wx.qq.com或wx.qq.com/mp），不支持IP地址、端口号及短链域名。填写的域名或路径需与实际回调URL中的域名或路径相同。</li>\n<li>填写的域名须通过ICP备案的验证。</li>\n<li>将文件MP_verify_j9vcNn6PYoEcuoBT.txt（点击下载）上传至填写域名或路径指向的web服务器（或虚拟主机）的目录（若填写域名，将文件放置在域名根目录下，例如wx.qq.com/MP_verify_j9vcNn6PYoEcuoBT.txt；若填写路径，将文件放置在路径目录下，例如wx.qq.com/mp/MP_verify_j9vcNn6PYoEcuoBT.txt），并确保可以访问。<br>如果要结合web开发工具在本地测试授权登录，需要将回调域名指向到本地，在类unix系统下可以通过修改/etc/hosts实现。</li>\n</ol>\n<h3 id=\"修改-host-文件\"><a href=\"#修改-host-文件\" class=\"headerlink\" title=\"修改 host 文件\"></a>修改 host 文件</h3><p>微信有JS接口安全域名和网页授权域名的限制，所以想要本地调试最重要的是解决这个问题。具体在右上角公众号名称-公众号设置-功能设置里面。</p>\n<p>想要把域名映射到本地显然是改 host 文件方便一些，因为你不太可能把线上的域名改成本地。</p>\n<p>Linux 下修改host：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo vi /etc/hosts</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#127.0.0.1\tlocalhost</span><br><span class=\"line\">127.0.0.1   ***.com</span><br></pre></td></tr></table></figure>\n<p>改完 host 之后保存，你就可以在微信Web开发者工具中调试本地代码了，如果是HTTPS的域名，你还需要在本机安装相关证书，然后再项目目录下的nginx.conf文件中设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http&#123;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">\t\tlisten       443 ssl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ngrok\"><a href=\"#ngrok\" class=\"headerlink\" title=\"ngrok\"></a>ngrok</h3><p>这是什么鬼？它是国外开源的一款可实现内网穿透工具（服务端+客户端），即，开启后，访问公网ip或域名，将TCP链接转发到内网。所以，通过ngrok，可实现：<br>访问域名，最终指向本地服务，那么修改本地代码，立即就可以看到效果，微信SDK要求的域名也能够满足了，微信SDK终于可以舒服的调试了。<br>另外，ngrok可以和微信开发者工具一起使用。<br>国内   <a href=\"http://qydev.com/\" target=\"_blank\" rel=\"noopener\">http://qydev.com/</a><br> 这个站点提供了免费服务，但还是希望大家能适当捐助，以帮助作者维持服务器费用，或者选择自行搭建ngrok服务。</p>\n<p>优点：</p>\n<p>任何人访问ngrok绑定的域名，都可以看到效果  </p>\n<p>缺点：</p>\n<p>公众号后台需要设置域名为ngrok绑定的域名<br>依赖ngrok服务端+客户端，搭建这样一个调试环境成本略高</p>\n<p><a href=\"https://natapp.cn/\" target=\"_blank\" rel=\"noopener\">NATAPP</a>  </p>\n<p>  一个基于ngrok的国内高速内网穿透服务,适用于微信开发调试,简单方便。</p>\n<h3 id=\"如何区分微信浏览器\"><a href=\"#如何区分微信浏览器\" class=\"headerlink\" title=\"如何区分微信浏览器\"></a>如何区分微信浏览器</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isWexin</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ua = navigator.userAgent.toLowerCase();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"regexp\">/micromessenger/</span>.test(ua)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在进行微信开发的时候，必须要输入外网域名，我们本地没法进行调试，这给我们造成很大的不方便，系统在开发阶段容易出现bug，如果服务器上的版本已经在运行了，我们不能在那基础上进行开发调试，所以能够在本地进行微信开发很重要。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/wechat.png\" alt=\"image\"></p>","more":"<div class=\"tip\"><br>    最近h5项目中需要增加微信网页授权用户登陆的功能，在开发过程中遇到的一些问题总结如下。<br></div>\n\n<h3 id=\"微信web开发者工具\"><a href=\"#微信web开发者工具\" class=\"headerlink\" title=\"微信web开发者工具\"></a>微信web开发者工具</h3><p>微信推出了一个web开发工具，支持在本地开发环境调试授权登录、 模拟JSSDK权限校验、移动调试，用过之后感觉方便。</p>\n<p>微信web开发者工具地址：<a href=\"https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html</a></p>\n<p>下面推荐一个Linux用户的微信开发者工具，虽然没有微信自家的功能完备，基本的功能还是有的，使用过也不错。  </p>\n<p><a href=\"https://github.com/yuan1994/wechat_web_devtools\" target=\"_blank\" rel=\"noopener\">微信开发者工具（wechat_web_devtools）Linux版，微信小程序Linux版，支持最新微信小程序开发和微信网页开发</a></p>\n<p>微信官方讲解很详细了，这里分享一些自己遇到的坑和技巧。</p>\n<h3 id=\"关注公众号\"><a href=\"#关注公众号\" class=\"headerlink\" title=\"关注公众号\"></a>关注公众号</h3><p>如果你使用微信Web调试工具进行网页开发，首先你需要关注你所调试的公众号和公众号安全助手两个公众号。</p>\n<h3 id=\"绑定开发者账号\"><a href=\"#绑定开发者账号\" class=\"headerlink\" title=\"绑定开发者账号\"></a>绑定开发者账号</h3><p>你必须成为相应公众号的开发者才能进行调试。</p>\n<p>这个可能容易忘记，如果要用该工具，需要绑定开发者账号。</p>\n<p>登录微信公众平台，在微信公众号后台的左下侧进入开发者工具，进入微信Web开发者工具后，点击绑定开发者微信号，就可以绑定开发者账号了。</p>\n<h3 id=\"网页授权域名\"><a href=\"#网页授权域名\" class=\"headerlink\" title=\"网页授权域名\"></a>网页授权域名</h3><p>这次开发的功能是用户通过微信授权进行登录，需要在公众平台配置网页授权域名。  </p>\n<p>登录微信公众平台，在微信公众号后台的左下侧进入开发&gt;接口权限,找到网页授权获取用户基本信息的接口，点击修改，设置网页授权，首先需要上传微信提供的一个验证文件，然后才能填写域名。</p>\n<p>微信的授权回调域名的设置有一些限制：</p>\n<p>用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。<br>注意事项：</p>\n<ol>\n<li>回调页面域名或路径需使用字母、数字及“-”的组合（例：wx.qq.com或wx.qq.com/mp），不支持IP地址、端口号及短链域名。填写的域名或路径需与实际回调URL中的域名或路径相同。</li>\n<li>填写的域名须通过ICP备案的验证。</li>\n<li>将文件MP_verify_j9vcNn6PYoEcuoBT.txt（点击下载）上传至填写域名或路径指向的web服务器（或虚拟主机）的目录（若填写域名，将文件放置在域名根目录下，例如wx.qq.com/MP_verify_j9vcNn6PYoEcuoBT.txt；若填写路径，将文件放置在路径目录下，例如wx.qq.com/mp/MP_verify_j9vcNn6PYoEcuoBT.txt），并确保可以访问。<br>如果要结合web开发工具在本地测试授权登录，需要将回调域名指向到本地，在类unix系统下可以通过修改/etc/hosts实现。</li>\n</ol>\n<h3 id=\"修改-host-文件\"><a href=\"#修改-host-文件\" class=\"headerlink\" title=\"修改 host 文件\"></a>修改 host 文件</h3><p>微信有JS接口安全域名和网页授权域名的限制，所以想要本地调试最重要的是解决这个问题。具体在右上角公众号名称-公众号设置-功能设置里面。</p>\n<p>想要把域名映射到本地显然是改 host 文件方便一些，因为你不太可能把线上的域名改成本地。</p>\n<p>Linux 下修改host：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo vi /etc/hosts</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#127.0.0.1\tlocalhost</span><br><span class=\"line\">127.0.0.1   ***.com</span><br></pre></td></tr></table></figure>\n<p>改完 host 之后保存，你就可以在微信Web开发者工具中调试本地代码了，如果是HTTPS的域名，你还需要在本机安装相关证书，然后再项目目录下的nginx.conf文件中设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http&#123;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">\t\tlisten       443 ssl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ngrok\"><a href=\"#ngrok\" class=\"headerlink\" title=\"ngrok\"></a>ngrok</h3><p>这是什么鬼？它是国外开源的一款可实现内网穿透工具（服务端+客户端），即，开启后，访问公网ip或域名，将TCP链接转发到内网。所以，通过ngrok，可实现：<br>访问域名，最终指向本地服务，那么修改本地代码，立即就可以看到效果，微信SDK要求的域名也能够满足了，微信SDK终于可以舒服的调试了。<br>另外，ngrok可以和微信开发者工具一起使用。<br>国内   <a href=\"http://qydev.com/\" target=\"_blank\" rel=\"noopener\">http://qydev.com/</a><br> 这个站点提供了免费服务，但还是希望大家能适当捐助，以帮助作者维持服务器费用，或者选择自行搭建ngrok服务。</p>\n<p>优点：</p>\n<p>任何人访问ngrok绑定的域名，都可以看到效果  </p>\n<p>缺点：</p>\n<p>公众号后台需要设置域名为ngrok绑定的域名<br>依赖ngrok服务端+客户端，搭建这样一个调试环境成本略高</p>\n<p><a href=\"https://natapp.cn/\" target=\"_blank\" rel=\"noopener\">NATAPP</a>  </p>\n<p>  一个基于ngrok的国内高速内网穿透服务,适用于微信开发调试,简单方便。</p>\n<h3 id=\"如何区分微信浏览器\"><a href=\"#如何区分微信浏览器\" class=\"headerlink\" title=\"如何区分微信浏览器\"></a>如何区分微信浏览器</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isWexin</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ua = navigator.userAgent.toLowerCase();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"regexp\">/micromessenger/</span>.test(ua)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"在React和TypeScript中使用emotion","date":"2021-01-13T08:17:44.000Z","_content":"\n> 本文介绍如何在React项目中使用CSS in JS方案：emotion。\n\n![image](https://raw.githubusercontent.com/emotion-js/emotion/master/emotion.png)\n\n<!--more-->\n\n### emotion\n\nemotion是一种高性能且灵活的CSS-in-JS库。它本身与框架无关，你可以在vue或者react中搭配使用。目前我们使用的是react，已经有多个项目在生产环境稳定运行。emotion11是对emotion10的略微改进，主要侧重于开发者的体验，TS的类型改进，以及使用新版本的解析器：Stylis。\n本文主要介绍在React和TypeScript中如何集成emotion11。\n\n### 变化\n\n#### 包重命名\nemotion11最重要的变化之一是大部分面向用户的package都已经重命名。\n\n重命名包的列表：\n\n- @emotion/core → @emotion/react\n- emotion → @emotion/css\n- emotion-theming → moved into @emotion/react\n- emotion-server → @emotion/server\n- create-emotion → @emotion/css/create-instance\n- create-emotion-server → @emotion/server/create-instance\n- babel-plugin-emotion → @emotion/babel-plugin\n- eslint-plugin-emotion → @emotion/eslint-plugin\njest-emotion → @emotion/jest\n\n#### Hooks\n\n在内部使用钩子以优化包的大小并在React DevTools中展示更好的DOM树。\n\n#### TypeScript\n\n##### TypeScript 类型已经被完全重写。\n\n1. 减少使用emotion时的构建时间，尤其是在大型项目中。\n2. 在许多情况下，不再需要为emotion组件手动指定通用参数\n3. 作为props的联合类型得到了更好的支持，应该正确推断\n4. 限制了css函数以防止传递无效的类型\n5. styled 的通用参数已更改，如果您指定ComponentType，则需要删除该通用参数\n6. styled不再需要第二个参数ExtraProps，代替地将其移动至styled调用之后。因此，styled<typeof MyComponent, ExtraProps>(MyComponent)应该被改写为styled(MyComponent)<ExtraProps>({})\n\n\n#####  Theme类型\n\n现在，为主题提供类型更加容易。您可以像这样创建内置的Theme接口，而不是像以前那样创建自定义实例：\n\n\n``` typescript\nimport '@emotion/react'\n\ndeclare module '@emotion/react' {\n  export interface Theme {\n    primaryColor: string\n    secondaryColor: string\n  }\n}\n```\n\n##### css prop 类型\n\n基于使用的不同JSX运行时，emotion11为css prop提供TypeScript支持的方式已经更改，可以仅对支持className prop的组件添加对应css prop的支持（因为emotion的JSX工厂函数采用提供的css prop，对其解析并将生成的className传递给渲染的组件）。\n\n#### Stylis V4\n\nemotion使用的css解析器Stylis得到了升级，它修复了一些长期存在的解析边缘情况，同时变得更小，更快。\n\n#### Emotion的缓存\n\n创建高速缓存的自定义实例时，现在需要key选项。请确保它是唯一的（并且不等于“ css”），因为它用于将样式链接到缓存。如果多个缓存共享同一个键，它们可能会为彼此的样式元素“争斗”。 新的prepend选项可以使Emotion在指定DOM容器的开头而不是结尾处添加样式标签。\n\n### 使用\n\n#### 安装\n\n\n``` bash\nyarn add @emotion/react\n```\n\n#### 使用\n\n\n```\n// this comment tells babel to convert jsx to calls to a function called jsx instead of React.createElement\n/** @jsx jsx */\nimport { jsx, css } from '@emotion/react'\n\nconst style = css`\n  color: hotpink;\n`\n\nconst SomeComponent = ({ children }) => (\n  <div css={style}>\n    Some hotpink text.\n    {children}\n  </div>\n)\n\nconst anotherStyle = css({\n  textDecoration: 'underline'\n})\n\nconst AnotherComponent = () => (\n  <div css={anotherStyle}>Some text with an underline.</div>\n)\nrender(\n  <SomeComponent>\n    <AnotherComponent />\n  </SomeComponent>\n)\n```\n\n#### css prop\n\nemotion提供主要的书写style的方式是使用css prop，它提供了一个简洁灵活的API来对组件进行样式设定。\n\n有两种方式使用css prop：\n\n##### Babel Preset\n\nBabel预设可在使用classic JSX运行时时自动启用Emotion的css prop。如果要使用新的JSX运行时，请不要使用此预设，而应使用@emotion/babel-plugin\n\n- 安装\n\n```\nyarn add @emotion/babel-preset-css-prop\n```\n- 使用\n\n.babelrc\n```\n{\n \"presets\": [\n   [\n     \"@emotion/babel-preset-css-prop\",\n     {\n       \"autoLabel\": \"dev-only\",\n       \"labelFormat\": \"[local]\"\n     }\n   ]\n ],\n}\n```\n如果您使用兼容的React版本（>=16.14.0），则可以通过以下配置选择使用新的JSX运行时：\n\n.babelrc\n```\n{\n  \"presets\": [\n    [\n      \"@babel/preset-react\",\n      { \"runtime\": \"automatic\", \"importSource\": \"@emotion/react\" }\n    ]\n  ],\n  \"plugins\": [\"@emotion/babel-plugin\"]\n}\n```\n\n#### JSX Pragma\n\n在使用CSS prop的源文件顶部设置jsx编译指示。此选项最适合测试css prop功能或在无法配置babel配置的项目（create-react-app，codesandbox等）中。\n\n\n```\n/** @jsx jsx */\n```\n\n与包含linter配置的注释类似，此配置将jsx babel插件配置为使用jsx函数而不是React.createElement。 \n\n如果您正在使用零配置工具来自动检测应该使用哪个运行时（classic还是automatic），并且您已经在使用具有新JSX运行时的React版本（因此运行时为您自动配置了runtime: 'automatic'），例如Create React App 4，然后\n```\n/ ** @jsx jsx * /\n```\n编译指示可能不起作用，您应该使用\n```\n/** @jsx jsx */\nimport { jsx } from '@emotion/react'\n```\n。\n\n#### 使用css prop\n\n\n```\n/** @jsx jsx */\nimport { jsx } from '@emotion/react'\n\nrender(\n  <div\n    css={{\n      backgroundColor: 'hotpink',\n      '&:hover': {\n        color: 'lightgreen'\n      }\n    }}\n  >\n    This has a hotpink background.\n  </div>\n)\n```\n### 主题\n\nTheme包含在@ emotion / react包中。\n\n将ThemeProvider添加到应用程序的顶层，并在样式化组件中使用props.theme来访问主题，或者提供一个接受该主题作为css prop的函数。\n\n#### 使用\n\n##### css function\n\n```\nimport { ThemeProvider } from '@emotion/react'\n\nconst theme = {\n  colors: {\n    primary: 'hotpink'\n  }\n}\n\nrender(\n  <ThemeProvider theme={theme}>\n    <div css={theme => ({ color: theme.colors.primary })}>\n      some other text\n    </div>\n  </ThemeProvider>\n)\n```\n##### useTheme hook\n\n\n```\nimport { ThemeProvider, useTheme } from '@emotion/react'\n\nconst theme = {\n  colors: {\n    primary: 'hotpink'\n  }\n}\n\nfunction SomeText (props) {\n  const theme = useTheme()\n  return (\n    <div\n      css={{ color: theme.colors.primary }}\n      {...props}\n    />\n  )\n}\n\nrender(\n  <ThemeProvider theme={theme}>\n    <SomeText>some text</SomeText>\n  </ThemeProvider>\n)\n```\n\n\n\n#### 类型\n\n主题的类型需要在类型文件中声明，否则TS类型会报错。\n\ntypes/emotion.d.ts\n\n```\nimport \"@emotion/react\";\n\ndeclare module \"@emotion/react\" {\n  export interface Theme {\n    colors: {\n      layoutBodyBackground: string;\n      headingColor: string;\n      textColorSecondary: string;\n      success: string;\n      warning: string;\n      error: string;\n      primary: string;\n      textColor: string;\n    };\n    fontSizes: {\n      base: number;\n    };\n  }\n}\n\n```\n\ntsconfig.json\n\n\n```\n{\n  \"compilerOptions\": {\n        \"paths\": {\n          \"*\": [\n            \"types/*\"\n          ],\n        },\n    }\n}\n```\n\n### 总结\n\nCSS in JS的方案使用下来相比传统的less、sass等优点的确不少，而emotion的类似方案也有很多，对我感受最深的一点是，打包速度提升很多，没有冗余的CSS出现，但是对于习惯了css写法的人来说还是需要时间熟悉，总之，不妨一试。\n\n\n","source":"_posts/在React和TypeScript中使用emotion.md","raw":"---\ntitle: 在React和TypeScript中使用emotion\ndate: 2021-01-13 16:17:44\ntags:\n  - CSS in JS\n  - emotion\n---\n\n> 本文介绍如何在React项目中使用CSS in JS方案：emotion。\n\n![image](https://raw.githubusercontent.com/emotion-js/emotion/master/emotion.png)\n\n<!--more-->\n\n### emotion\n\nemotion是一种高性能且灵活的CSS-in-JS库。它本身与框架无关，你可以在vue或者react中搭配使用。目前我们使用的是react，已经有多个项目在生产环境稳定运行。emotion11是对emotion10的略微改进，主要侧重于开发者的体验，TS的类型改进，以及使用新版本的解析器：Stylis。\n本文主要介绍在React和TypeScript中如何集成emotion11。\n\n### 变化\n\n#### 包重命名\nemotion11最重要的变化之一是大部分面向用户的package都已经重命名。\n\n重命名包的列表：\n\n- @emotion/core → @emotion/react\n- emotion → @emotion/css\n- emotion-theming → moved into @emotion/react\n- emotion-server → @emotion/server\n- create-emotion → @emotion/css/create-instance\n- create-emotion-server → @emotion/server/create-instance\n- babel-plugin-emotion → @emotion/babel-plugin\n- eslint-plugin-emotion → @emotion/eslint-plugin\njest-emotion → @emotion/jest\n\n#### Hooks\n\n在内部使用钩子以优化包的大小并在React DevTools中展示更好的DOM树。\n\n#### TypeScript\n\n##### TypeScript 类型已经被完全重写。\n\n1. 减少使用emotion时的构建时间，尤其是在大型项目中。\n2. 在许多情况下，不再需要为emotion组件手动指定通用参数\n3. 作为props的联合类型得到了更好的支持，应该正确推断\n4. 限制了css函数以防止传递无效的类型\n5. styled 的通用参数已更改，如果您指定ComponentType，则需要删除该通用参数\n6. styled不再需要第二个参数ExtraProps，代替地将其移动至styled调用之后。因此，styled<typeof MyComponent, ExtraProps>(MyComponent)应该被改写为styled(MyComponent)<ExtraProps>({})\n\n\n#####  Theme类型\n\n现在，为主题提供类型更加容易。您可以像这样创建内置的Theme接口，而不是像以前那样创建自定义实例：\n\n\n``` typescript\nimport '@emotion/react'\n\ndeclare module '@emotion/react' {\n  export interface Theme {\n    primaryColor: string\n    secondaryColor: string\n  }\n}\n```\n\n##### css prop 类型\n\n基于使用的不同JSX运行时，emotion11为css prop提供TypeScript支持的方式已经更改，可以仅对支持className prop的组件添加对应css prop的支持（因为emotion的JSX工厂函数采用提供的css prop，对其解析并将生成的className传递给渲染的组件）。\n\n#### Stylis V4\n\nemotion使用的css解析器Stylis得到了升级，它修复了一些长期存在的解析边缘情况，同时变得更小，更快。\n\n#### Emotion的缓存\n\n创建高速缓存的自定义实例时，现在需要key选项。请确保它是唯一的（并且不等于“ css”），因为它用于将样式链接到缓存。如果多个缓存共享同一个键，它们可能会为彼此的样式元素“争斗”。 新的prepend选项可以使Emotion在指定DOM容器的开头而不是结尾处添加样式标签。\n\n### 使用\n\n#### 安装\n\n\n``` bash\nyarn add @emotion/react\n```\n\n#### 使用\n\n\n```\n// this comment tells babel to convert jsx to calls to a function called jsx instead of React.createElement\n/** @jsx jsx */\nimport { jsx, css } from '@emotion/react'\n\nconst style = css`\n  color: hotpink;\n`\n\nconst SomeComponent = ({ children }) => (\n  <div css={style}>\n    Some hotpink text.\n    {children}\n  </div>\n)\n\nconst anotherStyle = css({\n  textDecoration: 'underline'\n})\n\nconst AnotherComponent = () => (\n  <div css={anotherStyle}>Some text with an underline.</div>\n)\nrender(\n  <SomeComponent>\n    <AnotherComponent />\n  </SomeComponent>\n)\n```\n\n#### css prop\n\nemotion提供主要的书写style的方式是使用css prop，它提供了一个简洁灵活的API来对组件进行样式设定。\n\n有两种方式使用css prop：\n\n##### Babel Preset\n\nBabel预设可在使用classic JSX运行时时自动启用Emotion的css prop。如果要使用新的JSX运行时，请不要使用此预设，而应使用@emotion/babel-plugin\n\n- 安装\n\n```\nyarn add @emotion/babel-preset-css-prop\n```\n- 使用\n\n.babelrc\n```\n{\n \"presets\": [\n   [\n     \"@emotion/babel-preset-css-prop\",\n     {\n       \"autoLabel\": \"dev-only\",\n       \"labelFormat\": \"[local]\"\n     }\n   ]\n ],\n}\n```\n如果您使用兼容的React版本（>=16.14.0），则可以通过以下配置选择使用新的JSX运行时：\n\n.babelrc\n```\n{\n  \"presets\": [\n    [\n      \"@babel/preset-react\",\n      { \"runtime\": \"automatic\", \"importSource\": \"@emotion/react\" }\n    ]\n  ],\n  \"plugins\": [\"@emotion/babel-plugin\"]\n}\n```\n\n#### JSX Pragma\n\n在使用CSS prop的源文件顶部设置jsx编译指示。此选项最适合测试css prop功能或在无法配置babel配置的项目（create-react-app，codesandbox等）中。\n\n\n```\n/** @jsx jsx */\n```\n\n与包含linter配置的注释类似，此配置将jsx babel插件配置为使用jsx函数而不是React.createElement。 \n\n如果您正在使用零配置工具来自动检测应该使用哪个运行时（classic还是automatic），并且您已经在使用具有新JSX运行时的React版本（因此运行时为您自动配置了runtime: 'automatic'），例如Create React App 4，然后\n```\n/ ** @jsx jsx * /\n```\n编译指示可能不起作用，您应该使用\n```\n/** @jsx jsx */\nimport { jsx } from '@emotion/react'\n```\n。\n\n#### 使用css prop\n\n\n```\n/** @jsx jsx */\nimport { jsx } from '@emotion/react'\n\nrender(\n  <div\n    css={{\n      backgroundColor: 'hotpink',\n      '&:hover': {\n        color: 'lightgreen'\n      }\n    }}\n  >\n    This has a hotpink background.\n  </div>\n)\n```\n### 主题\n\nTheme包含在@ emotion / react包中。\n\n将ThemeProvider添加到应用程序的顶层，并在样式化组件中使用props.theme来访问主题，或者提供一个接受该主题作为css prop的函数。\n\n#### 使用\n\n##### css function\n\n```\nimport { ThemeProvider } from '@emotion/react'\n\nconst theme = {\n  colors: {\n    primary: 'hotpink'\n  }\n}\n\nrender(\n  <ThemeProvider theme={theme}>\n    <div css={theme => ({ color: theme.colors.primary })}>\n      some other text\n    </div>\n  </ThemeProvider>\n)\n```\n##### useTheme hook\n\n\n```\nimport { ThemeProvider, useTheme } from '@emotion/react'\n\nconst theme = {\n  colors: {\n    primary: 'hotpink'\n  }\n}\n\nfunction SomeText (props) {\n  const theme = useTheme()\n  return (\n    <div\n      css={{ color: theme.colors.primary }}\n      {...props}\n    />\n  )\n}\n\nrender(\n  <ThemeProvider theme={theme}>\n    <SomeText>some text</SomeText>\n  </ThemeProvider>\n)\n```\n\n\n\n#### 类型\n\n主题的类型需要在类型文件中声明，否则TS类型会报错。\n\ntypes/emotion.d.ts\n\n```\nimport \"@emotion/react\";\n\ndeclare module \"@emotion/react\" {\n  export interface Theme {\n    colors: {\n      layoutBodyBackground: string;\n      headingColor: string;\n      textColorSecondary: string;\n      success: string;\n      warning: string;\n      error: string;\n      primary: string;\n      textColor: string;\n    };\n    fontSizes: {\n      base: number;\n    };\n  }\n}\n\n```\n\ntsconfig.json\n\n\n```\n{\n  \"compilerOptions\": {\n        \"paths\": {\n          \"*\": [\n            \"types/*\"\n          ],\n        },\n    }\n}\n```\n\n### 总结\n\nCSS in JS的方案使用下来相比传统的less、sass等优点的确不少，而emotion的类似方案也有很多，对我感受最深的一点是，打包速度提升很多，没有冗余的CSS出现，但是对于习惯了css写法的人来说还是需要时间熟悉，总之，不妨一试。\n\n\n","slug":"在React和TypeScript中使用emotion","published":1,"updated":"2021-03-04T15:20:51.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennv0018p70vql7t0vf3","content":"<blockquote>\n<p>本文介绍如何在React项目中使用CSS in JS方案：emotion。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/emotion-js/emotion/master/emotion.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"emotion\"><a href=\"#emotion\" class=\"headerlink\" title=\"emotion\"></a>emotion</h3><p>emotion是一种高性能且灵活的CSS-in-JS库。它本身与框架无关，你可以在vue或者react中搭配使用。目前我们使用的是react，已经有多个项目在生产环境稳定运行。emotion11是对emotion10的略微改进，主要侧重于开发者的体验，TS的类型改进，以及使用新版本的解析器：Stylis。<br>本文主要介绍在React和TypeScript中如何集成emotion11。</p>\n<h3 id=\"变化\"><a href=\"#变化\" class=\"headerlink\" title=\"变化\"></a>变化</h3><h4 id=\"包重命名\"><a href=\"#包重命名\" class=\"headerlink\" title=\"包重命名\"></a>包重命名</h4><p>emotion11最重要的变化之一是大部分面向用户的package都已经重命名。</p>\n<p>重命名包的列表：</p>\n<ul>\n<li>@emotion/core → @emotion/react</li>\n<li>emotion → @emotion/css</li>\n<li>emotion-theming → moved into @emotion/react</li>\n<li>emotion-server → @emotion/server</li>\n<li>create-emotion → @emotion/css/create-instance</li>\n<li>create-emotion-server → @emotion/server/create-instance</li>\n<li>babel-plugin-emotion → @emotion/babel-plugin</li>\n<li>eslint-plugin-emotion → @emotion/eslint-plugin<br>jest-emotion → @emotion/jest</li>\n</ul>\n<h4 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h4><p>在内部使用钩子以优化包的大小并在React DevTools中展示更好的DOM树。</p>\n<h4 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h4><h5 id=\"TypeScript-类型已经被完全重写。\"><a href=\"#TypeScript-类型已经被完全重写。\" class=\"headerlink\" title=\"TypeScript 类型已经被完全重写。\"></a>TypeScript 类型已经被完全重写。</h5><ol>\n<li>减少使用emotion时的构建时间，尤其是在大型项目中。</li>\n<li>在许多情况下，不再需要为emotion组件手动指定通用参数</li>\n<li>作为props的联合类型得到了更好的支持，应该正确推断</li>\n<li>限制了css函数以防止传递无效的类型</li>\n<li>styled 的通用参数已更改，如果您指定ComponentType，则需要删除该通用参数</li>\n<li>styled不再需要第二个参数ExtraProps，代替地将其移动至styled调用之后。因此，styled<typeof mycomponent, extraprops>(MyComponent)应该被改写为styled(MyComponent)<extraprops>({})</extraprops></typeof></li>\n</ol>\n<h5 id=\"Theme类型\"><a href=\"#Theme类型\" class=\"headerlink\" title=\"Theme类型\"></a>Theme类型</h5><p>现在，为主题提供类型更加容易。您可以像这样创建内置的Theme接口，而不是像以前那样创建自定义实例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'@emotion/react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">module</span> '@emotion/react' &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Theme &#123;</span><br><span class=\"line\">    primaryColor: <span class=\"built_in\">string</span></span><br><span class=\"line\">    secondaryColor: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"css-prop-类型\"><a href=\"#css-prop-类型\" class=\"headerlink\" title=\"css prop 类型\"></a>css prop 类型</h5><p>基于使用的不同JSX运行时，emotion11为css prop提供TypeScript支持的方式已经更改，可以仅对支持className prop的组件添加对应css prop的支持（因为emotion的JSX工厂函数采用提供的css prop，对其解析并将生成的className传递给渲染的组件）。</p>\n<h4 id=\"Stylis-V4\"><a href=\"#Stylis-V4\" class=\"headerlink\" title=\"Stylis V4\"></a>Stylis V4</h4><p>emotion使用的css解析器Stylis得到了升级，它修复了一些长期存在的解析边缘情况，同时变得更小，更快。</p>\n<h4 id=\"Emotion的缓存\"><a href=\"#Emotion的缓存\" class=\"headerlink\" title=\"Emotion的缓存\"></a>Emotion的缓存</h4><p>创建高速缓存的自定义实例时，现在需要key选项。请确保它是唯一的（并且不等于“ css”），因为它用于将样式链接到缓存。如果多个缓存共享同一个键，它们可能会为彼此的样式元素“争斗”。 新的prepend选项可以使Emotion在指定DOM容器的开头而不是结尾处添加样式标签。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add @emotion/react</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// this comment tells babel to convert jsx to calls to a function called jsx instead of React.createElement</span><br><span class=\"line\">/** @jsx jsx */</span><br><span class=\"line\">import &#123; jsx, css &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const style = css`</span><br><span class=\"line\">  color: hotpink;</span><br><span class=\"line\">`</span><br><span class=\"line\"></span><br><span class=\"line\">const SomeComponent = (&#123; children &#125;) =&gt; (</span><br><span class=\"line\">  &lt;div css=&#123;style&#125;&gt;</span><br><span class=\"line\">    Some hotpink text.</span><br><span class=\"line\">    &#123;children&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const anotherStyle = css(&#123;</span><br><span class=\"line\">  textDecoration: &apos;underline&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const AnotherComponent = () =&gt; (</span><br><span class=\"line\">  &lt;div css=&#123;anotherStyle&#125;&gt;Some text with an underline.&lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;SomeComponent&gt;</span><br><span class=\"line\">    &lt;AnotherComponent /&gt;</span><br><span class=\"line\">  &lt;/SomeComponent&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"css-prop\"><a href=\"#css-prop\" class=\"headerlink\" title=\"css prop\"></a>css prop</h4><p>emotion提供主要的书写style的方式是使用css prop，它提供了一个简洁灵活的API来对组件进行样式设定。</p>\n<p>有两种方式使用css prop：</p>\n<h5 id=\"Babel-Preset\"><a href=\"#Babel-Preset\" class=\"headerlink\" title=\"Babel Preset\"></a>Babel Preset</h5><p>Babel预设可在使用classic JSX运行时时自动启用Emotion的css prop。如果要使用新的JSX运行时，请不要使用此预设，而应使用@emotion/babel-plugin</p>\n<ul>\n<li>安装</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add @emotion/babel-preset-css-prop</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用</li>\n</ul>\n<p>.babelrc<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;presets&quot;: [</span><br><span class=\"line\">   [</span><br><span class=\"line\">     &quot;@emotion/babel-preset-css-prop&quot;,</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       &quot;autoLabel&quot;: &quot;dev-only&quot;,</span><br><span class=\"line\">       &quot;labelFormat&quot;: &quot;[local]&quot;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果您使用兼容的React版本（&gt;=16.14.0），则可以通过以下配置选择使用新的JSX运行时：</p>\n<p>.babelrc<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-react&quot;,</span><br><span class=\"line\">      &#123; &quot;runtime&quot;: &quot;automatic&quot;, &quot;importSource&quot;: &quot;@emotion/react&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: [&quot;@emotion/babel-plugin&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSX-Pragma\"><a href=\"#JSX-Pragma\" class=\"headerlink\" title=\"JSX Pragma\"></a>JSX Pragma</h4><p>在使用CSS prop的源文件顶部设置jsx编译指示。此选项最适合测试css prop功能或在无法配置babel配置的项目（create-react-app，codesandbox等）中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** @jsx jsx */</span><br></pre></td></tr></table></figure>\n<p>与包含linter配置的注释类似，此配置将jsx babel插件配置为使用jsx函数而不是React.createElement。 </p>\n<p>如果您正在使用零配置工具来自动检测应该使用哪个运行时（classic还是automatic），并且您已经在使用具有新JSX运行时的React版本（因此运行时为您自动配置了runtime: ‘automatic’），例如Create React App 4，然后<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ ** @jsx jsx * /</span><br></pre></td></tr></table></figure></p>\n<p>编译指示可能不起作用，您应该使用<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** @jsx jsx */</span><br><span class=\"line\">import &#123; jsx &#125; from &apos;@emotion/react&apos;</span><br></pre></td></tr></table></figure></p>\n<p>。</p>\n<h4 id=\"使用css-prop\"><a href=\"#使用css-prop\" class=\"headerlink\" title=\"使用css prop\"></a>使用css prop</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** @jsx jsx */</span><br><span class=\"line\">import &#123; jsx &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;div</span><br><span class=\"line\">    css=&#123;&#123;</span><br><span class=\"line\">      backgroundColor: &apos;hotpink&apos;,</span><br><span class=\"line\">      &apos;&amp;:hover&apos;: &#123;</span><br><span class=\"line\">        color: &apos;lightgreen&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    This has a hotpink background.</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>Theme包含在@ emotion / react包中。</p>\n<p>将ThemeProvider添加到应用程序的顶层，并在样式化组件中使用props.theme来访问主题，或者提供一个接受该主题作为css prop的函数。</p>\n<h4 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h4><h5 id=\"css-function\"><a href=\"#css-function\" class=\"headerlink\" title=\"css function\"></a>css function</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; ThemeProvider &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const theme = &#123;</span><br><span class=\"line\">  colors: &#123;</span><br><span class=\"line\">    primary: &apos;hotpink&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;ThemeProvider theme=&#123;theme&#125;&gt;</span><br><span class=\"line\">    &lt;div css=&#123;theme =&gt; (&#123; color: theme.colors.primary &#125;)&#125;&gt;</span><br><span class=\"line\">      some other text</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/ThemeProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h5 id=\"useTheme-hook\"><a href=\"#useTheme-hook\" class=\"headerlink\" title=\"useTheme hook\"></a>useTheme hook</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; ThemeProvider, useTheme &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const theme = &#123;</span><br><span class=\"line\">  colors: &#123;</span><br><span class=\"line\">    primary: &apos;hotpink&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function SomeText (props) &#123;</span><br><span class=\"line\">  const theme = useTheme()</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div</span><br><span class=\"line\">      css=&#123;&#123; color: theme.colors.primary &#125;&#125;</span><br><span class=\"line\">      &#123;...props&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;ThemeProvider theme=&#123;theme&#125;&gt;</span><br><span class=\"line\">    &lt;SomeText&gt;some text&lt;/SomeText&gt;</span><br><span class=\"line\">  &lt;/ThemeProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p>主题的类型需要在类型文件中声明，否则TS类型会报错。</p>\n<p>types/emotion.d.ts</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;@emotion/react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">declare module &quot;@emotion/react&quot; &#123;</span><br><span class=\"line\">  export interface Theme &#123;</span><br><span class=\"line\">    colors: &#123;</span><br><span class=\"line\">      layoutBodyBackground: string;</span><br><span class=\"line\">      headingColor: string;</span><br><span class=\"line\">      textColorSecondary: string;</span><br><span class=\"line\">      success: string;</span><br><span class=\"line\">      warning: string;</span><br><span class=\"line\">      error: string;</span><br><span class=\"line\">      primary: string;</span><br><span class=\"line\">      textColor: string;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fontSizes: &#123;</span><br><span class=\"line\">      base: number;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tsconfig.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">        &quot;paths&quot;: &#123;</span><br><span class=\"line\">          &quot;*&quot;: [</span><br><span class=\"line\">            &quot;types/*&quot;</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>CSS in JS的方案使用下来相比传统的less、sass等优点的确不少，而emotion的类似方案也有很多，对我感受最深的一点是，打包速度提升很多，没有冗余的CSS出现，但是对于习惯了css写法的人来说还是需要时间熟悉，总之，不妨一试。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文介绍如何在React项目中使用CSS in JS方案：emotion。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/emotion-js/emotion/master/emotion.png\" alt=\"image\"></p>","more":"<h3 id=\"emotion\"><a href=\"#emotion\" class=\"headerlink\" title=\"emotion\"></a>emotion</h3><p>emotion是一种高性能且灵活的CSS-in-JS库。它本身与框架无关，你可以在vue或者react中搭配使用。目前我们使用的是react，已经有多个项目在生产环境稳定运行。emotion11是对emotion10的略微改进，主要侧重于开发者的体验，TS的类型改进，以及使用新版本的解析器：Stylis。<br>本文主要介绍在React和TypeScript中如何集成emotion11。</p>\n<h3 id=\"变化\"><a href=\"#变化\" class=\"headerlink\" title=\"变化\"></a>变化</h3><h4 id=\"包重命名\"><a href=\"#包重命名\" class=\"headerlink\" title=\"包重命名\"></a>包重命名</h4><p>emotion11最重要的变化之一是大部分面向用户的package都已经重命名。</p>\n<p>重命名包的列表：</p>\n<ul>\n<li>@emotion/core → @emotion/react</li>\n<li>emotion → @emotion/css</li>\n<li>emotion-theming → moved into @emotion/react</li>\n<li>emotion-server → @emotion/server</li>\n<li>create-emotion → @emotion/css/create-instance</li>\n<li>create-emotion-server → @emotion/server/create-instance</li>\n<li>babel-plugin-emotion → @emotion/babel-plugin</li>\n<li>eslint-plugin-emotion → @emotion/eslint-plugin<br>jest-emotion → @emotion/jest</li>\n</ul>\n<h4 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h4><p>在内部使用钩子以优化包的大小并在React DevTools中展示更好的DOM树。</p>\n<h4 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h4><h5 id=\"TypeScript-类型已经被完全重写。\"><a href=\"#TypeScript-类型已经被完全重写。\" class=\"headerlink\" title=\"TypeScript 类型已经被完全重写。\"></a>TypeScript 类型已经被完全重写。</h5><ol>\n<li>减少使用emotion时的构建时间，尤其是在大型项目中。</li>\n<li>在许多情况下，不再需要为emotion组件手动指定通用参数</li>\n<li>作为props的联合类型得到了更好的支持，应该正确推断</li>\n<li>限制了css函数以防止传递无效的类型</li>\n<li>styled 的通用参数已更改，如果您指定ComponentType，则需要删除该通用参数</li>\n<li>styled不再需要第二个参数ExtraProps，代替地将其移动至styled调用之后。因此，styled<typeof mycomponent, extraprops>(MyComponent)应该被改写为styled(MyComponent)<extraprops>({})</extraprops></typeof></li>\n</ol>\n<h5 id=\"Theme类型\"><a href=\"#Theme类型\" class=\"headerlink\" title=\"Theme类型\"></a>Theme类型</h5><p>现在，为主题提供类型更加容易。您可以像这样创建内置的Theme接口，而不是像以前那样创建自定义实例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'@emotion/react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">module</span> '@emotion/react' &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Theme &#123;</span><br><span class=\"line\">    primaryColor: <span class=\"built_in\">string</span></span><br><span class=\"line\">    secondaryColor: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"css-prop-类型\"><a href=\"#css-prop-类型\" class=\"headerlink\" title=\"css prop 类型\"></a>css prop 类型</h5><p>基于使用的不同JSX运行时，emotion11为css prop提供TypeScript支持的方式已经更改，可以仅对支持className prop的组件添加对应css prop的支持（因为emotion的JSX工厂函数采用提供的css prop，对其解析并将生成的className传递给渲染的组件）。</p>\n<h4 id=\"Stylis-V4\"><a href=\"#Stylis-V4\" class=\"headerlink\" title=\"Stylis V4\"></a>Stylis V4</h4><p>emotion使用的css解析器Stylis得到了升级，它修复了一些长期存在的解析边缘情况，同时变得更小，更快。</p>\n<h4 id=\"Emotion的缓存\"><a href=\"#Emotion的缓存\" class=\"headerlink\" title=\"Emotion的缓存\"></a>Emotion的缓存</h4><p>创建高速缓存的自定义实例时，现在需要key选项。请确保它是唯一的（并且不等于“ css”），因为它用于将样式链接到缓存。如果多个缓存共享同一个键，它们可能会为彼此的样式元素“争斗”。 新的prepend选项可以使Emotion在指定DOM容器的开头而不是结尾处添加样式标签。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add @emotion/react</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// this comment tells babel to convert jsx to calls to a function called jsx instead of React.createElement</span><br><span class=\"line\">/** @jsx jsx */</span><br><span class=\"line\">import &#123; jsx, css &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const style = css`</span><br><span class=\"line\">  color: hotpink;</span><br><span class=\"line\">`</span><br><span class=\"line\"></span><br><span class=\"line\">const SomeComponent = (&#123; children &#125;) =&gt; (</span><br><span class=\"line\">  &lt;div css=&#123;style&#125;&gt;</span><br><span class=\"line\">    Some hotpink text.</span><br><span class=\"line\">    &#123;children&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const anotherStyle = css(&#123;</span><br><span class=\"line\">  textDecoration: &apos;underline&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const AnotherComponent = () =&gt; (</span><br><span class=\"line\">  &lt;div css=&#123;anotherStyle&#125;&gt;Some text with an underline.&lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;SomeComponent&gt;</span><br><span class=\"line\">    &lt;AnotherComponent /&gt;</span><br><span class=\"line\">  &lt;/SomeComponent&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"css-prop\"><a href=\"#css-prop\" class=\"headerlink\" title=\"css prop\"></a>css prop</h4><p>emotion提供主要的书写style的方式是使用css prop，它提供了一个简洁灵活的API来对组件进行样式设定。</p>\n<p>有两种方式使用css prop：</p>\n<h5 id=\"Babel-Preset\"><a href=\"#Babel-Preset\" class=\"headerlink\" title=\"Babel Preset\"></a>Babel Preset</h5><p>Babel预设可在使用classic JSX运行时时自动启用Emotion的css prop。如果要使用新的JSX运行时，请不要使用此预设，而应使用@emotion/babel-plugin</p>\n<ul>\n<li>安装</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yarn add @emotion/babel-preset-css-prop</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用</li>\n</ul>\n<p>.babelrc<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;presets&quot;: [</span><br><span class=\"line\">   [</span><br><span class=\"line\">     &quot;@emotion/babel-preset-css-prop&quot;,</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       &quot;autoLabel&quot;: &quot;dev-only&quot;,</span><br><span class=\"line\">       &quot;labelFormat&quot;: &quot;[local]&quot;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\"> ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果您使用兼容的React版本（&gt;=16.14.0），则可以通过以下配置选择使用新的JSX运行时：</p>\n<p>.babelrc<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;@babel/preset-react&quot;,</span><br><span class=\"line\">      &#123; &quot;runtime&quot;: &quot;automatic&quot;, &quot;importSource&quot;: &quot;@emotion/react&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: [&quot;@emotion/babel-plugin&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSX-Pragma\"><a href=\"#JSX-Pragma\" class=\"headerlink\" title=\"JSX Pragma\"></a>JSX Pragma</h4><p>在使用CSS prop的源文件顶部设置jsx编译指示。此选项最适合测试css prop功能或在无法配置babel配置的项目（create-react-app，codesandbox等）中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** @jsx jsx */</span><br></pre></td></tr></table></figure>\n<p>与包含linter配置的注释类似，此配置将jsx babel插件配置为使用jsx函数而不是React.createElement。 </p>\n<p>如果您正在使用零配置工具来自动检测应该使用哪个运行时（classic还是automatic），并且您已经在使用具有新JSX运行时的React版本（因此运行时为您自动配置了runtime: ‘automatic’），例如Create React App 4，然后<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ ** @jsx jsx * /</span><br></pre></td></tr></table></figure></p>\n<p>编译指示可能不起作用，您应该使用<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** @jsx jsx */</span><br><span class=\"line\">import &#123; jsx &#125; from &apos;@emotion/react&apos;</span><br></pre></td></tr></table></figure></p>\n<p>。</p>\n<h4 id=\"使用css-prop\"><a href=\"#使用css-prop\" class=\"headerlink\" title=\"使用css prop\"></a>使用css prop</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/** @jsx jsx */</span><br><span class=\"line\">import &#123; jsx &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;div</span><br><span class=\"line\">    css=&#123;&#123;</span><br><span class=\"line\">      backgroundColor: &apos;hotpink&apos;,</span><br><span class=\"line\">      &apos;&amp;:hover&apos;: &#123;</span><br><span class=\"line\">        color: &apos;lightgreen&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    This has a hotpink background.</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><p>Theme包含在@ emotion / react包中。</p>\n<p>将ThemeProvider添加到应用程序的顶层，并在样式化组件中使用props.theme来访问主题，或者提供一个接受该主题作为css prop的函数。</p>\n<h4 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h4><h5 id=\"css-function\"><a href=\"#css-function\" class=\"headerlink\" title=\"css function\"></a>css function</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; ThemeProvider &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const theme = &#123;</span><br><span class=\"line\">  colors: &#123;</span><br><span class=\"line\">    primary: &apos;hotpink&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;ThemeProvider theme=&#123;theme&#125;&gt;</span><br><span class=\"line\">    &lt;div css=&#123;theme =&gt; (&#123; color: theme.colors.primary &#125;)&#125;&gt;</span><br><span class=\"line\">      some other text</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/ThemeProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h5 id=\"useTheme-hook\"><a href=\"#useTheme-hook\" class=\"headerlink\" title=\"useTheme hook\"></a>useTheme hook</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; ThemeProvider, useTheme &#125; from &apos;@emotion/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const theme = &#123;</span><br><span class=\"line\">  colors: &#123;</span><br><span class=\"line\">    primary: &apos;hotpink&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function SomeText (props) &#123;</span><br><span class=\"line\">  const theme = useTheme()</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div</span><br><span class=\"line\">      css=&#123;&#123; color: theme.colors.primary &#125;&#125;</span><br><span class=\"line\">      &#123;...props&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;ThemeProvider theme=&#123;theme&#125;&gt;</span><br><span class=\"line\">    &lt;SomeText&gt;some text&lt;/SomeText&gt;</span><br><span class=\"line\">  &lt;/ThemeProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p>主题的类型需要在类型文件中声明，否则TS类型会报错。</p>\n<p>types/emotion.d.ts</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &quot;@emotion/react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">declare module &quot;@emotion/react&quot; &#123;</span><br><span class=\"line\">  export interface Theme &#123;</span><br><span class=\"line\">    colors: &#123;</span><br><span class=\"line\">      layoutBodyBackground: string;</span><br><span class=\"line\">      headingColor: string;</span><br><span class=\"line\">      textColorSecondary: string;</span><br><span class=\"line\">      success: string;</span><br><span class=\"line\">      warning: string;</span><br><span class=\"line\">      error: string;</span><br><span class=\"line\">      primary: string;</span><br><span class=\"line\">      textColor: string;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fontSizes: &#123;</span><br><span class=\"line\">      base: number;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tsconfig.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">        &quot;paths&quot;: &#123;</span><br><span class=\"line\">          &quot;*&quot;: [</span><br><span class=\"line\">            &quot;types/*&quot;</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>CSS in JS的方案使用下来相比传统的less、sass等优点的确不少，而emotion的类似方案也有很多，对我感受最深的一点是，打包速度提升很多，没有冗余的CSS出现，但是对于习惯了css写法的人来说还是需要时间熟悉，总之，不妨一试。</p>"},{"title":"我的第一个博客，Hexo强力驱动","date":"2016-07-03T13:25:24.000Z","banner":"http://img.yanyuanfe.cn/hexo.png","_content":"\n\n\n## 第一个博客，新的开始\n\n> 无所谓改变世界，只是继续潜心做自己热爱的事！\n\n![hexo icon](http://img.yanyuanfe.cn/hexo.png)\n\n\n<!--more-->\n\n时光辗转，从6月17日开始折腾hexo搭建博客，到现在写下第一篇文章，中间断断续续经历了大三的期末复习、考试，整天忙得焦头烂额，现在能在键盘上敲击文字，整理思路，还算很惬意吧。\n\n第一个博客，也是新的开始吧，希望这个博客能让我的技术沉淀下来，保持一种分享的态度，同时，坚持文字的爱好。\n\n第一篇文章，纪念第一个博客。\n\n\n","source":"_posts/我的第一个博客，Hexo强力驱动.md","raw":"---\ntitle: 我的第一个博客，Hexo强力驱动\ndate: 2016-07-03 21:25:24\ncategories: 生活\nbanner: http://img.yanyuanfe.cn/hexo.png\ntags:\n\t- 杂谈\n\t- 生活\n---\n\n\n\n## 第一个博客，新的开始\n\n> 无所谓改变世界，只是继续潜心做自己热爱的事！\n\n![hexo icon](http://img.yanyuanfe.cn/hexo.png)\n\n\n<!--more-->\n\n时光辗转，从6月17日开始折腾hexo搭建博客，到现在写下第一篇文章，中间断断续续经历了大三的期末复习、考试，整天忙得焦头烂额，现在能在键盘上敲击文字，整理思路，还算很惬意吧。\n\n第一个博客，也是新的开始吧，希望这个博客能让我的技术沉淀下来，保持一种分享的态度，同时，坚持文字的爱好。\n\n第一篇文章，纪念第一个博客。\n\n\n","slug":"我的第一个博客，Hexo强力驱动","published":1,"updated":"2020-07-16T13:56:47.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennw001ap70vclrxis0d","content":"<h2 id=\"第一个博客，新的开始\"><a href=\"#第一个博客，新的开始\" class=\"headerlink\" title=\"第一个博客，新的开始\"></a>第一个博客，新的开始</h2><blockquote>\n<p>无所谓改变世界，只是继续潜心做自己热爱的事！</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/hexo.png\" alt=\"hexo icon\"></p>\n<a id=\"more\"></a>\n<p>时光辗转，从6月17日开始折腾hexo搭建博客，到现在写下第一篇文章，中间断断续续经历了大三的期末复习、考试，整天忙得焦头烂额，现在能在键盘上敲击文字，整理思路，还算很惬意吧。</p>\n<p>第一个博客，也是新的开始吧，希望这个博客能让我的技术沉淀下来，保持一种分享的态度，同时，坚持文字的爱好。</p>\n<p>第一篇文章，纪念第一个博客。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第一个博客，新的开始\"><a href=\"#第一个博客，新的开始\" class=\"headerlink\" title=\"第一个博客，新的开始\"></a>第一个博客，新的开始</h2><blockquote>\n<p>无所谓改变世界，只是继续潜心做自己热爱的事！</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/hexo.png\" alt=\"hexo icon\"></p>","more":"<p>时光辗转，从6月17日开始折腾hexo搭建博客，到现在写下第一篇文章，中间断断续续经历了大三的期末复习、考试，整天忙得焦头烂额，现在能在键盘上敲击文字，整理思路，还算很惬意吧。</p>\n<p>第一个博客，也是新的开始吧，希望这个博客能让我的技术沉淀下来，保持一种分享的态度，同时，坚持文字的爱好。</p>\n<p>第一篇文章，纪念第一个博客。</p>"},{"title":"我和这个世界不熟","date":"2016-10-04T01:23:43.000Z","banner":"http://img.yanyuanfe.cn/fox_dribbble_1x.jpg","_content":"\n\n> 那时我们还年轻。穿过残垣断壁苍松古柏，我们来到山崖上。沐浴着夕阳，心静如水，我们向云雾飘荡的远方眺望。其实啥也看不到，生活的悲欢离合远在地平线以外，而眺望是一种青春的姿态。\n\n![image](http://img.yanyuanfe.cn/fox_dribbble_1x.jpg)\n\n<!--more-->\n\n　　\n我和这个世界不熟。 \n\n这并非是我安静的原因。 \n\n我依旧有很多问题， \n\n问南方，问故里，问希望，问距离。 \n　　\n我和这个世界不熟。 \n\n这并非是我绝望的原因。 \n\n我依旧有很多热情， \n\n给分开，给死亡，给昨天，给安寂。 \n　　\n我和这个世界不熟。 \n\n这并非是我虚假的原因。 \n\n我依旧有很多真诚， \n\n离不开，放不下，活下去，爱得起。 \n　　\n我和这个世界不熟。 \n\n这并非是我孤寂的原因。 \n\n我依旧有很多诉求， \n\n需慰藉，待分享，惹心烦，告诉你。 \n　　\n我和这个世界不熟。 \n\n这并非是我冷漠的原因。 \n\n我依旧有很多动情， \n\n为时间，为白云，为天黑，畏天命。 \n　　\n我和这个世界不熟。 \n\n这并非是我逃避的原因。 \n\n我依旧有很多憧憬， \n\n对梦想，对记忆，对失败，对希冀。 \n　　\n我和这个世界不熟。 \n\n这并非是我卑微的原因。 \n\n我依旧有很多勇敢， \n\n不信输，不信神，不信天，不信地。 \n　　\n我和这个世界不熟。 \n\n这并非是我失落的原因。 \n\n我依旧有很多高昂， \n\n有存在，有价值，有独特，有意义。 \n　　\n我和这个世界不熟。 \n\n这并非是我迷茫的原因。 \n\n我依旧有很多方向， \n\n往前走，回头望，会跳跃，会停息。 \n　　\n我和这个世界不熟。 \n\n这并非是我撕裂的原因。\n　\n我依旧有很多完整， \n\n至少我要成全我自己。 \n　　\n我和这个世界不熟。 \n\n这并非是我选择死亡或者生存的原因。 \n\n我依旧有很多选择， \n\n刚巧，这两者，都不是选项之一。 ","source":"_posts/我和这个世界不熟.md","raw":"---\ntitle: 我和这个世界不熟\ndate: 2016-10-04 09:23:43\ncategories: 生活\nbanner: http://img.yanyuanfe.cn/fox_dribbble_1x.jpg\ntags:\n\t- 随笔\n---\n\n\n> 那时我们还年轻。穿过残垣断壁苍松古柏，我们来到山崖上。沐浴着夕阳，心静如水，我们向云雾飘荡的远方眺望。其实啥也看不到，生活的悲欢离合远在地平线以外，而眺望是一种青春的姿态。\n\n![image](http://img.yanyuanfe.cn/fox_dribbble_1x.jpg)\n\n<!--more-->\n\n　　\n我和这个世界不熟。 \n\n这并非是我安静的原因。 \n\n我依旧有很多问题， \n\n问南方，问故里，问希望，问距离。 \n　　\n我和这个世界不熟。 \n\n这并非是我绝望的原因。 \n\n我依旧有很多热情， \n\n给分开，给死亡，给昨天，给安寂。 \n　　\n我和这个世界不熟。 \n\n这并非是我虚假的原因。 \n\n我依旧有很多真诚， \n\n离不开，放不下，活下去，爱得起。 \n　　\n我和这个世界不熟。 \n\n这并非是我孤寂的原因。 \n\n我依旧有很多诉求， \n\n需慰藉，待分享，惹心烦，告诉你。 \n　　\n我和这个世界不熟。 \n\n这并非是我冷漠的原因。 \n\n我依旧有很多动情， \n\n为时间，为白云，为天黑，畏天命。 \n　　\n我和这个世界不熟。 \n\n这并非是我逃避的原因。 \n\n我依旧有很多憧憬， \n\n对梦想，对记忆，对失败，对希冀。 \n　　\n我和这个世界不熟。 \n\n这并非是我卑微的原因。 \n\n我依旧有很多勇敢， \n\n不信输，不信神，不信天，不信地。 \n　　\n我和这个世界不熟。 \n\n这并非是我失落的原因。 \n\n我依旧有很多高昂， \n\n有存在，有价值，有独特，有意义。 \n　　\n我和这个世界不熟。 \n\n这并非是我迷茫的原因。 \n\n我依旧有很多方向， \n\n往前走，回头望，会跳跃，会停息。 \n　　\n我和这个世界不熟。 \n\n这并非是我撕裂的原因。\n　\n我依旧有很多完整， \n\n至少我要成全我自己。 \n　　\n我和这个世界不熟。 \n\n这并非是我选择死亡或者生存的原因。 \n\n我依旧有很多选择， \n\n刚巧，这两者，都不是选项之一。 ","slug":"我和这个世界不熟","published":1,"updated":"2020-07-16T13:56:47.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenny001cp70vceh7m3ft","content":"<blockquote>\n<p>那时我们还年轻。穿过残垣断壁苍松古柏，我们来到山崖上。沐浴着夕阳，心静如水，我们向云雾飘荡的远方眺望。其实啥也看不到，生活的悲欢离合远在地平线以外，而眺望是一种青春的姿态。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/fox_dribbble_1x.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我安静的原因。 </p>\n<p>我依旧有很多问题， </p>\n<p>问南方，问故里，问希望，问距离。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我绝望的原因。 </p>\n<p>我依旧有很多热情， </p>\n<p>给分开，给死亡，给昨天，给安寂。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我虚假的原因。 </p>\n<p>我依旧有很多真诚， </p>\n<p>离不开，放不下，活下去，爱得起。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我孤寂的原因。 </p>\n<p>我依旧有很多诉求， </p>\n<p>需慰藉，待分享，惹心烦，告诉你。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我冷漠的原因。 </p>\n<p>我依旧有很多动情， </p>\n<p>为时间，为白云，为天黑，畏天命。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我逃避的原因。 </p>\n<p>我依旧有很多憧憬， </p>\n<p>对梦想，对记忆，对失败，对希冀。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我卑微的原因。 </p>\n<p>我依旧有很多勇敢， </p>\n<p>不信输，不信神，不信天，不信地。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我失落的原因。 </p>\n<p>我依旧有很多高昂， </p>\n<p>有存在，有价值，有独特，有意义。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我迷茫的原因。 </p>\n<p>我依旧有很多方向， </p>\n<p>往前走，回头望，会跳跃，会停息。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我撕裂的原因。<br>　<br>我依旧有很多完整， </p>\n<p>至少我要成全我自己。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我选择死亡或者生存的原因。 </p>\n<p>我依旧有很多选择， </p>\n<p>刚巧，这两者，都不是选项之一。 </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>那时我们还年轻。穿过残垣断壁苍松古柏，我们来到山崖上。沐浴着夕阳，心静如水，我们向云雾飘荡的远方眺望。其实啥也看不到，生活的悲欢离合远在地平线以外，而眺望是一种青春的姿态。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/fox_dribbble_1x.jpg\" alt=\"image\"></p>","more":"<p>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我安静的原因。 </p>\n<p>我依旧有很多问题， </p>\n<p>问南方，问故里，问希望，问距离。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我绝望的原因。 </p>\n<p>我依旧有很多热情， </p>\n<p>给分开，给死亡，给昨天，给安寂。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我虚假的原因。 </p>\n<p>我依旧有很多真诚， </p>\n<p>离不开，放不下，活下去，爱得起。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我孤寂的原因。 </p>\n<p>我依旧有很多诉求， </p>\n<p>需慰藉，待分享，惹心烦，告诉你。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我冷漠的原因。 </p>\n<p>我依旧有很多动情， </p>\n<p>为时间，为白云，为天黑，畏天命。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我逃避的原因。 </p>\n<p>我依旧有很多憧憬， </p>\n<p>对梦想，对记忆，对失败，对希冀。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我卑微的原因。 </p>\n<p>我依旧有很多勇敢， </p>\n<p>不信输，不信神，不信天，不信地。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我失落的原因。 </p>\n<p>我依旧有很多高昂， </p>\n<p>有存在，有价值，有独特，有意义。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我迷茫的原因。 </p>\n<p>我依旧有很多方向， </p>\n<p>往前走，回头望，会跳跃，会停息。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我撕裂的原因。<br>　<br>我依旧有很多完整， </p>\n<p>至少我要成全我自己。<br>　　<br>我和这个世界不熟。 </p>\n<p>这并非是我选择死亡或者生存的原因。 </p>\n<p>我依旧有很多选择， </p>\n<p>刚巧，这两者，都不是选项之一。 </p>"},{"title":"手摸手撸一个简单的Redux（一）","date":"2018-02-26T02:14:41.000Z","banner":"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg","_content":"\n> 理解Redux的原理有助于我们更好的使用它。本文实现Redux的基本API。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n\n\nRedux 试图让 state 的变化变得可预测。\n\nredux已经被越来越多的人使用，理解其原理有助于更好的使用它。阅读redux源码是一个不错的办法，当我们了解了其原理之后，现在来实现一个简单的redux吧。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-3\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 基本API\n如果你使用过redux，应该对redux的API了然于胸吧。redux的基本API包括createStore、getState、subscribe、dispatch。现在回顾一下redux的使用方法：\n\n首先，redux暴露出createStore方法，调用createStore方法传入reducer，使用const store = createStore(reducer)，（此处暂时不考虑中间件），使用store.getState()获取状态，使用store.dispatch()发起一个action，使用store.subscribe()订阅状态改变时执行的函数。下面是redux API的简单实现。\n\n为了方便调试，使用前面讲的redux实现简单计数器的代码，在src目录下新建redux.js，\n\n``` js\nexport function createStore(reducer) {\n\n}\n```\n\n在redux.js中，先导出redux的核心方法 createStore，传入reducer作为参数。\n在createStore方法中，需要定义用于保存当前状态的变量以及用于保存状态改变后执行函数的监听器。\n\n\n``` js\nlet currentState;\nlet currentListeners = [];\n```\n\n此处定义currentState为当前状态，初始化为undefined;定义currentListenners为监听器，初始化为数组。\n\n然后，定义getState方法，用于获取当前状态，直接返回currentState：\n\n``` js\nfunction getState() {\n  return currentState;\n}\n```\n\n\n然后，定义subscribe函数，用于订阅状态改变时执行的方法：\n\n``` js\nfunction subscribe(listener) {\n  currentListeners.push(listener);\n}\n```\n\nsubscribe方法传入一个监听函数，将监听函数push进监听器数组中。\n然后定义dispatch方法，用于发起action：\n\n``` js\nfunction dispatch(action) {\n  currentState = reducer(currentState, action);\n  currentListeners.forEach(v => v());\n  return action;\n}\n```\n\ndispatch方法传入action，然后调用reducer开始更新currentState，传入当前currentState和action，当状态改变时，通知监听器，监听器数组依次执行数组中的每一个订阅方法，此处使用了设计模式中的发布——订阅模式，然后返回action。\n\n可以看到，上面已经实现了Redux的基本API，那么就结束了吗？当然没有，因为redux并没有初始化，reducer中的初始状态并没有生效，所以需要手动发起一个action，并且action.type必须是独一无二的。如下：\n\n``` js\ndispatch({type: '@@REDUX/INIT'});\n```\n\n此处，对redux进行初始化，定义type为'@@REDUX/INIT'，这样定义的原因是保证命中reducer中action.type为default使其返回初始化state。\n最后，根据redux使用方法可以知道，store肯定是一个对象，对象包含getState、subscribe、dispatch等方法，所有，最后需要将上述方法返回。\n\n``` js\nreturn { getState, subscribe, dispatch };\n```\n\n\n至此，一个超级简单的redux就实现了，麻雀虽小，五脏俱全。这个redux虽然简单，省去了许多错误处理过程，但是对于理解redux足矣。下面是完整代码：\n\n``` js\nexport function createStore(reducer) {\n  let currentState;\n\n  let currentListeners = [];\n\n  function getState() {\n    return currentState;\n  }\n  function subscribe(listener) {\n    currentListeners.push(listener);\n  }\n  function dispatch(action) {\n    currentState = reducer(currentState, action);\n    currentListeners.forEach(v => v());\n    return action;\n  }\n\n  dispatch({type: '@@REDUX/INIT'}); //初始化\n  return { getState, subscribe, dispatch }\n}\n```\n\n### 测试\n下面结合之前的计数器例子来验证上述redux是否正确。\n在前面计数器例子中，打开src下index.js，修改如下代码：\n\n``` js\nimport { createStore } from './redux';\n```\n\n\n替换redux为刚刚编写的redux.js文件。查看浏览器运行结果。\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_184.png)\n\n如图，与redux的效果一致，达到预期效果。\n\n### 总结\n本文实现了一个简单的redux，完成其基本API的实现，这有助于你理解redux的原理，后面会逐步对其扩展，编写react-redux以及中间件的实现。","source":"_posts/手摸手撸一个简单的Redux（一）.md","raw":"---\ntitle: 手摸手撸一个简单的Redux（一）\ndate: 2018-02-26 10:14:41\nbanner: http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\ntags:\n - Redux\n - React\n---\n\n> 理解Redux的原理有助于我们更好的使用它。本文实现Redux的基本API。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n\n\nRedux 试图让 state 的变化变得可预测。\n\nredux已经被越来越多的人使用，理解其原理有助于更好的使用它。阅读redux源码是一个不错的办法，当我们了解了其原理之后，现在来实现一个简单的redux吧。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-3\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 基本API\n如果你使用过redux，应该对redux的API了然于胸吧。redux的基本API包括createStore、getState、subscribe、dispatch。现在回顾一下redux的使用方法：\n\n首先，redux暴露出createStore方法，调用createStore方法传入reducer，使用const store = createStore(reducer)，（此处暂时不考虑中间件），使用store.getState()获取状态，使用store.dispatch()发起一个action，使用store.subscribe()订阅状态改变时执行的函数。下面是redux API的简单实现。\n\n为了方便调试，使用前面讲的redux实现简单计数器的代码，在src目录下新建redux.js，\n\n``` js\nexport function createStore(reducer) {\n\n}\n```\n\n在redux.js中，先导出redux的核心方法 createStore，传入reducer作为参数。\n在createStore方法中，需要定义用于保存当前状态的变量以及用于保存状态改变后执行函数的监听器。\n\n\n``` js\nlet currentState;\nlet currentListeners = [];\n```\n\n此处定义currentState为当前状态，初始化为undefined;定义currentListenners为监听器，初始化为数组。\n\n然后，定义getState方法，用于获取当前状态，直接返回currentState：\n\n``` js\nfunction getState() {\n  return currentState;\n}\n```\n\n\n然后，定义subscribe函数，用于订阅状态改变时执行的方法：\n\n``` js\nfunction subscribe(listener) {\n  currentListeners.push(listener);\n}\n```\n\nsubscribe方法传入一个监听函数，将监听函数push进监听器数组中。\n然后定义dispatch方法，用于发起action：\n\n``` js\nfunction dispatch(action) {\n  currentState = reducer(currentState, action);\n  currentListeners.forEach(v => v());\n  return action;\n}\n```\n\ndispatch方法传入action，然后调用reducer开始更新currentState，传入当前currentState和action，当状态改变时，通知监听器，监听器数组依次执行数组中的每一个订阅方法，此处使用了设计模式中的发布——订阅模式，然后返回action。\n\n可以看到，上面已经实现了Redux的基本API，那么就结束了吗？当然没有，因为redux并没有初始化，reducer中的初始状态并没有生效，所以需要手动发起一个action，并且action.type必须是独一无二的。如下：\n\n``` js\ndispatch({type: '@@REDUX/INIT'});\n```\n\n此处，对redux进行初始化，定义type为'@@REDUX/INIT'，这样定义的原因是保证命中reducer中action.type为default使其返回初始化state。\n最后，根据redux使用方法可以知道，store肯定是一个对象，对象包含getState、subscribe、dispatch等方法，所有，最后需要将上述方法返回。\n\n``` js\nreturn { getState, subscribe, dispatch };\n```\n\n\n至此，一个超级简单的redux就实现了，麻雀虽小，五脏俱全。这个redux虽然简单，省去了许多错误处理过程，但是对于理解redux足矣。下面是完整代码：\n\n``` js\nexport function createStore(reducer) {\n  let currentState;\n\n  let currentListeners = [];\n\n  function getState() {\n    return currentState;\n  }\n  function subscribe(listener) {\n    currentListeners.push(listener);\n  }\n  function dispatch(action) {\n    currentState = reducer(currentState, action);\n    currentListeners.forEach(v => v());\n    return action;\n  }\n\n  dispatch({type: '@@REDUX/INIT'}); //初始化\n  return { getState, subscribe, dispatch }\n}\n```\n\n### 测试\n下面结合之前的计数器例子来验证上述redux是否正确。\n在前面计数器例子中，打开src下index.js，修改如下代码：\n\n``` js\nimport { createStore } from './redux';\n```\n\n\n替换redux为刚刚编写的redux.js文件。查看浏览器运行结果。\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_184.png)\n\n如图，与redux的效果一致，达到预期效果。\n\n### 总结\n本文实现了一个简单的redux，完成其基本API的实现，这有助于你理解redux的原理，后面会逐步对其扩展，编写react-redux以及中间件的实现。","slug":"手摸手撸一个简单的Redux（一）","published":1,"updated":"2020-07-16T13:56:47.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcennz001gp70vd1d6lrks","content":"<blockquote>\n<p>理解Redux的原理有助于我们更好的使用它。本文实现Redux的基本API。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>Redux 试图让 state 的变化变得可预测。</p>\n<p>redux已经被越来越多的人使用，理解其原理有助于更好的使用它。阅读redux源码是一个不错的办法，当我们了解了其原理之后，现在来实现一个简单的redux吧。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-3</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h3><p>如果你使用过redux，应该对redux的API了然于胸吧。redux的基本API包括createStore、getState、subscribe、dispatch。现在回顾一下redux的使用方法：</p>\n<p>首先，redux暴露出createStore方法，调用createStore方法传入reducer，使用const store = createStore(reducer)，（此处暂时不考虑中间件），使用store.getState()获取状态，使用store.dispatch()发起一个action，使用store.subscribe()订阅状态改变时执行的函数。下面是redux API的简单实现。</p>\n<p>为了方便调试，使用前面讲的redux实现简单计数器的代码，在src目录下新建redux.js，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在redux.js中，先导出redux的核心方法 createStore，传入reducer作为参数。<br>在createStore方法中，需要定义用于保存当前状态的变量以及用于保存状态改变后执行函数的监听器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentState;</span><br><span class=\"line\"><span class=\"keyword\">let</span> currentListeners = [];</span><br></pre></td></tr></table></figure>\n<p>此处定义currentState为当前状态，初始化为undefined;定义currentListenners为监听器，初始化为数组。</p>\n<p>然后，定义getState方法，用于获取当前状态，直接返回currentState：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，定义subscribe函数，用于订阅状态改变时执行的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">  currentListeners.push(listener);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>subscribe方法传入一个监听函数，将监听函数push进监听器数组中。<br>然后定义dispatch方法，用于发起action：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">  currentState = reducer(currentState, action);</span><br><span class=\"line\">  currentListeners.forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>dispatch方法传入action，然后调用reducer开始更新currentState，传入当前currentState和action，当状态改变时，通知监听器，监听器数组依次执行数组中的每一个订阅方法，此处使用了设计模式中的发布——订阅模式，然后返回action。</p>\n<p>可以看到，上面已经实现了Redux的基本API，那么就结束了吗？当然没有，因为redux并没有初始化，reducer中的初始状态并没有生效，所以需要手动发起一个action，并且action.type必须是独一无二的。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">dispatch(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'@@REDUX/INIT'</span>&#125;);</span><br></pre></td></tr></table></figure>\n<p>此处，对redux进行初始化，定义type为‘@@REDUX/INIT’，这样定义的原因是保证命中reducer中action.type为default使其返回初始化state。<br>最后，根据redux使用方法可以知道，store肯定是一个对象，对象包含getState、subscribe、dispatch等方法，所有，最后需要将上述方法返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123; getState, subscribe, dispatch &#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，一个超级简单的redux就实现了，麻雀虽小，五脏俱全。这个redux虽然简单，省去了许多错误处理过程，但是对于理解redux足矣。下面是完整代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    currentListeners.push(listener);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    currentState = reducer(currentState, action);</span><br><span class=\"line\">    currentListeners.forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dispatch(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'@@REDUX/INIT'</span>&#125;); <span class=\"comment\">//初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; getState, subscribe, dispatch &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>下面结合之前的计数器例子来验证上述redux是否正确。<br>在前面计数器例子中，打开src下index.js，修改如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br></pre></td></tr></table></figure>\n<p>替换redux为刚刚编写的redux.js文件。查看浏览器运行结果。<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_184.png\" alt=\"image\"></p>\n<p>如图，与redux的效果一致，达到预期效果。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文实现了一个简单的redux，完成其基本API的实现，这有助于你理解redux的原理，后面会逐步对其扩展，编写react-redux以及中间件的实现。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>理解Redux的原理有助于我们更好的使用它。本文实现Redux的基本API。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>","more":"<p>Redux 试图让 state 的变化变得可预测。</p>\n<p>redux已经被越来越多的人使用，理解其原理有助于更好的使用它。阅读redux源码是一个不错的办法，当我们了解了其原理之后，现在来实现一个简单的redux吧。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-3</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h3><p>如果你使用过redux，应该对redux的API了然于胸吧。redux的基本API包括createStore、getState、subscribe、dispatch。现在回顾一下redux的使用方法：</p>\n<p>首先，redux暴露出createStore方法，调用createStore方法传入reducer，使用const store = createStore(reducer)，（此处暂时不考虑中间件），使用store.getState()获取状态，使用store.dispatch()发起一个action，使用store.subscribe()订阅状态改变时执行的函数。下面是redux API的简单实现。</p>\n<p>为了方便调试，使用前面讲的redux实现简单计数器的代码，在src目录下新建redux.js，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在redux.js中，先导出redux的核心方法 createStore，传入reducer作为参数。<br>在createStore方法中，需要定义用于保存当前状态的变量以及用于保存状态改变后执行函数的监听器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentState;</span><br><span class=\"line\"><span class=\"keyword\">let</span> currentListeners = [];</span><br></pre></td></tr></table></figure>\n<p>此处定义currentState为当前状态，初始化为undefined;定义currentListenners为监听器，初始化为数组。</p>\n<p>然后，定义getState方法，用于获取当前状态，直接返回currentState：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，定义subscribe函数，用于订阅状态改变时执行的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">  currentListeners.push(listener);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>subscribe方法传入一个监听函数，将监听函数push进监听器数组中。<br>然后定义dispatch方法，用于发起action：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">  currentState = reducer(currentState, action);</span><br><span class=\"line\">  currentListeners.forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>dispatch方法传入action，然后调用reducer开始更新currentState，传入当前currentState和action，当状态改变时，通知监听器，监听器数组依次执行数组中的每一个订阅方法，此处使用了设计模式中的发布——订阅模式，然后返回action。</p>\n<p>可以看到，上面已经实现了Redux的基本API，那么就结束了吗？当然没有，因为redux并没有初始化，reducer中的初始状态并没有生效，所以需要手动发起一个action，并且action.type必须是独一无二的。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">dispatch(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'@@REDUX/INIT'</span>&#125;);</span><br></pre></td></tr></table></figure>\n<p>此处，对redux进行初始化，定义type为‘@@REDUX/INIT’，这样定义的原因是保证命中reducer中action.type为default使其返回初始化state。<br>最后，根据redux使用方法可以知道，store肯定是一个对象，对象包含getState、subscribe、dispatch等方法，所有，最后需要将上述方法返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123; getState, subscribe, dispatch &#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，一个超级简单的redux就实现了，麻雀虽小，五脏俱全。这个redux虽然简单，省去了许多错误处理过程，但是对于理解redux足矣。下面是完整代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    currentListeners.push(listener);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    currentState = reducer(currentState, action);</span><br><span class=\"line\">    currentListeners.forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dispatch(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'@@REDUX/INIT'</span>&#125;); <span class=\"comment\">//初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; getState, subscribe, dispatch &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>下面结合之前的计数器例子来验证上述redux是否正确。<br>在前面计数器例子中，打开src下index.js，修改如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br></pre></td></tr></table></figure>\n<p>替换redux为刚刚编写的redux.js文件。查看浏览器运行结果。<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_184.png\" alt=\"image\"></p>\n<p>如图，与redux的效果一致，达到预期效果。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文实现了一个简单的redux，完成其基本API的实现，这有助于你理解redux的原理，后面会逐步对其扩展，编写react-redux以及中间件的实现。</p>"},{"title":"手摸手撸一个简单的Redux（二）","date":"2018-03-06T09:32:05.000Z","banner":"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg","_content":"\n> 理解Redux的原理有助于我们更好的使用它。本文实现react-redux的功能。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n在上一篇文章中，实现了一个简单的Redux，主要是对它的API进行了实现。本文将会实现一个简单的react-redux。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-4\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n使用react开发应用时，通常使用props来进行组件之间的数据传递，但是，当你的应用组件层级嵌套很深时，如果需要从根组件传递数据到最里层的组件，你可能需要向下每层都手动地传递你需要的props，这时，你需要react提供的context API。\n\nreact官方并不建议使用context API，因为context是一个实验性的API，在未来的react版本中可能会被更改。到目前为止，react 16的最新版本已经更改了context API。\n\n尽管有官方的警告，但是仍然有需要使用到context的场景。一个比较好的做法是将context的代码隔离到一小块地方并避免直接使用cntext API，这样以后API变更的时候更容易升级。这也是react-redux的做法。\n\n### Context的用法\n\n考虑如下代码：\n\n``` js\nconst PropTypes = require('prop-types');\n\nclass Button extends React.Component {\n  render() {\n    return (\n      <button style={{background: this.context.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nButton.contextTypes = {\n  color: PropTypes.string\n};\n\nclass Message extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.text} <Button>Delete</Button>\n      </div>\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    const children = this.props.messages.map((message) =>\n      <Message text={message.text} />\n    );\n    return <div>{children}</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n```\n\n上述代码包含三个组件，顶层组件MessageList包含多个Message组件，每个Message组件中包含了Button组件。如果需要从顶层的MessageList组件中传递color属性到Button组件，需要手动将color属性通过props传递到Message，然后再从Message传递到Button组件中。上述代码使用了Context API来实现。首先需要一个context提供者，在这里是MessageList，MessageList组件需要添加getChildContext方法和childContextTypes等官方API。getChildContext方法用于返回全局的context对象，childContextTypes用于定义context属性的类型。React会向下自动传递context参数，任何组件只要在它的子组件中，就可以通过定义ContextTypes来获取context参数。\n\n### 更新Context\n\nreact官方现在已经废弃了更新contetx的API，为了更新context的数据，可以使用this.setState来更新本地state，当state或者props更新时，getChildContext会自动调用。将会生成一个新的context，所有子组件都会收到更新。\n考虑如下代码：\n\n``` js\nconst PropTypes = require('prop-types');\n\nclass MediaQuery extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {type:'desktop'};\n  }\n\n  getChildContext() {\n    return {type: this.state.type};\n  }\n\n  componentDidMount() {\n    const checkMediaQuery = () => {\n      const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile';\n      if (type !== this.state.type) {\n        this.setState({type});\n      }\n    };\n\n    window.addEventListener('resize', checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\nMediaQuery.childContextTypes = {\n  type: PropTypes.string\n};\n```\n\n\n在getChildContext中，返回一个context对象，其值为this.state.type，当你需要更新context时，调用this.setState更新state，state更新后，会自动执行getChildContext返回新的context。\n\n### react-redux实现\n\n#### Provider实现\n在前面的文章已经介绍了react-redux的使用，react-redux的API主要包括connect和Provider。首先来看一下Provider的实现。\n\n回顾Provider的用法。\n\n``` js\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n从上述代码可以看到，Provider是一个组件，包裹在应用的根组件，接收一个store的props，在react-redux中，Provider组件提供context。\n\n接上一篇文章的项目，在src目录下新建react-redux.js，首先声明Provider组件。\n\n``` js\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nexport class Provider extends React.Component {\n\n}\n```\n\nProvider组件没有自己的UI渲染逻辑，只负责处理context部分逻辑。\n\n\n``` js\nexport class Provider extends React.Component {\n  static childContextType = {\n    store: PropTypes.object\n  }\n  constructor(props, context) {\n    super(props, context)\n    \n    this.store = props.store\n\n  }\n  render() {\n\n    return this.props.children\n\n  }\n}\n```\n\n这一步，在静态方法childContextTypes中定义context属性store的类型为object，在constructor构造函数中，传入props和context，定义this.store并赋值为props.store。这样，在Provider中任何地方都可以使用this.store获取到props中的store属性。\n由于Provider不负责UI渲染，在render方法中，直接返回this.props.children即可，即返回子组件。\n\n最后在Provider中，还需要添加getChildContext方法，用于提供context。\n\n``` js\nexport class Provider extends React.Component {\n  static childContextTypes = {\n    store: PropTypes.object\n  }\n  getChildContext() {\n    return {store: this.store}\n  }\n  constructor(props, context) {\n    super(props, context)\n    this.store = props.store\n  }\n  render() {\n    return this.props.children\n  }\n}\n```\n\n在getChildContext中，生成context对象，此处的context就是this.store，让子组件能够获取到context。\n\n#### connect实现\n在react-redux中，connect负责连接组件，接受一个组件作为参数，将store中的属性传入到组件的props中，并且返回一个新的组件，这种组件设计模式称为高阶组件。当数据变化时，connect将会通知组件更新。\n\n回顾connect的使用。\n\n``` js\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link)\n```\n\n\nconnect首先定义为一个高阶函数，\n在react-redux.js中，首先定义connect方法：\n\n``` js\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps={}) => (WrapComponent) => {\n    return class ConectComponent extends React.Component {\n    }\n}\n```\n\n\nconnect是一个两层的箭头函数，第一层，传入mapStateToProps和mapDispatchToProps参数，这两个参数是可选参数，需要定义初始值，mapStateToProps定义为函数，mapDispatchToProps有多种参数形式，可以是函数或者对象，这里默认设为空对象。connect方法最终应该返回一个组件，在第二层函数中，传入一个组件作为参数,并返回一个新的组件。上述代码可以改写为如下：\n\n\n``` js\nexport function connect(mapStateToProps, mapDispatchToProps) {\n  return function (wrapComponent) {\n    return class ConnectComponent extends React.Component {\n\n    }\n  }\n}\n```\n\n\n这样看起来就很清晰了，connect首先执行最外层返回一个函数，然后传入一个组件，执行最里层，返回一个组件。\n在返回的组件内部，需要获取context，代码如下：\n\n``` js\nstatic contextTypes = {\n  store: PropTypes.object\n}\n```\n\n\n然后是constructor的实现：\n\n``` js\nconstructor(props, context) {\n  super(props, context);\n  this.state = {\n    props: {}\n  }\n}\n```\n\n在constructor中，定义了一个props属性作为state，初始化为空对象。props将传递到wrapComponent上。\n\n在render函数中：\n\n\n``` js\nrender() {\n  return <WrapComponent {...this.state.props}/>\n}\n```\n\n在render函数中，将state.props解构传递到WrapComponent的props属性中。当然，state.props并没有如此简单，还需要将mapStateToProps和mapDiapatchToProps的数据注入进去。\n在componentDidMount中，代码如下：\n\n``` js\ncomponentDidMount() {\n  const { store } = this.context;\n  store.subscribe(() => this.update());\n  this.update();\n}\n```\n\n在上述代码中，首先获取到context中的store，然后调用update方法来更新state。同样，在store.subscribe中传入store更新后的方法，当store更新后需要调用update方法。update方法如下：\n\n\n``` js\nupdate() {\n  const { store } = this.context;\n  const stateProps = mapStateToProps(store.getState());\n\n  this.setState({\n    props: {\n      ...this.state.props,\n      ...stateProps,\n    }\n  })\n}\n```\n\n在update方法中，首先从context中获取到store，考虑需要connect的数据分为两部分，第一部分是将state中的数据映射到props中，调用connect的第一个参数mapStateToProps传入store.getState（），即传入全局的state。然后得到stateProps对象用于传入props中。然后通过this.setState来更新state，这里通过对象延展语法来对对象进行解构合并新旧state。\n\n上面只实现了state数据的映射，还需要方法的映射，数据的映射较为简单，而方法不能直接使用，因为需要对方法调用store.dispatch。这里需要在redux中实现一个bindActionCreators方法，按如下方式调用：\n\n\n``` js\nimport { bindActionCreators } from './redux';\n\n\n\nconst dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n```\nbindActionCreators用于将store.dispatch传递到函数内部，调用函数时能够在内部dispatch该函数。\n\n在src目录下的redux.js下，实现bindActionCreators方法：\n\n\n``` js\nexport function bindActionCreators(creators, dispatch) {\n  let bound = {};\n  Object.keys(creators).forEach(v => {\n    let creator = creators[v];\n    bound[v] = bindActionCreator(creator, dispatch);\n  })\n  return bound;\n}\n```\n\n\n在bindActionCreators方法中，传入connect的第二个参数mapDispatchToProps定义为creators，creators是一个对象，在这里需要对creators中的每一个方法使用dispatch进行一次包装，使用Object.keys返回对象可枚举属性组成的数组，然后循环数组，根据数组索引，依次取数组索引对应的方法，然后调用bindActionCreator返回一个由dispatch包装的新的方法，并且组装为一个新的对象bound返回，key保持不变。\n下面实现bindActionCreator：\n\n``` js\nfunction bindActionCreator(creator, dispatch) {\n  return (...args) => dispatch(creator(...args))\n}\n```\n\n\n在bindActionCreator方法中，使用高阶函数返回了一个新的函数，原函数creator经dispatch包装后，使用剩余参数...args透传到被包装函数内。这样是为了保证参数能够传递到最内层。\n到这里，已经实现了connect的两个部分的数据，下面是完整的update方法：\n\n\n``` js\nupdate() {\n  const { store } = this.context;\n  const stateProps = mapStateToProps(store.getState());\n\n  const dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n\n  this.setState({\n    props: {\n      ...this.state.props,\n      ...stateProps,\n      ...dispatchProps,\n    }\n  })\n}\n```\n\n最终的update方法中，将stateProps和dispatchProps都更新到state.props中，这样，每次数据更新都能通知到子组件进行同步更新。\n现在，react-redux的基本功能已经实现了，下面是完整的react-redux代码：\n\n\n``` js\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { bindActionCreators } from './redux';\n\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps={}) => (WrapComponent) => {\n  return class ConectComponent extends React.Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    constructor(props, context) {\n      super(props, context);\n      this.state = {\n        props: {}\n      }\n    }\n    componentDidMount() {\n      const { store } = this.context;\n      store.subscribe(() => this.update());\n      this.update();\n    }\n    update() {\n      const { store } = this.context;\n\n      const stateProps = mapStateToProps(store.getState());\n\n      const dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n\n      this.setState({\n        props: {\n          ...this.state.props,\n          ...stateProps,\n          ...dispatchProps,\n        }\n      })\n    }\n    render() {\n      return <WrapComponent {...this.state.props}/>\n    }\n  }\n}\n\nexport class Provider extends React.Component {\n  static childContextTypes = {\n    store: PropTypes.object\n  }\n  getChildContext() {\n    return {store: this.store}\n  }\n  constructor(props, context) {\n    super(props, context);\n    this.store = props.store;\n  }\n  render() {\n    return this.props.children\n  }\n}\n```\n\n### 使用react-redux来改写计数器应用\n\n在之前的文章中，使用自己编写的redux实现了一个简单的计数器应用，现在将它改写为react-redux实现：\n\n**App.js**如下：\n\n``` js\nimport React, { Component } from 'react';\nimport { connect } from './react-redux';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { onIncrement, onDecrement, counter } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={counter}\n          onIncrement={onIncrement}\n          onDecrement={onDecrement}\n        />\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  counter: state\n});\n\nfunction onIncrement() {\n  return { type: 'INCREMENT' }\n}\n\nfunction onDecrement() {\n  return { type: 'DECREMENT' }\n}\n\nconst mapDispatchToProps = {\n  onIncrement,\n  onDecrement\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n注意，由于在react-redux中connect中对mapDispatchToProps的处理仅考虑了其值为对象的情况，而实际可以支持对象或者函数作为参数，故在这里需要设置为对象的形式。\n\nindex.js代码如下：\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from './react-redux';\nimport './index.css';\nimport App from './App';\nimport { createStore } from './redux';\nimport counter from './reducers';\n\nconst store = createStore(counter);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n最后，npm start运行项目，打开浏览器界面如下，对其进行操作，符合预期效果：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_191.png)","source":"_posts/手摸手撸一个简单的Redux（二）.md","raw":"---\ntitle: 手摸手撸一个简单的Redux（二）\ndate: 2018-03-6 17:32:05\nbanner: http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\ntags:\n - Redux\n - React\n---\n\n> 理解Redux的原理有助于我们更好的使用它。本文实现react-redux的功能。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n在上一篇文章中，实现了一个简单的Redux，主要是对它的API进行了实现。本文将会实现一个简单的react-redux。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-4\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n使用react开发应用时，通常使用props来进行组件之间的数据传递，但是，当你的应用组件层级嵌套很深时，如果需要从根组件传递数据到最里层的组件，你可能需要向下每层都手动地传递你需要的props，这时，你需要react提供的context API。\n\nreact官方并不建议使用context API，因为context是一个实验性的API，在未来的react版本中可能会被更改。到目前为止，react 16的最新版本已经更改了context API。\n\n尽管有官方的警告，但是仍然有需要使用到context的场景。一个比较好的做法是将context的代码隔离到一小块地方并避免直接使用cntext API，这样以后API变更的时候更容易升级。这也是react-redux的做法。\n\n### Context的用法\n\n考虑如下代码：\n\n``` js\nconst PropTypes = require('prop-types');\n\nclass Button extends React.Component {\n  render() {\n    return (\n      <button style={{background: this.context.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nButton.contextTypes = {\n  color: PropTypes.string\n};\n\nclass Message extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.text} <Button>Delete</Button>\n      </div>\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    const children = this.props.messages.map((message) =>\n      <Message text={message.text} />\n    );\n    return <div>{children}</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n```\n\n上述代码包含三个组件，顶层组件MessageList包含多个Message组件，每个Message组件中包含了Button组件。如果需要从顶层的MessageList组件中传递color属性到Button组件，需要手动将color属性通过props传递到Message，然后再从Message传递到Button组件中。上述代码使用了Context API来实现。首先需要一个context提供者，在这里是MessageList，MessageList组件需要添加getChildContext方法和childContextTypes等官方API。getChildContext方法用于返回全局的context对象，childContextTypes用于定义context属性的类型。React会向下自动传递context参数，任何组件只要在它的子组件中，就可以通过定义ContextTypes来获取context参数。\n\n### 更新Context\n\nreact官方现在已经废弃了更新contetx的API，为了更新context的数据，可以使用this.setState来更新本地state，当state或者props更新时，getChildContext会自动调用。将会生成一个新的context，所有子组件都会收到更新。\n考虑如下代码：\n\n``` js\nconst PropTypes = require('prop-types');\n\nclass MediaQuery extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {type:'desktop'};\n  }\n\n  getChildContext() {\n    return {type: this.state.type};\n  }\n\n  componentDidMount() {\n    const checkMediaQuery = () => {\n      const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile';\n      if (type !== this.state.type) {\n        this.setState({type});\n      }\n    };\n\n    window.addEventListener('resize', checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\nMediaQuery.childContextTypes = {\n  type: PropTypes.string\n};\n```\n\n\n在getChildContext中，返回一个context对象，其值为this.state.type，当你需要更新context时，调用this.setState更新state，state更新后，会自动执行getChildContext返回新的context。\n\n### react-redux实现\n\n#### Provider实现\n在前面的文章已经介绍了react-redux的使用，react-redux的API主要包括connect和Provider。首先来看一下Provider的实现。\n\n回顾Provider的用法。\n\n``` js\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n从上述代码可以看到，Provider是一个组件，包裹在应用的根组件，接收一个store的props，在react-redux中，Provider组件提供context。\n\n接上一篇文章的项目，在src目录下新建react-redux.js，首先声明Provider组件。\n\n``` js\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nexport class Provider extends React.Component {\n\n}\n```\n\nProvider组件没有自己的UI渲染逻辑，只负责处理context部分逻辑。\n\n\n``` js\nexport class Provider extends React.Component {\n  static childContextType = {\n    store: PropTypes.object\n  }\n  constructor(props, context) {\n    super(props, context)\n    \n    this.store = props.store\n\n  }\n  render() {\n\n    return this.props.children\n\n  }\n}\n```\n\n这一步，在静态方法childContextTypes中定义context属性store的类型为object，在constructor构造函数中，传入props和context，定义this.store并赋值为props.store。这样，在Provider中任何地方都可以使用this.store获取到props中的store属性。\n由于Provider不负责UI渲染，在render方法中，直接返回this.props.children即可，即返回子组件。\n\n最后在Provider中，还需要添加getChildContext方法，用于提供context。\n\n``` js\nexport class Provider extends React.Component {\n  static childContextTypes = {\n    store: PropTypes.object\n  }\n  getChildContext() {\n    return {store: this.store}\n  }\n  constructor(props, context) {\n    super(props, context)\n    this.store = props.store\n  }\n  render() {\n    return this.props.children\n  }\n}\n```\n\n在getChildContext中，生成context对象，此处的context就是this.store，让子组件能够获取到context。\n\n#### connect实现\n在react-redux中，connect负责连接组件，接受一个组件作为参数，将store中的属性传入到组件的props中，并且返回一个新的组件，这种组件设计模式称为高阶组件。当数据变化时，connect将会通知组件更新。\n\n回顾connect的使用。\n\n``` js\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link)\n```\n\n\nconnect首先定义为一个高阶函数，\n在react-redux.js中，首先定义connect方法：\n\n``` js\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps={}) => (WrapComponent) => {\n    return class ConectComponent extends React.Component {\n    }\n}\n```\n\n\nconnect是一个两层的箭头函数，第一层，传入mapStateToProps和mapDispatchToProps参数，这两个参数是可选参数，需要定义初始值，mapStateToProps定义为函数，mapDispatchToProps有多种参数形式，可以是函数或者对象，这里默认设为空对象。connect方法最终应该返回一个组件，在第二层函数中，传入一个组件作为参数,并返回一个新的组件。上述代码可以改写为如下：\n\n\n``` js\nexport function connect(mapStateToProps, mapDispatchToProps) {\n  return function (wrapComponent) {\n    return class ConnectComponent extends React.Component {\n\n    }\n  }\n}\n```\n\n\n这样看起来就很清晰了，connect首先执行最外层返回一个函数，然后传入一个组件，执行最里层，返回一个组件。\n在返回的组件内部，需要获取context，代码如下：\n\n``` js\nstatic contextTypes = {\n  store: PropTypes.object\n}\n```\n\n\n然后是constructor的实现：\n\n``` js\nconstructor(props, context) {\n  super(props, context);\n  this.state = {\n    props: {}\n  }\n}\n```\n\n在constructor中，定义了一个props属性作为state，初始化为空对象。props将传递到wrapComponent上。\n\n在render函数中：\n\n\n``` js\nrender() {\n  return <WrapComponent {...this.state.props}/>\n}\n```\n\n在render函数中，将state.props解构传递到WrapComponent的props属性中。当然，state.props并没有如此简单，还需要将mapStateToProps和mapDiapatchToProps的数据注入进去。\n在componentDidMount中，代码如下：\n\n``` js\ncomponentDidMount() {\n  const { store } = this.context;\n  store.subscribe(() => this.update());\n  this.update();\n}\n```\n\n在上述代码中，首先获取到context中的store，然后调用update方法来更新state。同样，在store.subscribe中传入store更新后的方法，当store更新后需要调用update方法。update方法如下：\n\n\n``` js\nupdate() {\n  const { store } = this.context;\n  const stateProps = mapStateToProps(store.getState());\n\n  this.setState({\n    props: {\n      ...this.state.props,\n      ...stateProps,\n    }\n  })\n}\n```\n\n在update方法中，首先从context中获取到store，考虑需要connect的数据分为两部分，第一部分是将state中的数据映射到props中，调用connect的第一个参数mapStateToProps传入store.getState（），即传入全局的state。然后得到stateProps对象用于传入props中。然后通过this.setState来更新state，这里通过对象延展语法来对对象进行解构合并新旧state。\n\n上面只实现了state数据的映射，还需要方法的映射，数据的映射较为简单，而方法不能直接使用，因为需要对方法调用store.dispatch。这里需要在redux中实现一个bindActionCreators方法，按如下方式调用：\n\n\n``` js\nimport { bindActionCreators } from './redux';\n\n\n\nconst dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n```\nbindActionCreators用于将store.dispatch传递到函数内部，调用函数时能够在内部dispatch该函数。\n\n在src目录下的redux.js下，实现bindActionCreators方法：\n\n\n``` js\nexport function bindActionCreators(creators, dispatch) {\n  let bound = {};\n  Object.keys(creators).forEach(v => {\n    let creator = creators[v];\n    bound[v] = bindActionCreator(creator, dispatch);\n  })\n  return bound;\n}\n```\n\n\n在bindActionCreators方法中，传入connect的第二个参数mapDispatchToProps定义为creators，creators是一个对象，在这里需要对creators中的每一个方法使用dispatch进行一次包装，使用Object.keys返回对象可枚举属性组成的数组，然后循环数组，根据数组索引，依次取数组索引对应的方法，然后调用bindActionCreator返回一个由dispatch包装的新的方法，并且组装为一个新的对象bound返回，key保持不变。\n下面实现bindActionCreator：\n\n``` js\nfunction bindActionCreator(creator, dispatch) {\n  return (...args) => dispatch(creator(...args))\n}\n```\n\n\n在bindActionCreator方法中，使用高阶函数返回了一个新的函数，原函数creator经dispatch包装后，使用剩余参数...args透传到被包装函数内。这样是为了保证参数能够传递到最内层。\n到这里，已经实现了connect的两个部分的数据，下面是完整的update方法：\n\n\n``` js\nupdate() {\n  const { store } = this.context;\n  const stateProps = mapStateToProps(store.getState());\n\n  const dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n\n  this.setState({\n    props: {\n      ...this.state.props,\n      ...stateProps,\n      ...dispatchProps,\n    }\n  })\n}\n```\n\n最终的update方法中，将stateProps和dispatchProps都更新到state.props中，这样，每次数据更新都能通知到子组件进行同步更新。\n现在，react-redux的基本功能已经实现了，下面是完整的react-redux代码：\n\n\n``` js\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { bindActionCreators } from './redux';\n\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps={}) => (WrapComponent) => {\n  return class ConectComponent extends React.Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    constructor(props, context) {\n      super(props, context);\n      this.state = {\n        props: {}\n      }\n    }\n    componentDidMount() {\n      const { store } = this.context;\n      store.subscribe(() => this.update());\n      this.update();\n    }\n    update() {\n      const { store } = this.context;\n\n      const stateProps = mapStateToProps(store.getState());\n\n      const dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n\n      this.setState({\n        props: {\n          ...this.state.props,\n          ...stateProps,\n          ...dispatchProps,\n        }\n      })\n    }\n    render() {\n      return <WrapComponent {...this.state.props}/>\n    }\n  }\n}\n\nexport class Provider extends React.Component {\n  static childContextTypes = {\n    store: PropTypes.object\n  }\n  getChildContext() {\n    return {store: this.store}\n  }\n  constructor(props, context) {\n    super(props, context);\n    this.store = props.store;\n  }\n  render() {\n    return this.props.children\n  }\n}\n```\n\n### 使用react-redux来改写计数器应用\n\n在之前的文章中，使用自己编写的redux实现了一个简单的计数器应用，现在将它改写为react-redux实现：\n\n**App.js**如下：\n\n``` js\nimport React, { Component } from 'react';\nimport { connect } from './react-redux';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { onIncrement, onDecrement, counter } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={counter}\n          onIncrement={onIncrement}\n          onDecrement={onDecrement}\n        />\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  counter: state\n});\n\nfunction onIncrement() {\n  return { type: 'INCREMENT' }\n}\n\nfunction onDecrement() {\n  return { type: 'DECREMENT' }\n}\n\nconst mapDispatchToProps = {\n  onIncrement,\n  onDecrement\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n注意，由于在react-redux中connect中对mapDispatchToProps的处理仅考虑了其值为对象的情况，而实际可以支持对象或者函数作为参数，故在这里需要设置为对象的形式。\n\nindex.js代码如下：\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from './react-redux';\nimport './index.css';\nimport App from './App';\nimport { createStore } from './redux';\nimport counter from './reducers';\n\nconst store = createStore(counter);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n最后，npm start运行项目，打开浏览器界面如下，对其进行操作，符合预期效果：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_191.png)","slug":"手摸手撸一个简单的Redux（二）","published":1,"updated":"2020-07-16T13:56:47.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pceno3001ip70vds5mopj6","content":"<blockquote>\n<p>理解Redux的原理有助于我们更好的使用它。本文实现react-redux的功能。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>在上一篇文章中，实现了一个简单的Redux，主要是对它的API进行了实现。本文将会实现一个简单的react-redux。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-4</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>使用react开发应用时，通常使用props来进行组件之间的数据传递，但是，当你的应用组件层级嵌套很深时，如果需要从根组件传递数据到最里层的组件，你可能需要向下每层都手动地传递你需要的props，这时，你需要react提供的context API。</p>\n<p>react官方并不建议使用context API，因为context是一个实验性的API，在未来的react版本中可能会被更改。到目前为止，react 16的最新版本已经更改了context API。</p>\n<p>尽管有官方的警告，但是仍然有需要使用到context的场景。一个比较好的做法是将context的代码隔离到一小块地方并避免直接使用cntext API，这样以后API变更的时候更容易升级。这也是react-redux的做法。</p>\n<h3 id=\"Context的用法\"><a href=\"#Context的用法\" class=\"headerlink\" title=\"Context的用法\"></a>Context的用法</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PropTypes = <span class=\"built_in\">require</span>(<span class=\"string\">'prop-types'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button style=&#123;&#123;<span class=\"attr\">background</span>: <span class=\"keyword\">this</span>.context.color&#125;&#125;&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Button.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  color: PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">class Message extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/</span>Button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">class MessageList extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  getChildContext() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;color: \"purple\"&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    const children = this.props.messages.map((message) =&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;Message text=&#123;message.text&#125; /</span>&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MessageList.childContextTypes = &#123;</span><br><span class=\"line\">  color: PropTypes.string</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述代码包含三个组件，顶层组件MessageList包含多个Message组件，每个Message组件中包含了Button组件。如果需要从顶层的MessageList组件中传递color属性到Button组件，需要手动将color属性通过props传递到Message，然后再从Message传递到Button组件中。上述代码使用了Context API来实现。首先需要一个context提供者，在这里是MessageList，MessageList组件需要添加getChildContext方法和childContextTypes等官方API。getChildContext方法用于返回全局的context对象，childContextTypes用于定义context属性的类型。React会向下自动传递context参数，任何组件只要在它的子组件中，就可以通过定义ContextTypes来获取context参数。</p>\n<h3 id=\"更新Context\"><a href=\"#更新Context\" class=\"headerlink\" title=\"更新Context\"></a>更新Context</h3><p>react官方现在已经废弃了更新contetx的API，为了更新context的数据，可以使用this.setState来更新本地state，当state或者props更新时，getChildContext会自动调用。将会生成一个新的context，所有子组件都会收到更新。<br>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PropTypes = <span class=\"built_in\">require</span>(<span class=\"string\">'prop-types'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaQuery</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">type</span>:<span class=\"string\">'desktop'</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">type</span>: <span class=\"keyword\">this</span>.state.type&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> checkMediaQuery = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> type = <span class=\"built_in\">window</span>.matchMedia(<span class=\"string\">\"(min-width: 1025px)\"</span>).matches ? <span class=\"string\">'desktop'</span> : <span class=\"string\">'mobile'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (type !== <span class=\"keyword\">this</span>.state.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;type&#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, checkMediaQuery);</span><br><span class=\"line\">    checkMediaQuery();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MediaQuery.childContextTypes = &#123;</span><br><span class=\"line\">  type: PropTypes.string</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在getChildContext中，返回一个context对象，其值为this.state.type，当你需要更新context时，调用this.setState更新state，state更新后，会自动执行getChildContext返回新的context。</p>\n<h3 id=\"react-redux实现\"><a href=\"#react-redux实现\" class=\"headerlink\" title=\"react-redux实现\"></a>react-redux实现</h3><h4 id=\"Provider实现\"><a href=\"#Provider实现\" class=\"headerlink\" title=\"Provider实现\"></a>Provider实现</h4><p>在前面的文章已经介绍了react-redux的使用，react-redux的API主要包括connect和Provider。首先来看一下Provider的实现。</p>\n<p>回顾Provider的用法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>从上述代码可以看到，Provider是一个组件，包裹在应用的根组件，接收一个store的props，在react-redux中，Provider组件提供context。</p>\n<p>接上一篇文章的项目，在src目录下新建react-redux.js，首先声明Provider组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Provider组件没有自己的UI渲染逻辑，只负责处理context部分逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextType = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步，在静态方法childContextTypes中定义context属性store的类型为object，在constructor构造函数中，传入props和context，定义this.store并赋值为props.store。这样，在Provider中任何地方都可以使用this.store获取到props中的store属性。<br>由于Provider不负责UI渲染，在render方法中，直接返回this.props.children即可，即返回子组件。</p>\n<p>最后在Provider中，还需要添加getChildContext方法，用于提供context。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextTypes = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">store</span>: <span class=\"keyword\">this</span>.store&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在getChildContext中，生成context对象，此处的context就是this.store，让子组件能够获取到context。</p>\n<h4 id=\"connect实现\"><a href=\"#connect实现\" class=\"headerlink\" title=\"connect实现\"></a>connect实现</h4><p>在react-redux中，connect负责连接组件，接受一个组件作为参数，将store中的属性传入到组件的props中，并且返回一个新的组件，这种组件设计模式称为高阶组件。当数据变化时，connect将会通知组件更新。</p>\n<p>回顾connect的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link)</span><br></pre></td></tr></table></figure>\n<p>connect首先定义为一个高阶函数，<br>在react-redux.js中，首先定义connect方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state =&gt; state, mapDispatchToProps=&#123;&#125;</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>connect是一个两层的箭头函数，第一层，传入mapStateToProps和mapDispatchToProps参数，这两个参数是可选参数，需要定义初始值，mapStateToProps定义为函数，mapDispatchToProps有多种参数形式，可以是函数或者对象，这里默认设为空对象。connect方法最终应该返回一个组件，在第二层函数中，传入一个组件作为参数,并返回一个新的组件。上述代码可以改写为如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connect</span>(<span class=\"params\">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">wrapComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来就很清晰了，connect首先执行最外层返回一个函数，然后传入一个组件，执行最里层，返回一个组件。<br>在返回的组件内部，需要获取context，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">  store: PropTypes.object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是constructor的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">    props: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在constructor中，定义了一个props属性作为state，初始化为空对象。props将传递到wrapComponent上。</p>\n<p>在render函数中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrapComponent</span> &#123;<span class=\"attr\">...this.state.props</span>&#125;/&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在render函数中，将state.props解构传递到WrapComponent的props属性中。当然，state.props并没有如此简单，还需要将mapStateToProps和mapDiapatchToProps的数据注入进去。<br>在componentDidMount中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，首先获取到context中的store，然后调用update方法来更新state。同样，在store.subscribe中传入store更新后的方法，当store更新后需要调用update方法。update方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...this.state.props,</span><br><span class=\"line\">      ...stateProps,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在update方法中，首先从context中获取到store，考虑需要connect的数据分为两部分，第一部分是将state中的数据映射到props中，调用connect的第一个参数mapStateToProps传入store.getState（），即传入全局的state。然后得到stateProps对象用于传入props中。然后通过this.setState来更新state，这里通过对象延展语法来对对象进行解构合并新旧state。</p>\n<p>上面只实现了state数据的映射，还需要方法的映射，数据的映射较为简单，而方法不能直接使用，因为需要对方法调用store.dispatch。这里需要在redux中实现一个bindActionCreators方法，按如下方式调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br></pre></td></tr></table></figure>\n<p>bindActionCreators用于将store.dispatch传递到函数内部，调用函数时能够在内部dispatch该函数。</p>\n<p>在src目录下的redux.js下，实现bindActionCreators方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreators</span>(<span class=\"params\">creators, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bound = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(creators).forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> creator = creators[v];</span><br><span class=\"line\">    bound[v] = bindActionCreator(creator, dispatch);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在bindActionCreators方法中，传入connect的第二个参数mapDispatchToProps定义为creators，creators是一个对象，在这里需要对creators中的每一个方法使用dispatch进行一次包装，使用Object.keys返回对象可枚举属性组成的数组，然后循环数组，根据数组索引，依次取数组索引对应的方法，然后调用bindActionCreator返回一个由dispatch包装的新的方法，并且组装为一个新的对象bound返回，key保持不变。<br>下面实现bindActionCreator：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">creator, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(creator(...args))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在bindActionCreator方法中，使用高阶函数返回了一个新的函数，原函数creator经dispatch包装后，使用剩余参数…args透传到被包装函数内。这样是为了保证参数能够传递到最内层。<br>到这里，已经实现了connect的两个部分的数据，下面是完整的update方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...this.state.props,</span><br><span class=\"line\">      ...stateProps,</span><br><span class=\"line\">      ...dispatchProps,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终的update方法中，将stateProps和dispatchProps都更新到state.props中，这样，每次数据更新都能通知到子组件进行同步更新。<br>现在，react-redux的基本功能已经实现了，下面是完整的react-redux代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state =&gt; state, mapDispatchToProps=&#123;&#125;</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">      store: PropTypes.object</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        props: &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">      store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">          ...this.state.props,</span><br><span class=\"line\">          ...stateProps,</span><br><span class=\"line\">          ...dispatchProps,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrapComponent</span> &#123;<span class=\"attr\">...this.state.props</span>&#125;/&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextTypes = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">store</span>: <span class=\"keyword\">this</span>.store&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用react-redux来改写计数器应用\"><a href=\"#使用react-redux来改写计数器应用\" class=\"headerlink\" title=\"使用react-redux来改写计数器应用\"></a>使用react-redux来改写计数器应用</h3><p>在之前的文章中，使用自己编写的redux实现了一个简单的计数器应用，现在将它改写为react-redux实现：</p>\n<p><strong>App.js</strong>如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onIncrement, onDecrement, counter &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;counter&#125;</span><br><span class=\"line\">          onIncrement=&#123;onIncrement&#125;</span><br><span class=\"line\">          onDecrement=&#123;onDecrement&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: state</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onIncrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'INCREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onDecrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'DECREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapDispatchToProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure>\n<p>注意，由于在react-redux中connect中对mapDispatchToProps的处理仅考虑了其值为对象的情况，而实际可以支持对象或者函数作为参数，故在这里需要设置为对象的形式。</p>\n<p>index.js代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>最后，npm start运行项目，打开浏览器界面如下，对其进行操作，符合预期效果：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_191.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>理解Redux的原理有助于我们更好的使用它。本文实现react-redux的功能。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>","more":"<p>在上一篇文章中，实现了一个简单的Redux，主要是对它的API进行了实现。本文将会实现一个简单的react-redux。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-4</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>使用react开发应用时，通常使用props来进行组件之间的数据传递，但是，当你的应用组件层级嵌套很深时，如果需要从根组件传递数据到最里层的组件，你可能需要向下每层都手动地传递你需要的props，这时，你需要react提供的context API。</p>\n<p>react官方并不建议使用context API，因为context是一个实验性的API，在未来的react版本中可能会被更改。到目前为止，react 16的最新版本已经更改了context API。</p>\n<p>尽管有官方的警告，但是仍然有需要使用到context的场景。一个比较好的做法是将context的代码隔离到一小块地方并避免直接使用cntext API，这样以后API变更的时候更容易升级。这也是react-redux的做法。</p>\n<h3 id=\"Context的用法\"><a href=\"#Context的用法\" class=\"headerlink\" title=\"Context的用法\"></a>Context的用法</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PropTypes = <span class=\"built_in\">require</span>(<span class=\"string\">'prop-types'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button style=&#123;&#123;<span class=\"attr\">background</span>: <span class=\"keyword\">this</span>.context.color&#125;&#125;&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Button.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  color: PropTypes.string</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">class Message extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/</span>Button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">class MessageList extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  getChildContext() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;color: \"purple\"&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    const children = this.props.messages.map((message) =&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;Message text=&#123;message.text&#125; /</span>&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MessageList.childContextTypes = &#123;</span><br><span class=\"line\">  color: PropTypes.string</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述代码包含三个组件，顶层组件MessageList包含多个Message组件，每个Message组件中包含了Button组件。如果需要从顶层的MessageList组件中传递color属性到Button组件，需要手动将color属性通过props传递到Message，然后再从Message传递到Button组件中。上述代码使用了Context API来实现。首先需要一个context提供者，在这里是MessageList，MessageList组件需要添加getChildContext方法和childContextTypes等官方API。getChildContext方法用于返回全局的context对象，childContextTypes用于定义context属性的类型。React会向下自动传递context参数，任何组件只要在它的子组件中，就可以通过定义ContextTypes来获取context参数。</p>\n<h3 id=\"更新Context\"><a href=\"#更新Context\" class=\"headerlink\" title=\"更新Context\"></a>更新Context</h3><p>react官方现在已经废弃了更新contetx的API，为了更新context的数据，可以使用this.setState来更新本地state，当state或者props更新时，getChildContext会自动调用。将会生成一个新的context，所有子组件都会收到更新。<br>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PropTypes = <span class=\"built_in\">require</span>(<span class=\"string\">'prop-types'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaQuery</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">type</span>:<span class=\"string\">'desktop'</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">type</span>: <span class=\"keyword\">this</span>.state.type&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> checkMediaQuery = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> type = <span class=\"built_in\">window</span>.matchMedia(<span class=\"string\">\"(min-width: 1025px)\"</span>).matches ? <span class=\"string\">'desktop'</span> : <span class=\"string\">'mobile'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (type !== <span class=\"keyword\">this</span>.state.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;type&#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, checkMediaQuery);</span><br><span class=\"line\">    checkMediaQuery();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MediaQuery.childContextTypes = &#123;</span><br><span class=\"line\">  type: PropTypes.string</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在getChildContext中，返回一个context对象，其值为this.state.type，当你需要更新context时，调用this.setState更新state，state更新后，会自动执行getChildContext返回新的context。</p>\n<h3 id=\"react-redux实现\"><a href=\"#react-redux实现\" class=\"headerlink\" title=\"react-redux实现\"></a>react-redux实现</h3><h4 id=\"Provider实现\"><a href=\"#Provider实现\" class=\"headerlink\" title=\"Provider实现\"></a>Provider实现</h4><p>在前面的文章已经介绍了react-redux的使用，react-redux的API主要包括connect和Provider。首先来看一下Provider的实现。</p>\n<p>回顾Provider的用法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>从上述代码可以看到，Provider是一个组件，包裹在应用的根组件，接收一个store的props，在react-redux中，Provider组件提供context。</p>\n<p>接上一篇文章的项目，在src目录下新建react-redux.js，首先声明Provider组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Provider组件没有自己的UI渲染逻辑，只负责处理context部分逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextType = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步，在静态方法childContextTypes中定义context属性store的类型为object，在constructor构造函数中，传入props和context，定义this.store并赋值为props.store。这样，在Provider中任何地方都可以使用this.store获取到props中的store属性。<br>由于Provider不负责UI渲染，在render方法中，直接返回this.props.children即可，即返回子组件。</p>\n<p>最后在Provider中，还需要添加getChildContext方法，用于提供context。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextTypes = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">store</span>: <span class=\"keyword\">this</span>.store&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在getChildContext中，生成context对象，此处的context就是this.store，让子组件能够获取到context。</p>\n<h4 id=\"connect实现\"><a href=\"#connect实现\" class=\"headerlink\" title=\"connect实现\"></a>connect实现</h4><p>在react-redux中，connect负责连接组件，接受一个组件作为参数，将store中的属性传入到组件的props中，并且返回一个新的组件，这种组件设计模式称为高阶组件。当数据变化时，connect将会通知组件更新。</p>\n<p>回顾connect的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link)</span><br></pre></td></tr></table></figure>\n<p>connect首先定义为一个高阶函数，<br>在react-redux.js中，首先定义connect方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state =&gt; state, mapDispatchToProps=&#123;&#125;</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>connect是一个两层的箭头函数，第一层，传入mapStateToProps和mapDispatchToProps参数，这两个参数是可选参数，需要定义初始值，mapStateToProps定义为函数，mapDispatchToProps有多种参数形式，可以是函数或者对象，这里默认设为空对象。connect方法最终应该返回一个组件，在第二层函数中，传入一个组件作为参数,并返回一个新的组件。上述代码可以改写为如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connect</span>(<span class=\"params\">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">wrapComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来就很清晰了，connect首先执行最外层返回一个函数，然后传入一个组件，执行最里层，返回一个组件。<br>在返回的组件内部，需要获取context，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">  store: PropTypes.object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是constructor的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">    props: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在constructor中，定义了一个props属性作为state，初始化为空对象。props将传递到wrapComponent上。</p>\n<p>在render函数中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrapComponent</span> &#123;<span class=\"attr\">...this.state.props</span>&#125;/&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在render函数中，将state.props解构传递到WrapComponent的props属性中。当然，state.props并没有如此简单，还需要将mapStateToProps和mapDiapatchToProps的数据注入进去。<br>在componentDidMount中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，首先获取到context中的store，然后调用update方法来更新state。同样，在store.subscribe中传入store更新后的方法，当store更新后需要调用update方法。update方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...this.state.props,</span><br><span class=\"line\">      ...stateProps,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在update方法中，首先从context中获取到store，考虑需要connect的数据分为两部分，第一部分是将state中的数据映射到props中，调用connect的第一个参数mapStateToProps传入store.getState（），即传入全局的state。然后得到stateProps对象用于传入props中。然后通过this.setState来更新state，这里通过对象延展语法来对对象进行解构合并新旧state。</p>\n<p>上面只实现了state数据的映射，还需要方法的映射，数据的映射较为简单，而方法不能直接使用，因为需要对方法调用store.dispatch。这里需要在redux中实现一个bindActionCreators方法，按如下方式调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br></pre></td></tr></table></figure>\n<p>bindActionCreators用于将store.dispatch传递到函数内部，调用函数时能够在内部dispatch该函数。</p>\n<p>在src目录下的redux.js下，实现bindActionCreators方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreators</span>(<span class=\"params\">creators, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> bound = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(creators).forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> creator = creators[v];</span><br><span class=\"line\">    bound[v] = bindActionCreator(creator, dispatch);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在bindActionCreators方法中，传入connect的第二个参数mapDispatchToProps定义为creators，creators是一个对象，在这里需要对creators中的每一个方法使用dispatch进行一次包装，使用Object.keys返回对象可枚举属性组成的数组，然后循环数组，根据数组索引，依次取数组索引对应的方法，然后调用bindActionCreator返回一个由dispatch包装的新的方法，并且组装为一个新的对象bound返回，key保持不变。<br>下面实现bindActionCreator：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">creator, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(creator(...args))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在bindActionCreator方法中，使用高阶函数返回了一个新的函数，原函数creator经dispatch包装后，使用剩余参数…args透传到被包装函数内。这样是为了保证参数能够传递到最内层。<br>到这里，已经实现了connect的两个部分的数据，下面是完整的update方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...this.state.props,</span><br><span class=\"line\">      ...stateProps,</span><br><span class=\"line\">      ...dispatchProps,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终的update方法中，将stateProps和dispatchProps都更新到state.props中，这样，每次数据更新都能通知到子组件进行同步更新。<br>现在，react-redux的基本功能已经实现了，下面是完整的react-redux代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state =&gt; state, mapDispatchToProps=&#123;&#125;</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">      store: PropTypes.object</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        props: &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">      store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">          ...this.state.props,</span><br><span class=\"line\">          ...stateProps,</span><br><span class=\"line\">          ...dispatchProps,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrapComponent</span> &#123;<span class=\"attr\">...this.state.props</span>&#125;/&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextTypes = &#123;</span><br><span class=\"line\">    store: PropTypes.object</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">store</span>: <span class=\"keyword\">this</span>.store&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用react-redux来改写计数器应用\"><a href=\"#使用react-redux来改写计数器应用\" class=\"headerlink\" title=\"使用react-redux来改写计数器应用\"></a>使用react-redux来改写计数器应用</h3><p>在之前的文章中，使用自己编写的redux实现了一个简单的计数器应用，现在将它改写为react-redux实现：</p>\n<p><strong>App.js</strong>如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onIncrement, onDecrement, counter &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;counter&#125;</span><br><span class=\"line\">          onIncrement=&#123;onIncrement&#125;</span><br><span class=\"line\">          onDecrement=&#123;onDecrement&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: state</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onIncrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'INCREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onDecrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'DECREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapDispatchToProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure>\n<p>注意，由于在react-redux中connect中对mapDispatchToProps的处理仅考虑了其值为对象的情况，而实际可以支持对象或者函数作为参数，故在这里需要设置为对象的形式。</p>\n<p>index.js代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>最后，npm start运行项目，打开浏览器界面如下，对其进行操作，符合预期效果：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_191.png\" alt=\"image\"></p>"},{"title":"手摸手撸一个简单的Redux（四）","date":"2018-03-12T12:36:22.000Z","banner":"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg","_content":"\n> 理解Redux的原理有助于我们更好的使用它。本文实现redux的多个中间件合并功能。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n\n在上一篇文章中实现了redux的中间件机制，支持了传入一个中间件的用法，在实际的redux中，applyMiddleware是支持传入多个中间件的，本文使用redux实现多个中间件合并。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-6\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 中间件合并\n\n使用多个中间件的示例代码如下：\n\n\n``` js\nconst store = createStore(\n  reducer,\n  applyMiddleware(thunk, promise, logger)\n);\n```\n\n\n还是在原来的项目中进行开发，在src下redux.js中，对applyMiddleware函数进行修改。\n\n``` js\nexport function applyMiddleware(...middlewares) {\n}\n```\n单个中间件middleware的结构如下：\n\n``` js\nstore => next => action => {\n \n let result = next(action);\n \n return result;\n};\n```\n\n\n当传入多个middlewares参数时，将参数展开，middlewares成为一个数组方便后面操作。\n\n\n\n``` js\nexport function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    const store = createStore(...args);\n    let dispatch = store.dispatch;\n\n    const midApi = {\n      getState: store.getState(),\n      dispatch: (...args) => dispatch(...args)\n    }\n    const middlewareChain = middlewares.map(middleware => middleware(midApi));\n    dispatch = compose(...middlewareChain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n当有多个中间件时，对中间件数组middlewares执行map方法，对每个中间件都执行一次并传入midApi，返回成为一个新的数组middlewareChain。\nmiddlewareChain中保存着middleware执行一次后返回的函数[mid1, mid2, mid3],每个mid的结构如下：\n\n``` js\nnext => action => {\n \n let result = next(action);\n \n return result;\n};\n```\n\n然后，需要一个compose方法来对每个mid方法进行依次执行，并返回一个函数，最后传入store.dispatch参数。\ncompose方法作用如下：\n\n\n``` js\ncompose(fn1, fn2, fn3)\nfn1(fn2(fn3)))\n```\n\n\ncompose传入一系列函数作为参数，然后将一系列函数参数嵌套依次进行调用。\n下面是compose的实现：\n\n\n``` js\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  return funcs.reduce((ret, item) => (...args) => ret(item(...args)))\n}\n```\n\n\n在compose方法中，传入一系列函数参数，展开，funcs为一个数组。\n当funcs.length为0时，即一个参数都没有的时候，返回一个默认函数;当传入一个参数时，直接返回第一个参数;当传入多个函数参数时，使用数组的reduce方法依次对funcs数组从左到右执行一个函数，该函数中，ret为上一次执行该函数的返回值，如果没有指定初始值，第一次执行时为数组第一个参数，item为当前正在处理的数组元素。\n执行compose(fn1, fn2, fn3)，在reduce方法中的ret和item每次执行的结果如下：\n第一次执行，ret为fn1,item为fn2,返回fn1（fn2（））;\n第二次执行，ret为fn1（fn2（）），item为fn3,返回结果为fn1(fn2(fn3（）)))。\n\n到此，redux现在已经支持多个中间件的用法了。\n\n### 编写中间件进行测试\n为了测试多个中间件，这里我们再编写一个简单的中间件用于支持数组action，在src目录下新建redux.array.js。\n代码如下:\n\n``` js\nconst arrayThunk = ({dispatch, getState}) => next => action => {\n  if (Array.isArray(action)) {\n    action.forEach(v => dispatch(v))\n  }\n  return next(action)\n}\n\nexport default arrayThunk;\n```\n\n\n上述代码中，定义了arrayThunk中间件，使用Array.isArray方法判断action是否为数组，如果是数组就遍历action依次dispatch。\n下面在原来的计数器应用中，增加一个按钮，使用arrayThunk中间件点击每次加2。\n修改components/Counter.js如下：\n\n``` js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.incrementAsync = this.incrementAsync.bind(this);\n    this.incrementIfOdd = this.incrementIfOdd.bind(this);\n  }\n\n  incrementIfOdd() {\n    if (this.props.value % 2 !== 0) {\n      this.props.onIncrement();\n    }\n  }\n\n  incrementAsync() {\n    setTimeout(this.props.onIncrement, 1000);\n  }\n\n  render() {\n    const { value, onIncrement, onDecrement, incrementAsync, addTwice } = this.props;\n    console.log(this.props);\n    return (\n      <p>\n        Clicked: {value} times\n        {' '}\n        <button onClick={onIncrement}>\n          +\n        </button>\n        {' '}\n        <button onClick={onDecrement}>\n          -\n        </button>\n        {' '}\n        <button onClick={incrementAsync}>\n          Increment async\n        </button>\n        {' '}\n        <button onClick={addTwice}>\n          +2\n        </button>\n      </p>\n    )\n  }\n}\n\nCounter.propTypes = {\n  value: PropTypes.number.isRequired,\n  onIncrement: PropTypes.func.isRequired,\n  onDecrement: PropTypes.func.isRequired,\n  incrementAsync: PropTypes.func.isRequired,\n  addTwice: PropTypes.func.isRequired,\n};\n\nexport default Counter;\n```\n\n在Counter.js中，增加一个按钮，点击触发props中的addTwice方法。\n\n在src下，App.js中，修改代码如下：\n\n\n``` js\nimport React, { Component } from 'react';\nimport { connect } from './react-redux';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { onIncrement, onDecrement, counter, incrementAsync, addTwice } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={counter}\n          onIncrement={onIncrement}\n          onDecrement={onDecrement}\n          incrementAsync={incrementAsync}\n          addTwice={addTwice}\n        />\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  counter: state\n});\n\nfunction onIncrement() {\n  return { type: 'INCREMENT' }\n}\n\nfunction addTwice() {\n  return [{ type: 'INCREMENT' }, { type: 'INCREMENT' }]\n}\n\nfunction onDecrement() {\n  return { type: 'DECREMENT' }\n}\n\nfunction incrementAsync() {\n  return (dispatch, getState) => {\n    setTimeout(() => {\n      dispatch(onIncrement());\n    }, 2000)\n  }\n}\n\nconst mapDispatchToProps = {\n  onIncrement,\n  onDecrement,\n  incrementAsync,\n  addTwice,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n\n增加了addTwice方法，发起一个数组action，在数组中，定义了两个增加计数的action，并加入mapDispatch中，在App组件中，从props中获取到addwice方法并传入Counter组件。\n\n在index.js中，需要引入arrayThunk中间件。\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport thunk from './thunk';\nimport arrThunk from './redux-array';\nimport { Provider } from './react-redux';\nimport './index.css';\nimport App from './App';\nimport {applyMiddleware, createStore} from './redux';\n\nimport counter from './reducers';\n\n\nconst store = createStore(counter, applyMiddleware(thunk, arrThunk));\n\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n在index.js中，引入arrayThunk并传入applyMiddleware中。\n\nnpm start启动项目，打开浏览器进行操作，结果如下，达到预期效果。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_198.png)\n\n","source":"_posts/手摸手撸一个简单的Redux（四）.md","raw":"---\ntitle: 手摸手撸一个简单的Redux（四）\ndate: 2018-03-12 20:36:22\nbanner: http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\ntags:\n - Redux\n - React\n---\n\n> 理解Redux的原理有助于我们更好的使用它。本文实现redux的多个中间件合并功能。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n\n在上一篇文章中实现了redux的中间件机制，支持了传入一个中间件的用法，在实际的redux中，applyMiddleware是支持传入多个中间件的，本文使用redux实现多个中间件合并。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-6\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### 中间件合并\n\n使用多个中间件的示例代码如下：\n\n\n``` js\nconst store = createStore(\n  reducer,\n  applyMiddleware(thunk, promise, logger)\n);\n```\n\n\n还是在原来的项目中进行开发，在src下redux.js中，对applyMiddleware函数进行修改。\n\n``` js\nexport function applyMiddleware(...middlewares) {\n}\n```\n单个中间件middleware的结构如下：\n\n``` js\nstore => next => action => {\n \n let result = next(action);\n \n return result;\n};\n```\n\n\n当传入多个middlewares参数时，将参数展开，middlewares成为一个数组方便后面操作。\n\n\n\n``` js\nexport function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    const store = createStore(...args);\n    let dispatch = store.dispatch;\n\n    const midApi = {\n      getState: store.getState(),\n      dispatch: (...args) => dispatch(...args)\n    }\n    const middlewareChain = middlewares.map(middleware => middleware(midApi));\n    dispatch = compose(...middlewareChain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n当有多个中间件时，对中间件数组middlewares执行map方法，对每个中间件都执行一次并传入midApi，返回成为一个新的数组middlewareChain。\nmiddlewareChain中保存着middleware执行一次后返回的函数[mid1, mid2, mid3],每个mid的结构如下：\n\n``` js\nnext => action => {\n \n let result = next(action);\n \n return result;\n};\n```\n\n然后，需要一个compose方法来对每个mid方法进行依次执行，并返回一个函数，最后传入store.dispatch参数。\ncompose方法作用如下：\n\n\n``` js\ncompose(fn1, fn2, fn3)\nfn1(fn2(fn3)))\n```\n\n\ncompose传入一系列函数作为参数，然后将一系列函数参数嵌套依次进行调用。\n下面是compose的实现：\n\n\n``` js\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  return funcs.reduce((ret, item) => (...args) => ret(item(...args)))\n}\n```\n\n\n在compose方法中，传入一系列函数参数，展开，funcs为一个数组。\n当funcs.length为0时，即一个参数都没有的时候，返回一个默认函数;当传入一个参数时，直接返回第一个参数;当传入多个函数参数时，使用数组的reduce方法依次对funcs数组从左到右执行一个函数，该函数中，ret为上一次执行该函数的返回值，如果没有指定初始值，第一次执行时为数组第一个参数，item为当前正在处理的数组元素。\n执行compose(fn1, fn2, fn3)，在reduce方法中的ret和item每次执行的结果如下：\n第一次执行，ret为fn1,item为fn2,返回fn1（fn2（））;\n第二次执行，ret为fn1（fn2（）），item为fn3,返回结果为fn1(fn2(fn3（）)))。\n\n到此，redux现在已经支持多个中间件的用法了。\n\n### 编写中间件进行测试\n为了测试多个中间件，这里我们再编写一个简单的中间件用于支持数组action，在src目录下新建redux.array.js。\n代码如下:\n\n``` js\nconst arrayThunk = ({dispatch, getState}) => next => action => {\n  if (Array.isArray(action)) {\n    action.forEach(v => dispatch(v))\n  }\n  return next(action)\n}\n\nexport default arrayThunk;\n```\n\n\n上述代码中，定义了arrayThunk中间件，使用Array.isArray方法判断action是否为数组，如果是数组就遍历action依次dispatch。\n下面在原来的计数器应用中，增加一个按钮，使用arrayThunk中间件点击每次加2。\n修改components/Counter.js如下：\n\n``` js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.incrementAsync = this.incrementAsync.bind(this);\n    this.incrementIfOdd = this.incrementIfOdd.bind(this);\n  }\n\n  incrementIfOdd() {\n    if (this.props.value % 2 !== 0) {\n      this.props.onIncrement();\n    }\n  }\n\n  incrementAsync() {\n    setTimeout(this.props.onIncrement, 1000);\n  }\n\n  render() {\n    const { value, onIncrement, onDecrement, incrementAsync, addTwice } = this.props;\n    console.log(this.props);\n    return (\n      <p>\n        Clicked: {value} times\n        {' '}\n        <button onClick={onIncrement}>\n          +\n        </button>\n        {' '}\n        <button onClick={onDecrement}>\n          -\n        </button>\n        {' '}\n        <button onClick={incrementAsync}>\n          Increment async\n        </button>\n        {' '}\n        <button onClick={addTwice}>\n          +2\n        </button>\n      </p>\n    )\n  }\n}\n\nCounter.propTypes = {\n  value: PropTypes.number.isRequired,\n  onIncrement: PropTypes.func.isRequired,\n  onDecrement: PropTypes.func.isRequired,\n  incrementAsync: PropTypes.func.isRequired,\n  addTwice: PropTypes.func.isRequired,\n};\n\nexport default Counter;\n```\n\n在Counter.js中，增加一个按钮，点击触发props中的addTwice方法。\n\n在src下，App.js中，修改代码如下：\n\n\n``` js\nimport React, { Component } from 'react';\nimport { connect } from './react-redux';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { onIncrement, onDecrement, counter, incrementAsync, addTwice } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={counter}\n          onIncrement={onIncrement}\n          onDecrement={onDecrement}\n          incrementAsync={incrementAsync}\n          addTwice={addTwice}\n        />\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  counter: state\n});\n\nfunction onIncrement() {\n  return { type: 'INCREMENT' }\n}\n\nfunction addTwice() {\n  return [{ type: 'INCREMENT' }, { type: 'INCREMENT' }]\n}\n\nfunction onDecrement() {\n  return { type: 'DECREMENT' }\n}\n\nfunction incrementAsync() {\n  return (dispatch, getState) => {\n    setTimeout(() => {\n      dispatch(onIncrement());\n    }, 2000)\n  }\n}\n\nconst mapDispatchToProps = {\n  onIncrement,\n  onDecrement,\n  incrementAsync,\n  addTwice,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n\n增加了addTwice方法，发起一个数组action，在数组中，定义了两个增加计数的action，并加入mapDispatch中，在App组件中，从props中获取到addwice方法并传入Counter组件。\n\n在index.js中，需要引入arrayThunk中间件。\n\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport thunk from './thunk';\nimport arrThunk from './redux-array';\nimport { Provider } from './react-redux';\nimport './index.css';\nimport App from './App';\nimport {applyMiddleware, createStore} from './redux';\n\nimport counter from './reducers';\n\n\nconst store = createStore(counter, applyMiddleware(thunk, arrThunk));\n\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n在index.js中，引入arrayThunk并传入applyMiddleware中。\n\nnpm start启动项目，打开浏览器进行操作，结果如下，达到预期效果。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_198.png)\n\n","slug":"手摸手撸一个简单的Redux（四）","published":1,"updated":"2020-07-16T13:56:47.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pceno5001lp70vokye770c","content":"<blockquote>\n<p>理解Redux的原理有助于我们更好的使用它。本文实现redux的多个中间件合并功能。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>在上一篇文章中实现了redux的中间件机制，支持了传入一个中间件的用法，在实际的redux中，applyMiddleware是支持传入多个中间件的，本文使用redux实现多个中间件合并。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-6</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"中间件合并\"><a href=\"#中间件合并\" class=\"headerlink\" title=\"中间件合并\"></a>中间件合并</h3><p>使用多个中间件的示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(</span><br><span class=\"line\">  reducer,</span><br><span class=\"line\">  applyMiddleware(thunk, promise, logger)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>还是在原来的项目中进行开发，在src下redux.js中，对applyMiddleware函数进行修改。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>单个中间件middleware的结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">store =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当传入多个middlewares参数时，将参数展开，middlewares成为一个数组方便后面操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = store.dispatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> midApi = &#123;</span><br><span class=\"line\">      getState: store.getState(),</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> middlewareChain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(midApi));</span><br><span class=\"line\">    dispatch = compose(...middlewareChain)(store.dispatch);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当有多个中间件时，对中间件数组middlewares执行map方法，对每个中间件都执行一次并传入midApi，返回成为一个新的数组middlewareChain。<br>middlewareChain中保存着middleware执行一次后返回的函数[mid1, mid2, mid3],每个mid的结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后，需要一个compose方法来对每个mid方法进行依次执行，并返回一个函数，最后传入store.dispatch参数。<br>compose方法作用如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">compose(fn1, fn2, fn3)</span><br><span class=\"line\">fn1(fn2(fn3)))</span><br></pre></td></tr></table></figure>\n<p>compose传入一系列函数作为参数，然后将一系列函数参数嵌套依次进行调用。<br>下面是compose的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">ret, item</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在compose方法中，传入一系列函数参数，展开，funcs为一个数组。<br>当funcs.length为0时，即一个参数都没有的时候，返回一个默认函数;当传入一个参数时，直接返回第一个参数;当传入多个函数参数时，使用数组的reduce方法依次对funcs数组从左到右执行一个函数，该函数中，ret为上一次执行该函数的返回值，如果没有指定初始值，第一次执行时为数组第一个参数，item为当前正在处理的数组元素。<br>执行compose(fn1, fn2, fn3)，在reduce方法中的ret和item每次执行的结果如下：<br>第一次执行，ret为fn1,item为fn2,返回fn1（fn2（））;<br>第二次执行，ret为fn1（fn2（）），item为fn3,返回结果为fn1(fn2(fn3（）)))。</p>\n<p>到此，redux现在已经支持多个中间件的用法了。</p>\n<h3 id=\"编写中间件进行测试\"><a href=\"#编写中间件进行测试\" class=\"headerlink\" title=\"编写中间件进行测试\"></a>编写中间件进行测试</h3><p>为了测试多个中间件，这里我们再编写一个简单的中间件用于支持数组action，在src目录下新建redux.array.js。<br>代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayThunk = <span class=\"function\">(<span class=\"params\">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(action)) &#123;</span><br><span class=\"line\">    action.forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> dispatch(v))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> arrayThunk;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，定义了arrayThunk中间件，使用Array.isArray方法判断action是否为数组，如果是数组就遍历action依次dispatch。<br>下面在原来的计数器应用中，增加一个按钮，使用arrayThunk中间件点击每次加2。<br>修改components/Counter.js如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementAsync = <span class=\"keyword\">this</span>.incrementAsync.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementIfOdd = <span class=\"keyword\">this</span>.incrementIfOdd.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  incrementIfOdd() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.value % <span class=\"number\">2</span> !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.onIncrement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  incrementAsync() &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"keyword\">this</span>.props.onIncrement, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrement, onDecrement, incrementAsync, addTwice &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;value&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrement&#125;&gt;</span><br><span class=\"line\">          +</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;onDecrement&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          -</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;incrementAsync&#125;&gt;</span><br><span class=\"line\">          Increment <span class=\"keyword\">async</span></span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;addTwice&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          +2</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Counter.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  value: PropTypes.number.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  addTwice: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Counter;</span></span><br></pre></td></tr></table></figure>\n<p>在Counter.js中，增加一个按钮，点击触发props中的addTwice方法。</p>\n<p>在src下，App.js中，修改代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onIncrement, onDecrement, counter, incrementAsync, addTwice &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;counter&#125;</span><br><span class=\"line\">          onIncrement=&#123;onIncrement&#125;</span><br><span class=\"line\">          onDecrement=&#123;onDecrement&#125;</span><br><span class=\"line\">          incrementAsync=&#123;incrementAsync&#125;</span><br><span class=\"line\">          addTwice=&#123;addTwice&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: state</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onIncrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'INCREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function addTwice() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return [&#123; type: 'INCREMENT' &#125;, &#123; type: 'INCREMENT' &#125;]</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onDecrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'DECREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function incrementAsync() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (dispatch, getState) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      dispatch(onIncrement());</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;, 2000)</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapDispatchToProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync,</span></span><br><span class=\"line\"><span class=\"regexp\">  addTwice,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure>\n<p>增加了addTwice方法，发起一个数组action，在数组中，定义了两个增加计数的action，并加入mapDispatch中，在App组件中，从props中获取到addwice方法并传入Counter组件。</p>\n<p>在index.js中，需要引入arrayThunk中间件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'./thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> arrThunk <span class=\"keyword\">from</span> <span class=\"string\">'./redux-array'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;applyMiddleware, createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter, applyMiddleware(thunk, arrThunk));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>在index.js中，引入arrayThunk并传入applyMiddleware中。</p>\n<p>npm start启动项目，打开浏览器进行操作，结果如下，达到预期效果。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_198.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>理解Redux的原理有助于我们更好的使用它。本文实现redux的多个中间件合并功能。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>","more":"<p>在上一篇文章中实现了redux的中间件机制，支持了传入一个中间件的用法，在实际的redux中，applyMiddleware是支持传入多个中间件的，本文使用redux实现多个中间件合并。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-6</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"中间件合并\"><a href=\"#中间件合并\" class=\"headerlink\" title=\"中间件合并\"></a>中间件合并</h3><p>使用多个中间件的示例代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(</span><br><span class=\"line\">  reducer,</span><br><span class=\"line\">  applyMiddleware(thunk, promise, logger)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>还是在原来的项目中进行开发，在src下redux.js中，对applyMiddleware函数进行修改。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>单个中间件middleware的结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">store =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当传入多个middlewares参数时，将参数展开，middlewares成为一个数组方便后面操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = store.dispatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> midApi = &#123;</span><br><span class=\"line\">      getState: store.getState(),</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> middlewareChain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(midApi));</span><br><span class=\"line\">    dispatch = compose(...middlewareChain)(store.dispatch);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当有多个中间件时，对中间件数组middlewares执行map方法，对每个中间件都执行一次并传入midApi，返回成为一个新的数组middlewareChain。<br>middlewareChain中保存着middleware执行一次后返回的函数[mid1, mid2, mid3],每个mid的结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后，需要一个compose方法来对每个mid方法进行依次执行，并返回一个函数，最后传入store.dispatch参数。<br>compose方法作用如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">compose(fn1, fn2, fn3)</span><br><span class=\"line\">fn1(fn2(fn3)))</span><br></pre></td></tr></table></figure>\n<p>compose传入一系列函数作为参数，然后将一系列函数参数嵌套依次进行调用。<br>下面是compose的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">ret, item</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在compose方法中，传入一系列函数参数，展开，funcs为一个数组。<br>当funcs.length为0时，即一个参数都没有的时候，返回一个默认函数;当传入一个参数时，直接返回第一个参数;当传入多个函数参数时，使用数组的reduce方法依次对funcs数组从左到右执行一个函数，该函数中，ret为上一次执行该函数的返回值，如果没有指定初始值，第一次执行时为数组第一个参数，item为当前正在处理的数组元素。<br>执行compose(fn1, fn2, fn3)，在reduce方法中的ret和item每次执行的结果如下：<br>第一次执行，ret为fn1,item为fn2,返回fn1（fn2（））;<br>第二次执行，ret为fn1（fn2（）），item为fn3,返回结果为fn1(fn2(fn3（）)))。</p>\n<p>到此，redux现在已经支持多个中间件的用法了。</p>\n<h3 id=\"编写中间件进行测试\"><a href=\"#编写中间件进行测试\" class=\"headerlink\" title=\"编写中间件进行测试\"></a>编写中间件进行测试</h3><p>为了测试多个中间件，这里我们再编写一个简单的中间件用于支持数组action，在src目录下新建redux.array.js。<br>代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayThunk = <span class=\"function\">(<span class=\"params\">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(action)) &#123;</span><br><span class=\"line\">    action.forEach(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> dispatch(v))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> arrayThunk;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，定义了arrayThunk中间件，使用Array.isArray方法判断action是否为数组，如果是数组就遍历action依次dispatch。<br>下面在原来的计数器应用中，增加一个按钮，使用arrayThunk中间件点击每次加2。<br>修改components/Counter.js如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementAsync = <span class=\"keyword\">this</span>.incrementAsync.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.incrementIfOdd = <span class=\"keyword\">this</span>.incrementIfOdd.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  incrementIfOdd() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.value % <span class=\"number\">2</span> !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.onIncrement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  incrementAsync() &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"keyword\">this</span>.props.onIncrement, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrement, onDecrement, incrementAsync, addTwice &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;value&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrement&#125;&gt;</span><br><span class=\"line\">          +</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;onDecrement&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          -</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;incrementAsync&#125;&gt;</span><br><span class=\"line\">          Increment <span class=\"keyword\">async</span></span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;addTwice&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          +2</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Counter.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  value: PropTypes.number.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  addTwice: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Counter;</span></span><br></pre></td></tr></table></figure>\n<p>在Counter.js中，增加一个按钮，点击触发props中的addTwice方法。</p>\n<p>在src下，App.js中，修改代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onIncrement, onDecrement, counter, incrementAsync, addTwice &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;counter&#125;</span><br><span class=\"line\">          onIncrement=&#123;onIncrement&#125;</span><br><span class=\"line\">          onDecrement=&#123;onDecrement&#125;</span><br><span class=\"line\">          incrementAsync=&#123;incrementAsync&#125;</span><br><span class=\"line\">          addTwice=&#123;addTwice&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: state</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onIncrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'INCREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function addTwice() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return [&#123; type: 'INCREMENT' &#125;, &#123; type: 'INCREMENT' &#125;]</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onDecrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'DECREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function incrementAsync() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (dispatch, getState) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      dispatch(onIncrement());</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;, 2000)</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapDispatchToProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync,</span></span><br><span class=\"line\"><span class=\"regexp\">  addTwice,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure>\n<p>增加了addTwice方法，发起一个数组action，在数组中，定义了两个增加计数的action，并加入mapDispatch中，在App组件中，从props中获取到addwice方法并传入Counter组件。</p>\n<p>在index.js中，需要引入arrayThunk中间件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'./thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> arrThunk <span class=\"keyword\">from</span> <span class=\"string\">'./redux-array'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;applyMiddleware, createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter, applyMiddleware(thunk, arrThunk));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>在index.js中，引入arrayThunk并传入applyMiddleware中。</p>\n<p>npm start启动项目，打开浏览器进行操作，结果如下，达到预期效果。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_198.png\" alt=\"image\"></p>"},{"title":"手摸手撸一个简单的Redux（三）","date":"2018-03-08T02:36:15.000Z","banner":"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg","_content":"\n> It provides a third-party extension point between dispatching an\naction, and the moment it reaches the reducer. ---中间件\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-5\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n\n当我们的业务需求变得更为复杂的时候，单纯的在dispatch和reducer中处理业务逻辑已经不具有普遍性。我们需要的是可以组合的，自由插拔的插件机制，redux借鉴koa的中间件思想，实现了redux的middleware。在发出action和执行reducer之间，使用中间件函数对store.dispatch进行改造，所以，redux的middleware是为了增强dispatch而生的。\n\n回顾中间件的使用方法，这里以，redux-thunk中间件为例，为之前的计数器添加一个延迟计数的功能，即点击按钮两秒后进行加1操作，redux和react-redux使用官方实现的，下面是改造后的代码：\n首先是计数器组件，src下components目录下，Counter.js中，代码如下：\n\n``` js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n\n  }\n\n\n  render() {\n    const { value, onIncrement, onDecrement, incrementAsync } = this.props;\n    console.log(this.props);\n    return (\n        <p>\n        Clicked: {value} times\n        {' '}\n        <button onClick={onIncrement}>\n        +\n        </button>\n        {' '}\n        <button onClick={onDecrement}>\n        -\n        </button>\n        {' '}\n        <button onClick={incrementAsync}>\n        Increment async\n        </button>\n        </p>\n    )\n  }\n}\n\n\n\nCounter.propTypes = {\n    value: PropTypes.number.isRequired,\n    onIncrement: PropTypes.func.isRequired,\n    onDecrement: PropTypes.func.isRequired,\n    incrementAsync: PropTypes.func.isRequired\n};\n\nexport default Counter;\n\n```\n\n上述代码中，添加了用于异步加1的按钮，点击触发props中的incrementAsync方法。\n下面是src下App.js的代码：\n\n\n``` js\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { onIncrement, onDecrement, counter, incrementAsync } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={counter}\n          onIncrement={onIncrement}\n          onDecrement={onDecrement}\n          incrementAsync={incrementAsync}\n        />\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  counter: state\n});\n\nfunction onIncrement() {\n  return { type: 'INCREMENT' }\n}\n\nfunction onDecrement() {\n  return { type: 'DECREMENT' }\n}\n\nfunction incrementAsync() {\n  return dispatch => {\n    setTimeout(() => {\n      dispatch(onIncrement());\n    }, 2000)\n  }\n}\n\nconst mapDispatchToProps = {\n  onIncrement,\n  onDecrement,\n  incrementAsync\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n\n相比上一篇文章，主要定义了incrementAsync方法，然后添加到mapDispatch中，在incrementSync中，返回一个函数，在函数内部执行异步操作发起action，普通的action都是一个对象的形式，但是异步的action返回的是一个function，处理这种情况就需要使用redux的中间件：redux-thunk。\n下面是src下index.js的代码：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport thunk from 'redux-thunk';\nimport { Provider } from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport {applyMiddleware, createStore} from 'redux';\nimport counter from './reducers';\n\nconst store = createStore(counter, applyMiddleware(thunk));\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n\n在index.js中，引入react-thunk模块，然后在createStore中传入第二个参数，使用redux的API applymiddleware对chunk中间件进行包裹。\n上述就是改进后的计数器，运行项目在浏览器预览下，点击incrementAsync按钮，达到预期效果。如下图：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_195.png)\n\n### applyMiddleware实现\n\napplyMiddleware是redux提供的用于使用中间件的API，回顾applyMiddleware的使用：\n\n``` js\nconst store = createStore(counter, applyMiddleware(logger, thunk));\n```\napplyMiddleware接收多个中间件参数，返回值作为第二个参数传入createStore。\n\n在src下redux.js文件中，首先让原来的createStore支持传入第二个参数，代码如下：\n\n``` js\nexport function createStore(reducer, enhancer) {\n  if (enhancer) {\n    return enhancer(createStore)(reducer);\n  }\n}\n```\n\n在createStore中传入第二个参数enhancer，enhancer即调用applyMiddleware包装中间件的函数，然后判断enhancer是否存在，存在即调用enhancer传入createStore和reducer两个参数，由此，applyMiddleware应该是一个高阶函数，返回一个新的函数。\n下面暴露applyMiddleware方法。redux的middleware是支持多个中间件的，此处先实现支持一个中间件的用法。\n\n``` js\nexport function applyMiddleware(middleware) {\n  return createStore => (...args) => {\n    const store = createStore(...args);\n    let dispatch = store.dispatch;\n\n    const midApi = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n    dispatch = middleware(midApi)(store.dispatch)\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\napplyMiddleware的结构是一个多层柯里化的函数，第一层函数执行后返回一个函数，这个函数即createStore函数中的参数enhancer，然后这个函数传入createStore参数，再返回一个函数，这个函数传入reducer参数，使用...args进行解构，在函数内部，首先调用createStore获取到原始的store以及dispatch，然后封装一个对象midApi传入中间件内部，midApi包括两个方法getState和dispatch，getState对应store.getState方法，dispatch对应store.dispatch方法并透传参数。下面是一个日志中间件的代码：\n\n``` js\nconst logger = store => next => action => {\n console.log('dispatching', action);\n let result = next(action);\n console.log('next state', store.getState());\n return result;\n};\n```\n\n\n由此可见，中间件函数是一个层层包裹的匿名函数，第一层传入store，第二层传入next下一个中间件，此处指store.dispatch，第三层是在组件中进行调用时，传入action。logger中间件在applyMiddleware中被层层调用，动态的对store和next参数赋值。\n\n接着看上面applyMiddleware的代码，定义了一个由getState和dispatch组成的闭包midApi，中间件函数middleware第一次调用传入midApi返回一个匿名函数，如下：\n``` js\nnext => action => {\n console.log('dispatching', action);\n let result = next(action);\n console.log('next state', store.getState());\n return result;\n};\n```\n紧接着对匿名函数再次调用，传入store.dispatch作为参数next，再次返回一个匿名函数，如下：\n``` js\naction => {\n console.log('dispatching', action);\n let result = next(action);\n console.log('next state', store.getState());\n return result;\n};\n```\n通过对middleware的层层调用来生成一个新的dispatch方法，新的dispatch\n对store原有的dispatch方法进行了增强，最后返回一个对象，使用解构赋值将增强的dispatch覆盖原有的store.dispatch，成为一个新的store。最终，在组件中发起dispatch的时候使用的就是新的dispatch方法。\n\n到这里，已经让redux支持中间件的用法了，现在来使用一下，还是使用上面项目中的计数器案例，将redux和react-redux替换为自己编写的文件，redux-thunk不变，运行项目，依次点击三个按钮，达到预期效果。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_196.png)\n\n### 编写redux-thunk中间件\n上面已经让我们的redux支持使用中间件，下面来尝试自己编写一个thunk中间件。在src下新建thunk.js：\n\n``` js\nconst thunk = ({dispatch, getState}) => next => action => {\n\n  return next(action)\n}\n\nexport default thunk;\n```\n\n一个中间件的结构如上，一个三层箭头函数，第一个参数传入midApi，这里解构出dispatch和getState方法方便使用，第二个参数传入下一个中间件，即store.dispatch，第三个参数传入需要提交的action。在中间件函数中，如果什么都不做，直接返回next（action），即直接dispatch action。当然，这样做并没有什么用，下面为它加上thunk的代码：\n\n``` js\nconst thunk = ({dispatch, getState}) => next => action => {\n  // 如果是函数，执行一下\n  if (typeof action === 'function') {\n    return action(dispatch, getState);\n  }\n  return next(action)\n}\n\nexport default thunk;\n```\n\n这就是redux-thunk的代码，很简单吧，首先判断传入的action是否为fuction，如果是function就执行该action，并传入dispatch和getState， 如下，在incrementAsync的返回函数的参数中，可以接受dispatch和getState两个参数：\n\n``` js\nfunction incrementAsync() {\n  return (dispatch, getState) => {\n    setTimeout(() => {\n      dispatch(onIncrement());\n    }, 2000)\n  }\n}\n```\n\n下面来验证一下实现的thunk中间件，在src下替换redux-thunk为./thunk。在浏览器依次点击三个按钮，结果如下，达到预期效果。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_197.png)","source":"_posts/手摸手撸一个简单的Redux（三）.md","raw":"---\ntitle: 手摸手撸一个简单的Redux（三）\ndate: 2018-03-8 10:36:15\nbanner: http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\ntags:\n - Redux\n - React\n---\n\n> It provides a third-party extension point between dispatching an\naction, and the moment it reaches the reducer. ---中间件\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-5\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n\n当我们的业务需求变得更为复杂的时候，单纯的在dispatch和reducer中处理业务逻辑已经不具有普遍性。我们需要的是可以组合的，自由插拔的插件机制，redux借鉴koa的中间件思想，实现了redux的middleware。在发出action和执行reducer之间，使用中间件函数对store.dispatch进行改造，所以，redux的middleware是为了增强dispatch而生的。\n\n回顾中间件的使用方法，这里以，redux-thunk中间件为例，为之前的计数器添加一个延迟计数的功能，即点击按钮两秒后进行加1操作，redux和react-redux使用官方实现的，下面是改造后的代码：\n首先是计数器组件，src下components目录下，Counter.js中，代码如下：\n\n``` js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n\n  }\n\n\n  render() {\n    const { value, onIncrement, onDecrement, incrementAsync } = this.props;\n    console.log(this.props);\n    return (\n        <p>\n        Clicked: {value} times\n        {' '}\n        <button onClick={onIncrement}>\n        +\n        </button>\n        {' '}\n        <button onClick={onDecrement}>\n        -\n        </button>\n        {' '}\n        <button onClick={incrementAsync}>\n        Increment async\n        </button>\n        </p>\n    )\n  }\n}\n\n\n\nCounter.propTypes = {\n    value: PropTypes.number.isRequired,\n    onIncrement: PropTypes.func.isRequired,\n    onDecrement: PropTypes.func.isRequired,\n    incrementAsync: PropTypes.func.isRequired\n};\n\nexport default Counter;\n\n```\n\n上述代码中，添加了用于异步加1的按钮，点击触发props中的incrementAsync方法。\n下面是src下App.js的代码：\n\n\n``` js\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport Counter from './components/Counter';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const { onIncrement, onDecrement, counter, incrementAsync } = this.props;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h1 className=\"App-title\">Welcome to React</h1>\n        </header>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n        <Counter\n          value={counter}\n          onIncrement={onIncrement}\n          onDecrement={onDecrement}\n          incrementAsync={incrementAsync}\n        />\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  counter: state\n});\n\nfunction onIncrement() {\n  return { type: 'INCREMENT' }\n}\n\nfunction onDecrement() {\n  return { type: 'DECREMENT' }\n}\n\nfunction incrementAsync() {\n  return dispatch => {\n    setTimeout(() => {\n      dispatch(onIncrement());\n    }, 2000)\n  }\n}\n\nconst mapDispatchToProps = {\n  onIncrement,\n  onDecrement,\n  incrementAsync\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n\n相比上一篇文章，主要定义了incrementAsync方法，然后添加到mapDispatch中，在incrementSync中，返回一个函数，在函数内部执行异步操作发起action，普通的action都是一个对象的形式，但是异步的action返回的是一个function，处理这种情况就需要使用redux的中间件：redux-thunk。\n下面是src下index.js的代码：\n\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport thunk from 'redux-thunk';\nimport { Provider } from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport {applyMiddleware, createStore} from 'redux';\nimport counter from './reducers';\n\nconst store = createStore(counter, applyMiddleware(thunk));\n\nReactDOM.render(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n\n在index.js中，引入react-thunk模块，然后在createStore中传入第二个参数，使用redux的API applymiddleware对chunk中间件进行包裹。\n上述就是改进后的计数器，运行项目在浏览器预览下，点击incrementAsync按钮，达到预期效果。如下图：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_195.png)\n\n### applyMiddleware实现\n\napplyMiddleware是redux提供的用于使用中间件的API，回顾applyMiddleware的使用：\n\n``` js\nconst store = createStore(counter, applyMiddleware(logger, thunk));\n```\napplyMiddleware接收多个中间件参数，返回值作为第二个参数传入createStore。\n\n在src下redux.js文件中，首先让原来的createStore支持传入第二个参数，代码如下：\n\n``` js\nexport function createStore(reducer, enhancer) {\n  if (enhancer) {\n    return enhancer(createStore)(reducer);\n  }\n}\n```\n\n在createStore中传入第二个参数enhancer，enhancer即调用applyMiddleware包装中间件的函数，然后判断enhancer是否存在，存在即调用enhancer传入createStore和reducer两个参数，由此，applyMiddleware应该是一个高阶函数，返回一个新的函数。\n下面暴露applyMiddleware方法。redux的middleware是支持多个中间件的，此处先实现支持一个中间件的用法。\n\n``` js\nexport function applyMiddleware(middleware) {\n  return createStore => (...args) => {\n    const store = createStore(...args);\n    let dispatch = store.dispatch;\n\n    const midApi = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n    dispatch = middleware(midApi)(store.dispatch)\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\napplyMiddleware的结构是一个多层柯里化的函数，第一层函数执行后返回一个函数，这个函数即createStore函数中的参数enhancer，然后这个函数传入createStore参数，再返回一个函数，这个函数传入reducer参数，使用...args进行解构，在函数内部，首先调用createStore获取到原始的store以及dispatch，然后封装一个对象midApi传入中间件内部，midApi包括两个方法getState和dispatch，getState对应store.getState方法，dispatch对应store.dispatch方法并透传参数。下面是一个日志中间件的代码：\n\n``` js\nconst logger = store => next => action => {\n console.log('dispatching', action);\n let result = next(action);\n console.log('next state', store.getState());\n return result;\n};\n```\n\n\n由此可见，中间件函数是一个层层包裹的匿名函数，第一层传入store，第二层传入next下一个中间件，此处指store.dispatch，第三层是在组件中进行调用时，传入action。logger中间件在applyMiddleware中被层层调用，动态的对store和next参数赋值。\n\n接着看上面applyMiddleware的代码，定义了一个由getState和dispatch组成的闭包midApi，中间件函数middleware第一次调用传入midApi返回一个匿名函数，如下：\n``` js\nnext => action => {\n console.log('dispatching', action);\n let result = next(action);\n console.log('next state', store.getState());\n return result;\n};\n```\n紧接着对匿名函数再次调用，传入store.dispatch作为参数next，再次返回一个匿名函数，如下：\n``` js\naction => {\n console.log('dispatching', action);\n let result = next(action);\n console.log('next state', store.getState());\n return result;\n};\n```\n通过对middleware的层层调用来生成一个新的dispatch方法，新的dispatch\n对store原有的dispatch方法进行了增强，最后返回一个对象，使用解构赋值将增强的dispatch覆盖原有的store.dispatch，成为一个新的store。最终，在组件中发起dispatch的时候使用的就是新的dispatch方法。\n\n到这里，已经让redux支持中间件的用法了，现在来使用一下，还是使用上面项目中的计数器案例，将redux和react-redux替换为自己编写的文件，redux-thunk不变，运行项目，依次点击三个按钮，达到预期效果。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_196.png)\n\n### 编写redux-thunk中间件\n上面已经让我们的redux支持使用中间件，下面来尝试自己编写一个thunk中间件。在src下新建thunk.js：\n\n``` js\nconst thunk = ({dispatch, getState}) => next => action => {\n\n  return next(action)\n}\n\nexport default thunk;\n```\n\n一个中间件的结构如上，一个三层箭头函数，第一个参数传入midApi，这里解构出dispatch和getState方法方便使用，第二个参数传入下一个中间件，即store.dispatch，第三个参数传入需要提交的action。在中间件函数中，如果什么都不做，直接返回next（action），即直接dispatch action。当然，这样做并没有什么用，下面为它加上thunk的代码：\n\n``` js\nconst thunk = ({dispatch, getState}) => next => action => {\n  // 如果是函数，执行一下\n  if (typeof action === 'function') {\n    return action(dispatch, getState);\n  }\n  return next(action)\n}\n\nexport default thunk;\n```\n\n这就是redux-thunk的代码，很简单吧，首先判断传入的action是否为fuction，如果是function就执行该action，并传入dispatch和getState， 如下，在incrementAsync的返回函数的参数中，可以接受dispatch和getState两个参数：\n\n``` js\nfunction incrementAsync() {\n  return (dispatch, getState) => {\n    setTimeout(() => {\n      dispatch(onIncrement());\n    }, 2000)\n  }\n}\n```\n\n下面来验证一下实现的thunk中间件，在src下替换redux-thunk为./thunk。在浏览器依次点击三个按钮，结果如下，达到预期效果。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_197.png)","slug":"手摸手撸一个简单的Redux（三）","published":1,"updated":"2020-07-16T13:56:47.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pceno6001op70vu7loukna","content":"<blockquote>\n<p>It provides a third-party extension point between dispatching an<br>action, and the moment it reaches the reducer. —中间件</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-5</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>当我们的业务需求变得更为复杂的时候，单纯的在dispatch和reducer中处理业务逻辑已经不具有普遍性。我们需要的是可以组合的，自由插拔的插件机制，redux借鉴koa的中间件思想，实现了redux的middleware。在发出action和执行reducer之间，使用中间件函数对store.dispatch进行改造，所以，redux的middleware是为了增强dispatch而生的。</p>\n<p>回顾中间件的使用方法，这里以，redux-thunk中间件为例，为之前的计数器添加一个延迟计数的功能，即点击按钮两秒后进行加1操作，redux和react-redux使用官方实现的，下面是改造后的代码：<br>首先是计数器组件，src下components目录下，Counter.js中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrement, onDecrement, incrementAsync &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;value&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrement&#125;&gt;</span><br><span class=\"line\">        +</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;onDecrement&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        -</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;incrementAsync&#125;&gt;</span><br><span class=\"line\">        Increment <span class=\"keyword\">async</span></span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>p&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Counter.propTypes = &#123;</span><br><span class=\"line\">    value: PropTypes.number.isRequired,</span><br><span class=\"line\">    onIncrement: PropTypes.func.isRequired,</span><br><span class=\"line\">    onDecrement: PropTypes.func.isRequired,</span><br><span class=\"line\">    incrementAsync: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Counter;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，添加了用于异步加1的按钮，点击触发props中的incrementAsync方法。<br>下面是src下App.js的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onIncrement, onDecrement, counter, incrementAsync &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;counter&#125;</span><br><span class=\"line\">          onIncrement=&#123;onIncrement&#125;</span><br><span class=\"line\">          onDecrement=&#123;onDecrement&#125;</span><br><span class=\"line\">          incrementAsync=&#123;incrementAsync&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: state</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onIncrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'INCREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onDecrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'DECREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function incrementAsync() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return dispatch =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      dispatch(onIncrement());</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;, 2000)</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapDispatchToProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure>\n<p>相比上一篇文章，主要定义了incrementAsync方法，然后添加到mapDispatch中，在incrementSync中，返回一个函数，在函数内部执行异步操作发起action，普通的action都是一个对象的形式，但是异步的action返回的是一个function，处理这种情况就需要使用redux的中间件：redux-thunk。<br>下面是src下index.js的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;applyMiddleware, createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter, applyMiddleware(thunk));</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>在index.js中，引入react-thunk模块，然后在createStore中传入第二个参数，使用redux的API applymiddleware对chunk中间件进行包裹。<br>上述就是改进后的计数器，运行项目在浏览器预览下，点击incrementAsync按钮，达到预期效果。如下图：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_195.png\" alt=\"image\"></p>\n<h3 id=\"applyMiddleware实现\"><a href=\"#applyMiddleware实现\" class=\"headerlink\" title=\"applyMiddleware实现\"></a>applyMiddleware实现</h3><p>applyMiddleware是redux提供的用于使用中间件的API，回顾applyMiddleware的使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter, applyMiddleware(logger, thunk));</span><br></pre></td></tr></table></figure>\n<p>applyMiddleware接收多个中间件参数，返回值作为第二个参数传入createStore。</p>\n<p>在src下redux.js文件中，首先让原来的createStore支持传入第二个参数，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, enhancer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enhancer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在createStore中传入第二个参数enhancer，enhancer即调用applyMiddleware包装中间件的函数，然后判断enhancer是否存在，存在即调用enhancer传入createStore和reducer两个参数，由此，applyMiddleware应该是一个高阶函数，返回一个新的函数。<br>下面暴露applyMiddleware方法。redux的middleware是支持多个中间件的，此处先实现支持一个中间件的用法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">middleware</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = store.dispatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> midApi = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dispatch = middleware(midApi)(store.dispatch)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>applyMiddleware的结构是一个多层柯里化的函数，第一层函数执行后返回一个函数，这个函数即createStore函数中的参数enhancer，然后这个函数传入createStore参数，再返回一个函数，这个函数传入reducer参数，使用…args进行解构，在函数内部，首先调用createStore获取到原始的store以及dispatch，然后封装一个对象midApi传入中间件内部，midApi包括两个方法getState和dispatch，getState对应store.getState方法，dispatch对应store.dispatch方法并透传参数。下面是一个日志中间件的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'dispatching'</span>, action);</span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState());</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可见，中间件函数是一个层层包裹的匿名函数，第一层传入store，第二层传入next下一个中间件，此处指store.dispatch，第三层是在组件中进行调用时，传入action。logger中间件在applyMiddleware中被层层调用，动态的对store和next参数赋值。</p>\n<p>接着看上面applyMiddleware的代码，定义了一个由getState和dispatch组成的闭包midApi，中间件函数middleware第一次调用传入midApi返回一个匿名函数，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'dispatching'</span>, action);</span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState());</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>紧接着对匿名函数再次调用，传入store.dispatch作为参数next，再次返回一个匿名函数，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">action =&gt; &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'dispatching'</span>, action);</span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState());</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过对middleware的层层调用来生成一个新的dispatch方法，新的dispatch<br>对store原有的dispatch方法进行了增强，最后返回一个对象，使用解构赋值将增强的dispatch覆盖原有的store.dispatch，成为一个新的store。最终，在组件中发起dispatch的时候使用的就是新的dispatch方法。</p>\n<p>到这里，已经让redux支持中间件的用法了，现在来使用一下，还是使用上面项目中的计数器案例，将redux和react-redux替换为自己编写的文件，redux-thunk不变，运行项目，依次点击三个按钮，达到预期效果。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_196.png\" alt=\"image\"></p>\n<h3 id=\"编写redux-thunk中间件\"><a href=\"#编写redux-thunk中间件\" class=\"headerlink\" title=\"编写redux-thunk中间件\"></a>编写redux-thunk中间件</h3><p>上面已经让我们的redux支持使用中间件，下面来尝试自己编写一个thunk中间件。在src下新建thunk.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thunk = <span class=\"function\">(<span class=\"params\">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n<p>一个中间件的结构如上，一个三层箭头函数，第一个参数传入midApi，这里解构出dispatch和getState方法方便使用，第二个参数传入下一个中间件，即store.dispatch，第三个参数传入需要提交的action。在中间件函数中，如果什么都不做，直接返回next（action），即直接dispatch action。当然，这样做并没有什么用，下面为它加上thunk的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thunk = <span class=\"function\">(<span class=\"params\">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是函数，执行一下</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action(dispatch, getState);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n<p>这就是redux-thunk的代码，很简单吧，首先判断传入的action是否为fuction，如果是function就执行该action，并传入dispatch和getState， 如下，在incrementAsync的返回函数的参数中，可以接受dispatch和getState两个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(onIncrement());</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面来验证一下实现的thunk中间件，在src下替换redux-thunk为./thunk。在浏览器依次点击三个按钮，结果如下，达到预期效果。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_197.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>It provides a third-party extension point between dispatching an<br>action, and the moment it reaches the reducer. —中间件</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>","more":"<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-5</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>当我们的业务需求变得更为复杂的时候，单纯的在dispatch和reducer中处理业务逻辑已经不具有普遍性。我们需要的是可以组合的，自由插拔的插件机制，redux借鉴koa的中间件思想，实现了redux的middleware。在发出action和执行reducer之间，使用中间件函数对store.dispatch进行改造，所以，redux的middleware是为了增强dispatch而生的。</p>\n<p>回顾中间件的使用方法，这里以，redux-thunk中间件为例，为之前的计数器添加一个延迟计数的功能，即点击按钮两秒后进行加1操作，redux和react-redux使用官方实现的，下面是改造后的代码：<br>首先是计数器组件，src下components目录下，Counter.js中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrement, onDecrement, incrementAsync &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;value&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrement&#125;&gt;</span><br><span class=\"line\">        +</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;onDecrement&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        -</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>button&gt;</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;incrementAsync&#125;&gt;</span><br><span class=\"line\">        Increment <span class=\"keyword\">async</span></span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>p&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Counter.propTypes = &#123;</span><br><span class=\"line\">    value: PropTypes.number.isRequired,</span><br><span class=\"line\">    onIncrement: PropTypes.func.isRequired,</span><br><span class=\"line\">    onDecrement: PropTypes.func.isRequired,</span><br><span class=\"line\">    incrementAsync: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Counter;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，添加了用于异步加1的按钮，点击触发props中的incrementAsync方法。<br>下面是src下App.js的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; onIncrement, onDecrement, counter, incrementAsync &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;header className=<span class=\"string\">\"App-header\"</span>&gt;</span><br><span class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</span><br><span class=\"line\">          &lt;h1 className=<span class=\"string\">\"App-title\"</span>&gt;Welcome to React&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>header&gt;</span><br><span class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</span><br><span class=\"line\">          To <span class=\"keyword\">get</span> started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;Counter</span><br><span class=\"line\">          value=&#123;counter&#125;</span><br><span class=\"line\">          onIncrement=&#123;onIncrement&#125;</span><br><span class=\"line\">          onDecrement=&#123;onDecrement&#125;</span><br><span class=\"line\">          incrementAsync=&#123;incrementAsync&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: state</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onIncrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'INCREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function onDecrement() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return &#123; type: 'DECREMENT' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function incrementAsync() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return dispatch =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      dispatch(onIncrement());</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;, 2000)</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const mapDispatchToProps = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  onIncrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  onDecrement,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure>\n<p>相比上一篇文章，主要定义了incrementAsync方法，然后添加到mapDispatch中，在incrementSync中，返回一个函数，在函数内部执行异步操作发起action，普通的action都是一个对象的形式，但是异步的action返回的是一个function，处理这种情况就需要使用redux的中间件：redux-thunk。<br>下面是src下index.js的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./index.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;applyMiddleware, createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter, applyMiddleware(thunk));</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>在index.js中，引入react-thunk模块，然后在createStore中传入第二个参数，使用redux的API applymiddleware对chunk中间件进行包裹。<br>上述就是改进后的计数器，运行项目在浏览器预览下，点击incrementAsync按钮，达到预期效果。如下图：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_195.png\" alt=\"image\"></p>\n<h3 id=\"applyMiddleware实现\"><a href=\"#applyMiddleware实现\" class=\"headerlink\" title=\"applyMiddleware实现\"></a>applyMiddleware实现</h3><p>applyMiddleware是redux提供的用于使用中间件的API，回顾applyMiddleware的使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(counter, applyMiddleware(logger, thunk));</span><br></pre></td></tr></table></figure>\n<p>applyMiddleware接收多个中间件参数，返回值作为第二个参数传入createStore。</p>\n<p>在src下redux.js文件中，首先让原来的createStore支持传入第二个参数，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, enhancer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enhancer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在createStore中传入第二个参数enhancer，enhancer即调用applyMiddleware包装中间件的函数，然后判断enhancer是否存在，存在即调用enhancer传入createStore和reducer两个参数，由此，applyMiddleware应该是一个高阶函数，返回一个新的函数。<br>下面暴露applyMiddleware方法。redux的middleware是支持多个中间件的，此处先实现支持一个中间件的用法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">middleware</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = store.dispatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> midApi = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dispatch = middleware(midApi)(store.dispatch)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>applyMiddleware的结构是一个多层柯里化的函数，第一层函数执行后返回一个函数，这个函数即createStore函数中的参数enhancer，然后这个函数传入createStore参数，再返回一个函数，这个函数传入reducer参数，使用…args进行解构，在函数内部，首先调用createStore获取到原始的store以及dispatch，然后封装一个对象midApi传入中间件内部，midApi包括两个方法getState和dispatch，getState对应store.getState方法，dispatch对应store.dispatch方法并透传参数。下面是一个日志中间件的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'dispatching'</span>, action);</span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState());</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可见，中间件函数是一个层层包裹的匿名函数，第一层传入store，第二层传入next下一个中间件，此处指store.dispatch，第三层是在组件中进行调用时，传入action。logger中间件在applyMiddleware中被层层调用，动态的对store和next参数赋值。</p>\n<p>接着看上面applyMiddleware的代码，定义了一个由getState和dispatch组成的闭包midApi，中间件函数middleware第一次调用传入midApi返回一个匿名函数，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'dispatching'</span>, action);</span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState());</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>紧接着对匿名函数再次调用，传入store.dispatch作为参数next，再次返回一个匿名函数，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">action =&gt; &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'dispatching'</span>, action);</span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = next(action);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'next state'</span>, store.getState());</span><br><span class=\"line\"> <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过对middleware的层层调用来生成一个新的dispatch方法，新的dispatch<br>对store原有的dispatch方法进行了增强，最后返回一个对象，使用解构赋值将增强的dispatch覆盖原有的store.dispatch，成为一个新的store。最终，在组件中发起dispatch的时候使用的就是新的dispatch方法。</p>\n<p>到这里，已经让redux支持中间件的用法了，现在来使用一下，还是使用上面项目中的计数器案例，将redux和react-redux替换为自己编写的文件，redux-thunk不变，运行项目，依次点击三个按钮，达到预期效果。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_196.png\" alt=\"image\"></p>\n<h3 id=\"编写redux-thunk中间件\"><a href=\"#编写redux-thunk中间件\" class=\"headerlink\" title=\"编写redux-thunk中间件\"></a>编写redux-thunk中间件</h3><p>上面已经让我们的redux支持使用中间件，下面来尝试自己编写一个thunk中间件。在src下新建thunk.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thunk = <span class=\"function\">(<span class=\"params\">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n<p>一个中间件的结构如上，一个三层箭头函数，第一个参数传入midApi，这里解构出dispatch和getState方法方便使用，第二个参数传入下一个中间件，即store.dispatch，第三个参数传入需要提交的action。在中间件函数中，如果什么都不做，直接返回next（action），即直接dispatch action。当然，这样做并没有什么用，下面为它加上thunk的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thunk = <span class=\"function\">(<span class=\"params\">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果是函数，执行一下</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action(dispatch, getState);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n<p>这就是redux-thunk的代码，很简单吧，首先判断传入的action是否为fuction，如果是function就执行该action，并传入dispatch和getState， 如下，在incrementAsync的返回函数的参数中，可以接受dispatch和getState两个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(onIncrement());</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面来验证一下实现的thunk中间件，在src下替换redux-thunk为./thunk。在浏览器依次点击三个按钮，结果如下，达到预期效果。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_197.png\" alt=\"image\"></p>"},{"title":"手摸手撸一个简单的Redux（五）","date":"2018-04-04T13:30:00.000Z","banner":"http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg","_content":"\n> Redux使用CombineReducer来组合多个reducer函数。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n之前我们已经完成了redux和react-redux的大部分功能，本文将结合之前的To do list项目来完善我们编写的redux和react-redux，主要是实现combineReducer以及mapDiapatch的默认参数和让mapDispatch支持function参数。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-7\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### combineReducer\n随着应用变得越来越复杂，我们会将reducer根据业务进行拆分，拆分后的reducer函数负责独立管理state的一部分。\n\nRedux为我们提供了combineReducer这个辅助函数，用于将我们拆分后的多个reducer根据自身的键值进行组合成一个新的object，成为新的reducer，然后对这个reducer调用createStore方法。\n\ncombineReducer合并后的reducer可以调用各个子reducer，并且把返回的结果合并成一个state对象。由combineReducer返回的state对象，会将传入的每个reducer返回的state按其传递给combineReducer时对应的key进行命名。\n\n通常在项目中，我们会为每个单独的reducer单独创建js文件，在reducer中为每个reducer进行命名并导出，然后在reducer的入口文件中导入，通过Redux的combineReducer为每个reducer进行命名不同的key来控制不同的state的key的命名。\n下面回顾一下在之前Todo list项目中对combineReducer的使用。\nreducers/index.js：\n\n``` js\nimport { combineReducers } from 'redux';\nimport todos from './todos';\nimport visibilityFilter from './visibilityFilter';\n\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n});\n\nexport default todoApp;\n```\n\n\ncombineReducers({todos, visibilityFilter})这里使用了ES6的对象简写语法，这与\ncombineReducers({todos: todos, visibilityFilter: visibilityFilter})是等价的。\n此处需要注意，combineReducer中传入对象的key与redux中存储的state同名。\n\n下面来实现一个简单的combineReducer。\n在src/redux.js中：\n\n``` js\nexport function combineReducers(reducers) {\n  const finalReducerKeys = Object.keys(reducers);\n\n  return (state = {}, action) => {\n    let nextState = {};\n    finalReducerKeys.forEach((key) => {\n      const reducer = reducers[key];\n      const prevStateForKey = state[key];\n      const nextStateForKey = reducer(prevStateForKey, action);\n      nextState[key] = nextStateForKey;\n    });\n\n    return nextState;\n  }\n\n}\n```\n\n可以看到，combineReducer是一个高阶函数，返回一个function，首先通过Object.keys获取到由reducers\n的key组成的数组finalReducerKeys，然后返回一个function，这个function是一个组合后的reducer函数，\n接收state和action参数，state默认为空对象，在function内部，定义nextState为空对象，然后对\nfinalReducerKeys进行遍历，通过数组的key获取到每一个reducer，然后为reducer传入前一个state和\naction，返回新的state并加入到nextState的对象中，最后返回新的state。\n我们还可以用更加简洁的代码来实现：\n\n``` js\nexport function combineReducers(reducers) {\n  \n  const finalReducerKeys = Object.keys(reducers);\n\n  return (state = {}, action) => {\n\n    return finalReducerKeys.reduce((ret, item) => {\n       ret[item] = reducers[item](state[item], action);\n       return ret;\n    }, {});\n  }\n\n}\n```\n\n上述代码中，使用reduce对一个空对象进行累加操作，对数组每一项进行计算并返回一个新的对象，代码更加简洁。\n\n\n### 新的To do List\n\n现在我们将之前使用react-redux实现的To do List项目使用自己实现的react-redux，修改containers文件夹下\n的AddTodo.js、FilterLink.js、VisibleTodoList.js，将引用的react-redux修改为自己编写的\nreact-redux，如下：\n\n``` js\nimport { connect } from '../react-redux'\n```\n\n然后运行项目，开始报错：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_220.png)\n\nemm。\n\n好吧，查看报错信息，发现containers/FilterLink.js文件中：\n\n``` js\nimport { connect } from '../react-redux'\nimport { setVisibilityFilter } from '../actions'\nimport Link from '../components/Link'\n\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link);\n\nexport default FilterLink\n```\n\n在mapStateToProps和mapDispatchToProps都使用了ownProps参数，但是再看下我们自己的react-redux中\nconnect的参数。\n\n``` js\nupdate() {\n  const { store } = this.context;\n  const stateProps = mapStateToProps(store.getState());\n  const dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n\n  this.setState({\n    props: {\n      ...this.state.props,\n      ...stateProps,\n      ...dispatchProps,\n    }\n  })\n}\n```\n\n使用mapStateToProps并没有传入props，修改如下：\n\n``` js\nconst stateProps = mapStateToProps(store.getState(), this.props);\n```\n\n然后，没有报错了，但是页面好像有点问题，下面的筛选按钮没有显示出来。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_221.png)\n\n使用React开发者工具查看，是因为props没有传递下去。修改上述代码，将ConectComponent\n中的this.props也传递下去。\n\n``` js\nthis.setState({\n  props: {\n    ...this.state.props,\n    ...stateProps,\n    ...dispatchProps,\n    ...this.props,\n  }\n})\n```\n\n再查看界面，显示好了，下面尝试新增一个to do。输入提交后又报错了。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_222.png)\n\n查看报错信息：\n``` js\nTypeError: dispatch is not a function\n```\n\n原来是AddTodo组件的props中没有dispatch方法，分析如下，使用connect将AddTodo组件与Redux进行连接，\n但是connect中并没有传递参数，mapDispatch参数被默认定义为空对象，这里应该默认定义为一个dispatch方法，\n修改如下：\n\n``` js\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps) => (WrapComponent) => {\n  return class ConectComponent extends React.Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    constructor(props, context) {\n      super(props, context);\n      this.state = {\n        props: {}\n      }\n    }\n    componentDidMount() {\n      const { store } = this.context;\n      store.subscribe(() => this.update());\n      this.update();\n    }\n    update() {\n      const { store } = this.context;\n      const stateProps = mapStateToProps(store.getState(), this.props);\n      if (!mapDispatchToProps) {\n       \n          mapDispatchToProps = { dispatch: store.dispatch}\n      }\n     \n\n      this.setState({\n        props: {\n          ...this.state.props,\n          ...stateProps,\n          ...dispatchProps,\n          ...this.props,\n        }\n      })\n    }\n    render() {\n      return <WrapComponent {...this.state.props}/>\n    }\n  }\n}\n```\n\n这里主要是去掉了mapDispatch的默认参数，在update函数中对其进行判断是否为空，为空则传递一个对象，对象包含\n一个dispatch方法。\n再次尝试添加todo，添加成功，但是出来了两条数据，可能是连续触发了两次dispatch，点击筛选按钮试试，报错了。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_223.png)\n查看报错信息：\n\n``` js\nTypeError: _onClick is not a function\n```\n\n\ncomponents/Link.js中的onClick props没有传递进来，查看onClick方法定义的地方：\n在containers/FilterLink.js中，在mapDispatch中进行了定义：\n\n``` js\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n```\n\n\n在我们实现的connect中，mapDispatch只支持传递对象参数，下面进行修改，让其支持传递函数。\n修改update方法：\n\n``` js\nlet dispatchProps;\nif (typeof mapDispatchToProps === 'function') {\n    dispatchProps = mapDispatchToProps(store.dispatch, this.props);\n} else {\n    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n}\n```\n\n上述代码的作用主要是对mapDispatch进行处理，判断其类型是否为function，如果为function则执行一下，\n传入store.dispatch和this.props参数，返回一个对象，然后赋值到dispatchProps上。\n然后尝试点击筛选按钮，没有报错，功能正常，但是添加todo还是会出现两条数据，经过调试发现是因为又执行了一\n次bindActionCreator，尝试将mapDispatch的默认值修改为一个函数，如下：\n\n``` js\nif (!mapDispatchToProps) {\n  mapDispatchToProps = (dispatch) => ({dispatch})\n}\nlet dispatchProps;\nif (typeof mapDispatchToProps === 'function') {\n    dispatchProps = mapDispatchToProps(store.dispatch, this.props);\n} else {\n    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n}\n```\n\n这样，下面对mapDispatch进行判断后，会返回一个对象，包含dispatch方法。\n重新添加todo，成功，数据正确。如下图。\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_224.png)\n\n细心的你发现了吗？在右边的控制台一直会出现警告，大概意思是我们的组件props参数应该是一些数值但是实际上\n是undefined，因为在组件内部定义了PropTypes。\n\n``` js\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\n```\n\n问题应该出现在我们的connect方法中，在connect方法中，最终render返回包裹的组件，并传递this.state.props\n到包裹的组件，但是this.state.props初始为空，只有在componentDidMount才会调用this.update方法更新state，\n而组件执行是先render再执行componentDidMount，故第一次render时所有的props都是undefined，造成报错。\n我们可以将componentDidMount修改为componentWillMount，componentWillMount在render之前执行，可以避免\n这个报错。修改如下：\n\n``` js\ncomponentWillMount() {\n  const { store } = this.context;\n  store.subscribe(() => this.update());\n  this.update();\n}\n```\n\n最终效果如下，没有报错信息，尝试添加todo和修改，功能都正常。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_225.png)\n\n\n\n参考：\n> https://github.com/ecmadao/Coding-Guide/tree/master/Notes/React/Redux\n","source":"_posts/手摸手撸一个简单的Redux（五）.md","raw":"---\ntitle: 手摸手撸一个简单的Redux（五）\ndate: 2018-04-04 21:30:00\nbanner: http://img.yanyuanfe.cn/photo-1432821596592-e2c18b78144f.jpeg\ntags:\n - Redux\n - React\n---\n\n> Redux使用CombineReducer来组合多个reducer函数。\n\n![image](http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png)\n\n<!--more-->\n\n之前我们已经完成了redux和react-redux的大部分功能，本文将结合之前的To do list项目来完善我们编写的redux和react-redux，主要是实现combineReducer以及mapDiapatch的默认参数和让mapDispatch支持function参数。\n\n> 本文完整代码请查看Github：https://github.com/YanYuanFE/redux-app\n\n``` bash\n// clone repo\ngit clone https://github.com/YanYuanFE/redux-app.git\n\n\ncd redux-app\n\n// checkout branch\ngit checkout part-7\n\n// install\nnpm install\n\n// start\nnpm start\n\n```\n\n### combineReducer\n随着应用变得越来越复杂，我们会将reducer根据业务进行拆分，拆分后的reducer函数负责独立管理state的一部分。\n\nRedux为我们提供了combineReducer这个辅助函数，用于将我们拆分后的多个reducer根据自身的键值进行组合成一个新的object，成为新的reducer，然后对这个reducer调用createStore方法。\n\ncombineReducer合并后的reducer可以调用各个子reducer，并且把返回的结果合并成一个state对象。由combineReducer返回的state对象，会将传入的每个reducer返回的state按其传递给combineReducer时对应的key进行命名。\n\n通常在项目中，我们会为每个单独的reducer单独创建js文件，在reducer中为每个reducer进行命名并导出，然后在reducer的入口文件中导入，通过Redux的combineReducer为每个reducer进行命名不同的key来控制不同的state的key的命名。\n下面回顾一下在之前Todo list项目中对combineReducer的使用。\nreducers/index.js：\n\n``` js\nimport { combineReducers } from 'redux';\nimport todos from './todos';\nimport visibilityFilter from './visibilityFilter';\n\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n});\n\nexport default todoApp;\n```\n\n\ncombineReducers({todos, visibilityFilter})这里使用了ES6的对象简写语法，这与\ncombineReducers({todos: todos, visibilityFilter: visibilityFilter})是等价的。\n此处需要注意，combineReducer中传入对象的key与redux中存储的state同名。\n\n下面来实现一个简单的combineReducer。\n在src/redux.js中：\n\n``` js\nexport function combineReducers(reducers) {\n  const finalReducerKeys = Object.keys(reducers);\n\n  return (state = {}, action) => {\n    let nextState = {};\n    finalReducerKeys.forEach((key) => {\n      const reducer = reducers[key];\n      const prevStateForKey = state[key];\n      const nextStateForKey = reducer(prevStateForKey, action);\n      nextState[key] = nextStateForKey;\n    });\n\n    return nextState;\n  }\n\n}\n```\n\n可以看到，combineReducer是一个高阶函数，返回一个function，首先通过Object.keys获取到由reducers\n的key组成的数组finalReducerKeys，然后返回一个function，这个function是一个组合后的reducer函数，\n接收state和action参数，state默认为空对象，在function内部，定义nextState为空对象，然后对\nfinalReducerKeys进行遍历，通过数组的key获取到每一个reducer，然后为reducer传入前一个state和\naction，返回新的state并加入到nextState的对象中，最后返回新的state。\n我们还可以用更加简洁的代码来实现：\n\n``` js\nexport function combineReducers(reducers) {\n  \n  const finalReducerKeys = Object.keys(reducers);\n\n  return (state = {}, action) => {\n\n    return finalReducerKeys.reduce((ret, item) => {\n       ret[item] = reducers[item](state[item], action);\n       return ret;\n    }, {});\n  }\n\n}\n```\n\n上述代码中，使用reduce对一个空对象进行累加操作，对数组每一项进行计算并返回一个新的对象，代码更加简洁。\n\n\n### 新的To do List\n\n现在我们将之前使用react-redux实现的To do List项目使用自己实现的react-redux，修改containers文件夹下\n的AddTodo.js、FilterLink.js、VisibleTodoList.js，将引用的react-redux修改为自己编写的\nreact-redux，如下：\n\n``` js\nimport { connect } from '../react-redux'\n```\n\n然后运行项目，开始报错：\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_220.png)\n\nemm。\n\n好吧，查看报错信息，发现containers/FilterLink.js文件中：\n\n``` js\nimport { connect } from '../react-redux'\nimport { setVisibilityFilter } from '../actions'\nimport Link from '../components/Link'\n\nconst mapStateToProps = (state, ownProps) => ({\n  active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link);\n\nexport default FilterLink\n```\n\n在mapStateToProps和mapDispatchToProps都使用了ownProps参数，但是再看下我们自己的react-redux中\nconnect的参数。\n\n``` js\nupdate() {\n  const { store } = this.context;\n  const stateProps = mapStateToProps(store.getState());\n  const dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n\n  this.setState({\n    props: {\n      ...this.state.props,\n      ...stateProps,\n      ...dispatchProps,\n    }\n  })\n}\n```\n\n使用mapStateToProps并没有传入props，修改如下：\n\n``` js\nconst stateProps = mapStateToProps(store.getState(), this.props);\n```\n\n然后，没有报错了，但是页面好像有点问题，下面的筛选按钮没有显示出来。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_221.png)\n\n使用React开发者工具查看，是因为props没有传递下去。修改上述代码，将ConectComponent\n中的this.props也传递下去。\n\n``` js\nthis.setState({\n  props: {\n    ...this.state.props,\n    ...stateProps,\n    ...dispatchProps,\n    ...this.props,\n  }\n})\n```\n\n再查看界面，显示好了，下面尝试新增一个to do。输入提交后又报错了。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_222.png)\n\n查看报错信息：\n``` js\nTypeError: dispatch is not a function\n```\n\n原来是AddTodo组件的props中没有dispatch方法，分析如下，使用connect将AddTodo组件与Redux进行连接，\n但是connect中并没有传递参数，mapDispatch参数被默认定义为空对象，这里应该默认定义为一个dispatch方法，\n修改如下：\n\n``` js\nexport const connect = (mapStateToProps = state => state, mapDispatchToProps) => (WrapComponent) => {\n  return class ConectComponent extends React.Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n\n    constructor(props, context) {\n      super(props, context);\n      this.state = {\n        props: {}\n      }\n    }\n    componentDidMount() {\n      const { store } = this.context;\n      store.subscribe(() => this.update());\n      this.update();\n    }\n    update() {\n      const { store } = this.context;\n      const stateProps = mapStateToProps(store.getState(), this.props);\n      if (!mapDispatchToProps) {\n       \n          mapDispatchToProps = { dispatch: store.dispatch}\n      }\n     \n\n      this.setState({\n        props: {\n          ...this.state.props,\n          ...stateProps,\n          ...dispatchProps,\n          ...this.props,\n        }\n      })\n    }\n    render() {\n      return <WrapComponent {...this.state.props}/>\n    }\n  }\n}\n```\n\n这里主要是去掉了mapDispatch的默认参数，在update函数中对其进行判断是否为空，为空则传递一个对象，对象包含\n一个dispatch方法。\n再次尝试添加todo，添加成功，但是出来了两条数据，可能是连续触发了两次dispatch，点击筛选按钮试试，报错了。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_223.png)\n查看报错信息：\n\n``` js\nTypeError: _onClick is not a function\n```\n\n\ncomponents/Link.js中的onClick props没有传递进来，查看onClick方法定义的地方：\n在containers/FilterLink.js中，在mapDispatch中进行了定义：\n\n``` js\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  onClick: () => {\n    dispatch(setVisibilityFilter(ownProps.filter))\n  }\n})\n```\n\n\n在我们实现的connect中，mapDispatch只支持传递对象参数，下面进行修改，让其支持传递函数。\n修改update方法：\n\n``` js\nlet dispatchProps;\nif (typeof mapDispatchToProps === 'function') {\n    dispatchProps = mapDispatchToProps(store.dispatch, this.props);\n} else {\n    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n}\n```\n\n上述代码的作用主要是对mapDispatch进行处理，判断其类型是否为function，如果为function则执行一下，\n传入store.dispatch和this.props参数，返回一个对象，然后赋值到dispatchProps上。\n然后尝试点击筛选按钮，没有报错，功能正常，但是添加todo还是会出现两条数据，经过调试发现是因为又执行了一\n次bindActionCreator，尝试将mapDispatch的默认值修改为一个函数，如下：\n\n``` js\nif (!mapDispatchToProps) {\n  mapDispatchToProps = (dispatch) => ({dispatch})\n}\nlet dispatchProps;\nif (typeof mapDispatchToProps === 'function') {\n    dispatchProps = mapDispatchToProps(store.dispatch, this.props);\n} else {\n    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);\n}\n```\n\n这样，下面对mapDispatch进行判断后，会返回一个对象，包含dispatch方法。\n重新添加todo，成功，数据正确。如下图。\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_224.png)\n\n细心的你发现了吗？在右边的控制台一直会出现警告，大概意思是我们的组件props参数应该是一些数值但是实际上\n是undefined，因为在组件内部定义了PropTypes。\n\n``` js\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\n```\n\n问题应该出现在我们的connect方法中，在connect方法中，最终render返回包裹的组件，并传递this.state.props\n到包裹的组件，但是this.state.props初始为空，只有在componentDidMount才会调用this.update方法更新state，\n而组件执行是先render再执行componentDidMount，故第一次render时所有的props都是undefined，造成报错。\n我们可以将componentDidMount修改为componentWillMount，componentWillMount在render之前执行，可以避免\n这个报错。修改如下：\n\n``` js\ncomponentWillMount() {\n  const { store } = this.context;\n  store.subscribe(() => this.update());\n  this.update();\n}\n```\n\n最终效果如下，没有报错信息，尝试添加todo和修改，功能都正常。\n\n![image](http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_225.png)\n\n\n\n参考：\n> https://github.com/ecmadao/Coding-Guide/tree/master/Notes/React/Redux\n","slug":"手摸手撸一个简单的Redux（五）","published":1,"updated":"2020-07-16T13:56:47.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pceno8001rp70vvtnb1oqt","content":"<blockquote>\n<p>Redux使用CombineReducer来组合多个reducer函数。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>之前我们已经完成了redux和react-redux的大部分功能，本文将结合之前的To do list项目来完善我们编写的redux和react-redux，主要是实现combineReducer以及mapDiapatch的默认参数和让mapDispatch支持function参数。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-7</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"combineReducer\"><a href=\"#combineReducer\" class=\"headerlink\" title=\"combineReducer\"></a>combineReducer</h3><p>随着应用变得越来越复杂，我们会将reducer根据业务进行拆分，拆分后的reducer函数负责独立管理state的一部分。</p>\n<p>Redux为我们提供了combineReducer这个辅助函数，用于将我们拆分后的多个reducer根据自身的键值进行组合成一个新的object，成为新的reducer，然后对这个reducer调用createStore方法。</p>\n<p>combineReducer合并后的reducer可以调用各个子reducer，并且把返回的结果合并成一个state对象。由combineReducer返回的state对象，会将传入的每个reducer返回的state按其传递给combineReducer时对应的key进行命名。</p>\n<p>通常在项目中，我们会为每个单独的reducer单独创建js文件，在reducer中为每个reducer进行命名并导出，然后在reducer的入口文件中导入，通过Redux的combineReducer为每个reducer进行命名不同的key来控制不同的state的key的命名。<br>下面回顾一下在之前Todo list项目中对combineReducer的使用。<br>reducers/index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> visibilityFilter <span class=\"keyword\">from</span> <span class=\"string\">'./visibilityFilter'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  visibilityFilter</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp;</span><br></pre></td></tr></table></figure>\n<p>combineReducers({todos, visibilityFilter})这里使用了ES6的对象简写语法，这与<br>combineReducers({todos: todos, visibilityFilter: visibilityFilter})是等价的。<br>此处需要注意，combineReducer中传入对象的key与redux中存储的state同名。</p>\n<p>下面来实现一个简单的combineReducer。<br>在src/redux.js中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(reducers);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextState = &#123;&#125;;</span><br><span class=\"line\">    finalReducerKeys.forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = reducers[key];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> prevStateForKey = state[key];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(prevStateForKey, action);</span><br><span class=\"line\">      nextState[key] = nextStateForKey;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，combineReducer是一个高阶函数，返回一个function，首先通过Object.keys获取到由reducers<br>的key组成的数组finalReducerKeys，然后返回一个function，这个function是一个组合后的reducer函数，<br>接收state和action参数，state默认为空对象，在function内部，定义nextState为空对象，然后对<br>finalReducerKeys进行遍历，通过数组的key获取到每一个reducer，然后为reducer传入前一个state和<br>action，返回新的state并加入到nextState的对象中，最后返回新的state。<br>我们还可以用更加简洁的代码来实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(reducers);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> finalReducerKeys.reduce(<span class=\"function\">(<span class=\"params\">ret, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       ret[item] = reducers[item](state[item], action);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;, &#123;&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，使用reduce对一个空对象进行累加操作，对数组每一项进行计算并返回一个新的对象，代码更加简洁。</p>\n<h3 id=\"新的To-do-List\"><a href=\"#新的To-do-List\" class=\"headerlink\" title=\"新的To do List\"></a>新的To do List</h3><p>现在我们将之前使用react-redux实现的To do List项目使用自己实现的react-redux，修改containers文件夹下<br>的AddTodo.js、FilterLink.js、VisibleTodoList.js，将引用的react-redux修改为自己编写的<br>react-redux，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../react-redux'</span></span><br></pre></td></tr></table></figure>\n<p>然后运行项目，开始报错：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_220.png\" alt=\"image\"></p>\n<p>emm。</p>\n<p>好吧，查看报错信息，发现containers/FilterLink.js文件中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; setVisibilityFilter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Link <span class=\"keyword\">from</span> <span class=\"string\">'../components/Link'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> FilterLink</span><br></pre></td></tr></table></figure>\n<p>在mapStateToProps和mapDispatchToProps都使用了ownProps参数，但是再看下我们自己的react-redux中<br>connect的参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...this.state.props,</span><br><span class=\"line\">      ...stateProps,</span><br><span class=\"line\">      ...dispatchProps,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用mapStateToProps并没有传入props，修改如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState(), <span class=\"keyword\">this</span>.props);</span><br></pre></td></tr></table></figure>\n<p>然后，没有报错了，但是页面好像有点问题，下面的筛选按钮没有显示出来。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_221.png\" alt=\"image\"></p>\n<p>使用React开发者工具查看，是因为props没有传递下去。修改上述代码，将ConectComponent<br>中的this.props也传递下去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    ...this.state.props,</span><br><span class=\"line\">    ...stateProps,</span><br><span class=\"line\">    ...dispatchProps,</span><br><span class=\"line\">    ...this.props,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>再查看界面，显示好了，下面尝试新增一个to do。输入提交后又报错了。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_222.png\" alt=\"image\"></p>\n<p>查看报错信息：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TypeError</span>: dispatch is not a <span class=\"function\"><span class=\"keyword\">function</span></span></span><br></pre></td></tr></table></figure></p>\n<p>原来是AddTodo组件的props中没有dispatch方法，分析如下，使用connect将AddTodo组件与Redux进行连接，<br>但是connect中并没有传递参数，mapDispatch参数被默认定义为空对象，这里应该默认定义为一个dispatch方法，<br>修改如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state =&gt; state, mapDispatchToProps</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">      store: PropTypes.object</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        props: &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">      store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState(), <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!mapDispatchToProps) &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">          mapDispatchToProps = &#123; <span class=\"attr\">dispatch</span>: store.dispatch&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">          ...this.state.props,</span><br><span class=\"line\">          ...stateProps,</span><br><span class=\"line\">          ...dispatchProps,</span><br><span class=\"line\">          ...this.props,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrapComponent</span> &#123;<span class=\"attr\">...this.state.props</span>&#125;/&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里主要是去掉了mapDispatch的默认参数，在update函数中对其进行判断是否为空，为空则传递一个对象，对象包含<br>一个dispatch方法。<br>再次尝试添加todo，添加成功，但是出来了两条数据，可能是连续触发了两次dispatch，点击筛选按钮试试，报错了。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_223.png\" alt=\"image\"><br>查看报错信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TypeError</span>: _onClick is not a <span class=\"function\"><span class=\"keyword\">function</span></span></span><br></pre></td></tr></table></figure>\n<p>components/Link.js中的onClick props没有传递进来，查看onClick方法定义的地方：<br>在containers/FilterLink.js中，在mapDispatch中进行了定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在我们实现的connect中，mapDispatch只支持传递对象参数，下面进行修改，让其支持传递函数。<br>修改update方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dispatchProps;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> mapDispatchToProps === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    dispatchProps = mapDispatchToProps(store.dispatch, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码的作用主要是对mapDispatch进行处理，判断其类型是否为function，如果为function则执行一下，<br>传入store.dispatch和this.props参数，返回一个对象，然后赋值到dispatchProps上。<br>然后尝试点击筛选按钮，没有报错，功能正常，但是添加todo还是会出现两条数据，经过调试发现是因为又执行了一<br>次bindActionCreator，尝试将mapDispatch的默认值修改为一个函数，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!mapDispatchToProps) &#123;</span><br><span class=\"line\">  mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> (&#123;dispatch&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dispatchProps;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> mapDispatchToProps === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    dispatchProps = mapDispatchToProps(store.dispatch, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，下面对mapDispatch进行判断后，会返回一个对象，包含dispatch方法。<br>重新添加todo，成功，数据正确。如下图。<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_224.png\" alt=\"image\"></p>\n<p>细心的你发现了吗？在右边的控制台一直会出现警告，大概意思是我们的组件props参数应该是一些数值但是实际上<br>是undefined，因为在组件内部定义了PropTypes。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Link.propTypes = &#123;</span><br><span class=\"line\">  active: PropTypes.bool.isRequired,</span><br><span class=\"line\">  children: PropTypes.node.isRequired,</span><br><span class=\"line\">  onClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Link</span><br><span class=\"line\">Link.propTypes = &#123;</span><br><span class=\"line\">  active: PropTypes.bool.isRequired,</span><br><span class=\"line\">  children: PropTypes.node.isRequired,</span><br><span class=\"line\">  onClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Link</span><br></pre></td></tr></table></figure>\n<p>问题应该出现在我们的connect方法中，在connect方法中，最终render返回包裹的组件，并传递this.state.props<br>到包裹的组件，但是this.state.props初始为空，只有在componentDidMount才会调用this.update方法更新state，<br>而组件执行是先render再执行componentDidMount，故第一次render时所有的props都是undefined，造成报错。<br>我们可以将componentDidMount修改为componentWillMount，componentWillMount在render之前执行，可以避免<br>这个报错。修改如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentWillMount() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，没有报错信息，尝试添加todo和修改，功能都正常。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_225.png\" alt=\"image\"></p>\n<p>参考：</p>\n<blockquote>\n<p><a href=\"https://github.com/ecmadao/Coding-Guide/tree/master/Notes/React/Redux\" target=\"_blank\" rel=\"noopener\">https://github.com/ecmadao/Coding-Guide/tree/master/Notes/React/Redux</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Redux使用CombineReducer来组合多个reducer函数。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67.png\" alt=\"image\"></p>","more":"<p>之前我们已经完成了redux和react-redux的大部分功能，本文将结合之前的To do list项目来完善我们编写的redux和react-redux，主要是实现combineReducer以及mapDiapatch的默认参数和让mapDispatch支持function参数。</p>\n<blockquote>\n<p>本文完整代码请查看Github：<a href=\"https://github.com/YanYuanFE/redux-app\" target=\"_blank\" rel=\"noopener\">https://github.com/YanYuanFE/redux-app</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// <span class=\"built_in\">clone</span> repo</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YanYuanFE/redux-app.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> redux-app</span><br><span class=\"line\"></span><br><span class=\"line\">// checkout branch</span><br><span class=\"line\">git checkout part-7</span><br><span class=\"line\"></span><br><span class=\"line\">// install</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">// start</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<h3 id=\"combineReducer\"><a href=\"#combineReducer\" class=\"headerlink\" title=\"combineReducer\"></a>combineReducer</h3><p>随着应用变得越来越复杂，我们会将reducer根据业务进行拆分，拆分后的reducer函数负责独立管理state的一部分。</p>\n<p>Redux为我们提供了combineReducer这个辅助函数，用于将我们拆分后的多个reducer根据自身的键值进行组合成一个新的object，成为新的reducer，然后对这个reducer调用createStore方法。</p>\n<p>combineReducer合并后的reducer可以调用各个子reducer，并且把返回的结果合并成一个state对象。由combineReducer返回的state对象，会将传入的每个reducer返回的state按其传递给combineReducer时对应的key进行命名。</p>\n<p>通常在项目中，我们会为每个单独的reducer单独创建js文件，在reducer中为每个reducer进行命名并导出，然后在reducer的入口文件中导入，通过Redux的combineReducer为每个reducer进行命名不同的key来控制不同的state的key的命名。<br>下面回顾一下在之前Todo list项目中对combineReducer的使用。<br>reducers/index.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> visibilityFilter <span class=\"keyword\">from</span> <span class=\"string\">'./visibilityFilter'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  visibilityFilter</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp;</span><br></pre></td></tr></table></figure>\n<p>combineReducers({todos, visibilityFilter})这里使用了ES6的对象简写语法，这与<br>combineReducers({todos: todos, visibilityFilter: visibilityFilter})是等价的。<br>此处需要注意，combineReducer中传入对象的key与redux中存储的state同名。</p>\n<p>下面来实现一个简单的combineReducer。<br>在src/redux.js中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(reducers);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nextState = &#123;&#125;;</span><br><span class=\"line\">    finalReducerKeys.forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = reducers[key];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> prevStateForKey = state[key];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(prevStateForKey, action);</span><br><span class=\"line\">      nextState[key] = nextStateForKey;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，combineReducer是一个高阶函数，返回一个function，首先通过Object.keys获取到由reducers<br>的key组成的数组finalReducerKeys，然后返回一个function，这个function是一个组合后的reducer函数，<br>接收state和action参数，state默认为空对象，在function内部，定义nextState为空对象，然后对<br>finalReducerKeys进行遍历，通过数组的key获取到每一个reducer，然后为reducer传入前一个state和<br>action，返回新的state并加入到nextState的对象中，最后返回新的state。<br>我们还可以用更加简洁的代码来实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(reducers);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> finalReducerKeys.reduce(<span class=\"function\">(<span class=\"params\">ret, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       ret[item] = reducers[item](state[item], action);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;, &#123;&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，使用reduce对一个空对象进行累加操作，对数组每一项进行计算并返回一个新的对象，代码更加简洁。</p>\n<h3 id=\"新的To-do-List\"><a href=\"#新的To-do-List\" class=\"headerlink\" title=\"新的To do List\"></a>新的To do List</h3><p>现在我们将之前使用react-redux实现的To do List项目使用自己实现的react-redux，修改containers文件夹下<br>的AddTodo.js、FilterLink.js、VisibleTodoList.js，将引用的react-redux修改为自己编写的<br>react-redux，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../react-redux'</span></span><br></pre></td></tr></table></figure>\n<p>然后运行项目，开始报错：</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_220.png\" alt=\"image\"></p>\n<p>emm。</p>\n<p>好吧，查看报错信息，发现containers/FilterLink.js文件中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; setVisibilityFilter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Link <span class=\"keyword\">from</span> <span class=\"string\">'../components/Link'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\">(<span class=\"params\">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  active: ownProps.filter === state.visibilityFilter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FilterLink = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Link);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> FilterLink</span><br></pre></td></tr></table></figure>\n<p>在mapStateToProps和mapDispatchToProps都使用了ownProps参数，但是再看下我们自己的react-redux中<br>connect的参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState());</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...this.state.props,</span><br><span class=\"line\">      ...stateProps,</span><br><span class=\"line\">      ...dispatchProps,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用mapStateToProps并没有传入props，修改如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState(), <span class=\"keyword\">this</span>.props);</span><br></pre></td></tr></table></figure>\n<p>然后，没有报错了，但是页面好像有点问题，下面的筛选按钮没有显示出来。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_221.png\" alt=\"image\"></p>\n<p>使用React开发者工具查看，是因为props没有传递下去。修改上述代码，将ConectComponent<br>中的this.props也传递下去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    ...this.state.props,</span><br><span class=\"line\">    ...stateProps,</span><br><span class=\"line\">    ...dispatchProps,</span><br><span class=\"line\">    ...this.props,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>再查看界面，显示好了，下面尝试新增一个to do。输入提交后又报错了。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_222.png\" alt=\"image\"></p>\n<p>查看报错信息：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TypeError</span>: dispatch is not a <span class=\"function\"><span class=\"keyword\">function</span></span></span><br></pre></td></tr></table></figure></p>\n<p>原来是AddTodo组件的props中没有dispatch方法，分析如下，使用connect将AddTodo组件与Redux进行连接，<br>但是connect中并没有传递参数，mapDispatch参数被默认定义为空对象，这里应该默认定义为一个dispatch方法，<br>修改如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> connect = <span class=\"function\">(<span class=\"params\">mapStateToProps = state =&gt; state, mapDispatchToProps</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConectComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">      store: PropTypes.object</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        props: &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">      store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> stateProps = mapStateToProps(store.getState(), <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!mapDispatchToProps) &#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">          mapDispatchToProps = &#123; <span class=\"attr\">dispatch</span>: store.dispatch&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">          ...this.state.props,</span><br><span class=\"line\">          ...stateProps,</span><br><span class=\"line\">          ...dispatchProps,</span><br><span class=\"line\">          ...this.props,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrapComponent</span> &#123;<span class=\"attr\">...this.state.props</span>&#125;/&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里主要是去掉了mapDispatch的默认参数，在update函数中对其进行判断是否为空，为空则传递一个对象，对象包含<br>一个dispatch方法。<br>再次尝试添加todo，添加成功，但是出来了两条数据，可能是连续触发了两次dispatch，点击筛选按钮试试，报错了。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_223.png\" alt=\"image\"><br>查看报错信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TypeError</span>: _onClick is not a <span class=\"function\"><span class=\"keyword\">function</span></span></span><br></pre></td></tr></table></figure>\n<p>components/Link.js中的onClick props没有传递进来，查看onClick方法定义的地方：<br>在containers/FilterLink.js中，在mapDispatch中进行了定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  onClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在我们实现的connect中，mapDispatch只支持传递对象参数，下面进行修改，让其支持传递函数。<br>修改update方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dispatchProps;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> mapDispatchToProps === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    dispatchProps = mapDispatchToProps(store.dispatch, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码的作用主要是对mapDispatch进行处理，判断其类型是否为function，如果为function则执行一下，<br>传入store.dispatch和this.props参数，返回一个对象，然后赋值到dispatchProps上。<br>然后尝试点击筛选按钮，没有报错，功能正常，但是添加todo还是会出现两条数据，经过调试发现是因为又执行了一<br>次bindActionCreator，尝试将mapDispatch的默认值修改为一个函数，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!mapDispatchToProps) &#123;</span><br><span class=\"line\">  mapDispatchToProps = <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> (&#123;dispatch&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dispatchProps;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> mapDispatchToProps === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    dispatchProps = mapDispatchToProps(store.dispatch, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，下面对mapDispatch进行判断后，会返回一个对象，包含dispatch方法。<br>重新添加todo，成功，数据正确。如下图。<br><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_224.png\" alt=\"image\"></p>\n<p>细心的你发现了吗？在右边的控制台一直会出现警告，大概意思是我们的组件props参数应该是一些数值但是实际上<br>是undefined，因为在组件内部定义了PropTypes。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Link.propTypes = &#123;</span><br><span class=\"line\">  active: PropTypes.bool.isRequired,</span><br><span class=\"line\">  children: PropTypes.node.isRequired,</span><br><span class=\"line\">  onClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Link</span><br><span class=\"line\">Link.propTypes = &#123;</span><br><span class=\"line\">  active: PropTypes.bool.isRequired,</span><br><span class=\"line\">  children: PropTypes.node.isRequired,</span><br><span class=\"line\">  onClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Link</span><br></pre></td></tr></table></figure>\n<p>问题应该出现在我们的connect方法中，在connect方法中，最终render返回包裹的组件，并传递this.state.props<br>到包裹的组件，但是this.state.props初始为空，只有在componentDidMount才会调用this.update方法更新state，<br>而组件执行是先render再执行componentDidMount，故第一次render时所有的props都是undefined，造成报错。<br>我们可以将componentDidMount修改为componentWillMount，componentWillMount在render之前执行，可以避免<br>这个报错。修改如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentWillMount() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; store &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">  store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.update());</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.update();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，没有报错信息，尝试添加todo和修改，功能都正常。</p>\n<p><img src=\"http://img.yanyuanfe.cn/%E9%80%89%E5%8C%BA_225.png\" alt=\"image\"></p>\n<p>参考：</p>\n<blockquote>\n<p><a href=\"https://github.com/ecmadao/Coding-Guide/tree/master/Notes/React/Redux\" target=\"_blank\" rel=\"noopener\">https://github.com/ecmadao/Coding-Guide/tree/master/Notes/React/Redux</a></p>\n</blockquote>"},{"title":"正则表达式必知必会","date":"2016-10-15T11:53:55.000Z","banner":"http://img.yanyuanfe.cn/reg.jpg","_content":"\n> 正则表达式可以用来完成各种复杂的文本处理工作，更重要的是，它可以在几乎所有的程序设计语言里和几乎所有的计算机平台上使用。\n\n![image](http://img.yanyuanfe.cn/reg.jpg)\n\n<!--more-->\n\n### 正则表达式初识\n\n正则表达式是被用来匹配字符串中的字符组合的模式。在JavaScript中，正则表达式也是对象。这种模式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。\n\n### JavaScript中的正则表达式\n\n在JavaScript中，通过下面两种方法创建一个正则表达式：\n\n使用一个正则表达式字面量，如下所示：\n\n\n``` js\nvar re = /ab+c/;\n```\n\n正则表达式字面量在脚本加载后编译。若你的正则表达式是常量，使用这种方式可以获得更好的性能。\n\n调用RegExp对象的构造函数，如下所示：\n\n\n``` js\nvar re = new RegExp(\"ab+c\");\n```\n\n使用构造函数，提供了对正则表达式运行时的编译。当你知道正则表达式的模式会发生改变， 或者你事先并不了解它的模式或者是从其他地方（比如用户的输入），得到的代码这时比较适合用构造函数的方式。\n\n### 正则表达式特殊符号\n\n\n字符 | 含义\n---|---\n\\ | 匹配将依照下列规则：反斜杠,对于其后的平常被当作字面量的字符，将其转义为特殊字符。比如，/b/匹配了字符'b'.通过在b的前面放一个反斜杠，即用作/\\b/，这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\\*/ 将 '*' 的特殊性移除，从而可以匹配像 \"a*\" 这样的字符串。使用 new RegExp(\"pattern\") 的时候不要忘记将 \\ 进行转义，因为 \\ 在字符串里面也是一个转义字符。\n^ | 匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 \"an A\" 中的 'A'，但是会匹配 \"An E\" 中的 'A'。当 '^' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合 一节有详细介绍和示例。\n$ | 匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 \"eater\" 中的 't'，但是会匹配 \"eat\" 中的 't'。\n* | 匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 \"A ghost boooooed\" 中的 'booooo' 和 \"A bird warbled\" 中的 'b'，但是在 \"A goat grunted\" 中将不会匹配任何东西。\n+| 匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 \"candy\" 中的 'a'，和在 \"caaaaaaandy\" 中所有的 'a'。\n? | 匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 \"angel\" 中的 'el'，和 \"angle\" 中的 'le' 以及\"oslo' 中的'l'。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1\"。还可以运用于向前断言，在本表格的 x(?=y) 和 x(?!y) 中有描述。\n. | （小数点）匹配除了换行符（\\n）之外的任何单个字符。例如，/.n/将会匹配 \"nay, an apple is on the tree\" 中的 'an' 和 'on'，但是不会匹配 'nay'。\n(x) | 匹配 'x' 并且记住匹配项，就像下面的例子展示的那样。括号被称为 **捕获括号**。模式 /(foo) (bar) \\1 \\2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 \"foo bar foo bar\" 中前两个单词。模式中的 \\1 和 \\2 匹配字符串的后两个单词。注意 \\1、\\2、\\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )。\n(?:x) | 匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。\nx(?=y)  | 匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat&#124;Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\nx(?!y) | 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。例如，/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’但是不是‘3.141’\nx&#124;y | 匹配‘x’或者‘y’。例如，/green&#124; red/匹配“green apple”中的‘green’和“red apple”中的‘red’\n{n} | n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的'a',但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个'a'。\n{n,m} | n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。\n[xyz] | 一个字符集合。匹配方括号的中任意字符。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转意，不过转意也是起作用的。例如，[abcd] 和[a-d]是一样的。他们都匹配\"brisket\"中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/都匹配“test.i.ng”中得所有字符。\n[^xyz] | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配\"brisket\"中得‘r’，也匹配“chop”中的‘h’。\n[\\b] | 匹配一个退格(U+0008)。（不要和\\b混淆了。）\n\\b | 匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\\b]混淆了）例子：/\\bm/匹配“moon”中得‘m’；/oo\\b/并不匹配\"moon\"中得'oo'，因为'oo'被一个词汇字符'n'紧跟着。/oon\\b/匹配\"moon\"中得'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\\w\\b\\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。\n\\B | 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。例如，/\\B../匹配\"noonday\"中得'oo', 而/y\\B./匹配\"possibly yesterday\"中得’ye‘\n\\cX | 当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，/\\cM/ 匹配字符串中的 control-M (U+000D)。\n\\d | 匹配一个数字。等价于[0-9]。例如， /\\d/ 或者 /[0-9]/ 匹配\"B2 is the suite number.\"中的'2'。\n\\D | 匹配一个非数字字符。等价于[^0-9]。例如， /\\D/ 或者 /[^0-9]/ 匹配\"B2 is the suite number.\"中的'B' 。\n\\f | 匹配一个换页符 (U+000C)。\n\\n | 匹配一个换行符 (U+000A)。\n\\r | 匹配一个回车符 (U+000D)。\n\\s | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如, /\\s\\w*/ 匹配\"foo bar.\"中的' bar'。\n\\S | 匹配一个非空白字符。等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如， /\\S\\w*/ 匹配\"foo bar.\"中的'foo'。\n\\t | 匹配一个水平制表符 (U+0009)。\n\\v | 匹配一个垂直制表符 (U+000B)。\n\\w | 匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3'。\n\\W | 匹配一个非单字字符。等价于[^A-Za-z0-9\\_]。例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%'。\n\\n | 当 n 是一个正整数，一个返回引用到最后一个与有n插入的正值表达式(counting left parentheses)匹配的副字符串。比如 /apple(,)\\sorange\\1/ 匹配\"apple, orange, cherry, peach.\"中的'apple, orange,' 。\n\\0 | 匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。\n\\xhh | 匹配带有两位小数代码（hh）的字符\n\\uhhhh | 匹配带有四位小数代码（hh）的字符\n\n### 在JavaScript中使用正则表达式\n正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。\n\n方法 | 描述\n---|---\nexec | 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。\ntest | 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。\nmatch | 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。\nsearch | 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。\nreplace | 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。\nsplit | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。\n\n当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象）。如果匹配失败，那么exec方法返回null（也就是false）。\n\n下面是一个例子：\n使用exec方法在一个字符串中查找一个匹配。\n``` js\nvar myRe = /d(b+)d/g;\nvar myArray = myRe.exec(\"cdbbdbsbz\");\n```\n通过这些JavaScript，匹配成功后将返回一个数组并且更新正则表达式的属性，如下表所示。\n\n#### 正则表达式执行返回信息\n\n\n对象 | 属性或索引 | 描述 | 在例子中对应的值\n---|------|------|------|---  \nmyArray |  | 匹配到的字符串和所有被记住的子字符串。 | [\"dbbd\", \"bb\"]\n  myArray | index | 在输入的字符串中匹配到的以0开始的索引值。 | 1\n  myArray | input | 初始字符串。 | \"cdbbdbsbz\"\n    myArray | [0] | 匹配到的所有字符串（并不是匹配后记住的字符串）。 | \"dbbd\"\nmyRe | \tlastIndex | 下一个匹配的索引值。（这个属性只有在使用g参数时可用) | 5\nmyRe | \tsource | 模式文本。在正则表达式创建时更新，不执行。 | \"d(b+)d\"\n\n### 通过标志进行高级搜索\n\n正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。\n\n标志 | 描述\n---|---\ng | 全局搜索。\ni | 不区分大小写搜索。\nm | 多行搜索。\ny | 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。\n\n例如，re = /\\w+\\s/g 将创建一个查找一个或多个字符后有一个空格的正则表达式，或者组合起来像此要求的字符串。\n\n\n``` js\n\nvar re = /\\w+\\s/g; //var re = new RegExp(\"\\\\w+\\\\s\", \"g\");\nvar str = \"fee fi fo fum\";\nvar myArray = str.match(re);\nconsole.log(myArray);\n```\n这段代码将输出 :\n\n``` js\n[\"fee \", \"fi \", \"fo \"]\n```","source":"_posts/正则表达式必知必会.md","raw":"---\ntitle: 正则表达式必知必会\ndate: 2016-10-15 19:53:55\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/reg.jpg\ntags:\n\t- 正则\n---\n\n> 正则表达式可以用来完成各种复杂的文本处理工作，更重要的是，它可以在几乎所有的程序设计语言里和几乎所有的计算机平台上使用。\n\n![image](http://img.yanyuanfe.cn/reg.jpg)\n\n<!--more-->\n\n### 正则表达式初识\n\n正则表达式是被用来匹配字符串中的字符组合的模式。在JavaScript中，正则表达式也是对象。这种模式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。\n\n### JavaScript中的正则表达式\n\n在JavaScript中，通过下面两种方法创建一个正则表达式：\n\n使用一个正则表达式字面量，如下所示：\n\n\n``` js\nvar re = /ab+c/;\n```\n\n正则表达式字面量在脚本加载后编译。若你的正则表达式是常量，使用这种方式可以获得更好的性能。\n\n调用RegExp对象的构造函数，如下所示：\n\n\n``` js\nvar re = new RegExp(\"ab+c\");\n```\n\n使用构造函数，提供了对正则表达式运行时的编译。当你知道正则表达式的模式会发生改变， 或者你事先并不了解它的模式或者是从其他地方（比如用户的输入），得到的代码这时比较适合用构造函数的方式。\n\n### 正则表达式特殊符号\n\n\n字符 | 含义\n---|---\n\\ | 匹配将依照下列规则：反斜杠,对于其后的平常被当作字面量的字符，将其转义为特殊字符。比如，/b/匹配了字符'b'.通过在b的前面放一个反斜杠，即用作/\\b/，这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\\*/ 将 '*' 的特殊性移除，从而可以匹配像 \"a*\" 这样的字符串。使用 new RegExp(\"pattern\") 的时候不要忘记将 \\ 进行转义，因为 \\ 在字符串里面也是一个转义字符。\n^ | 匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 \"an A\" 中的 'A'，但是会匹配 \"An E\" 中的 'A'。当 '^' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合 一节有详细介绍和示例。\n$ | 匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 \"eater\" 中的 't'，但是会匹配 \"eat\" 中的 't'。\n* | 匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 \"A ghost boooooed\" 中的 'booooo' 和 \"A bird warbled\" 中的 'b'，但是在 \"A goat grunted\" 中将不会匹配任何东西。\n+| 匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 \"candy\" 中的 'a'，和在 \"caaaaaaandy\" 中所有的 'a'。\n? | 匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 \"angel\" 中的 'el'，和 \"angle\" 中的 'le' 以及\"oslo' 中的'l'。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1\"。还可以运用于向前断言，在本表格的 x(?=y) 和 x(?!y) 中有描述。\n. | （小数点）匹配除了换行符（\\n）之外的任何单个字符。例如，/.n/将会匹配 \"nay, an apple is on the tree\" 中的 'an' 和 'on'，但是不会匹配 'nay'。\n(x) | 匹配 'x' 并且记住匹配项，就像下面的例子展示的那样。括号被称为 **捕获括号**。模式 /(foo) (bar) \\1 \\2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 \"foo bar foo bar\" 中前两个单词。模式中的 \\1 和 \\2 匹配字符串的后两个单词。注意 \\1、\\2、\\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )。\n(?:x) | 匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。\nx(?=y)  | 匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat&#124;Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\nx(?!y) | 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。例如，/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’但是不是‘3.141’\nx&#124;y | 匹配‘x’或者‘y’。例如，/green&#124; red/匹配“green apple”中的‘green’和“red apple”中的‘red’\n{n} | n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的'a',但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个'a'。\n{n,m} | n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。\n[xyz] | 一个字符集合。匹配方括号的中任意字符。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转意，不过转意也是起作用的。例如，[abcd] 和[a-d]是一样的。他们都匹配\"brisket\"中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/都匹配“test.i.ng”中得所有字符。\n[^xyz] | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配\"brisket\"中得‘r’，也匹配“chop”中的‘h’。\n[\\b] | 匹配一个退格(U+0008)。（不要和\\b混淆了。）\n\\b | 匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\\b]混淆了）例子：/\\bm/匹配“moon”中得‘m’；/oo\\b/并不匹配\"moon\"中得'oo'，因为'oo'被一个词汇字符'n'紧跟着。/oon\\b/匹配\"moon\"中得'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\\w\\b\\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。\n\\B | 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。例如，/\\B../匹配\"noonday\"中得'oo', 而/y\\B./匹配\"possibly yesterday\"中得’ye‘\n\\cX | 当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，/\\cM/ 匹配字符串中的 control-M (U+000D)。\n\\d | 匹配一个数字。等价于[0-9]。例如， /\\d/ 或者 /[0-9]/ 匹配\"B2 is the suite number.\"中的'2'。\n\\D | 匹配一个非数字字符。等价于[^0-9]。例如， /\\D/ 或者 /[^0-9]/ 匹配\"B2 is the suite number.\"中的'B' 。\n\\f | 匹配一个换页符 (U+000C)。\n\\n | 匹配一个换行符 (U+000A)。\n\\r | 匹配一个回车符 (U+000D)。\n\\s | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如, /\\s\\w*/ 匹配\"foo bar.\"中的' bar'。\n\\S | 匹配一个非空白字符。等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如， /\\S\\w*/ 匹配\"foo bar.\"中的'foo'。\n\\t | 匹配一个水平制表符 (U+0009)。\n\\v | 匹配一个垂直制表符 (U+000B)。\n\\w | 匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3'。\n\\W | 匹配一个非单字字符。等价于[^A-Za-z0-9\\_]。例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%'。\n\\n | 当 n 是一个正整数，一个返回引用到最后一个与有n插入的正值表达式(counting left parentheses)匹配的副字符串。比如 /apple(,)\\sorange\\1/ 匹配\"apple, orange, cherry, peach.\"中的'apple, orange,' 。\n\\0 | 匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。\n\\xhh | 匹配带有两位小数代码（hh）的字符\n\\uhhhh | 匹配带有四位小数代码（hh）的字符\n\n### 在JavaScript中使用正则表达式\n正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。\n\n方法 | 描述\n---|---\nexec | 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。\ntest | 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。\nmatch | 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。\nsearch | 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。\nreplace | 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。\nsplit | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。\n\n当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象）。如果匹配失败，那么exec方法返回null（也就是false）。\n\n下面是一个例子：\n使用exec方法在一个字符串中查找一个匹配。\n``` js\nvar myRe = /d(b+)d/g;\nvar myArray = myRe.exec(\"cdbbdbsbz\");\n```\n通过这些JavaScript，匹配成功后将返回一个数组并且更新正则表达式的属性，如下表所示。\n\n#### 正则表达式执行返回信息\n\n\n对象 | 属性或索引 | 描述 | 在例子中对应的值\n---|------|------|------|---  \nmyArray |  | 匹配到的字符串和所有被记住的子字符串。 | [\"dbbd\", \"bb\"]\n  myArray | index | 在输入的字符串中匹配到的以0开始的索引值。 | 1\n  myArray | input | 初始字符串。 | \"cdbbdbsbz\"\n    myArray | [0] | 匹配到的所有字符串（并不是匹配后记住的字符串）。 | \"dbbd\"\nmyRe | \tlastIndex | 下一个匹配的索引值。（这个属性只有在使用g参数时可用) | 5\nmyRe | \tsource | 模式文本。在正则表达式创建时更新，不执行。 | \"d(b+)d\"\n\n### 通过标志进行高级搜索\n\n正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。\n\n标志 | 描述\n---|---\ng | 全局搜索。\ni | 不区分大小写搜索。\nm | 多行搜索。\ny | 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。\n\n例如，re = /\\w+\\s/g 将创建一个查找一个或多个字符后有一个空格的正则表达式，或者组合起来像此要求的字符串。\n\n\n``` js\n\nvar re = /\\w+\\s/g; //var re = new RegExp(\"\\\\w+\\\\s\", \"g\");\nvar str = \"fee fi fo fum\";\nvar myArray = str.match(re);\nconsole.log(myArray);\n```\n这段代码将输出 :\n\n``` js\n[\"fee \", \"fi \", \"fo \"]\n```","slug":"正则表达式必知必会","published":1,"updated":"2020-07-16T13:56:47.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pceno9001up70vpq6f2i8b","content":"<blockquote>\n<p>正则表达式可以用来完成各种复杂的文本处理工作，更重要的是，它可以在几乎所有的程序设计语言里和几乎所有的计算机平台上使用。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/reg.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"正则表达式初识\"><a href=\"#正则表达式初识\" class=\"headerlink\" title=\"正则表达式初识\"></a>正则表达式初识</h3><p>正则表达式是被用来匹配字符串中的字符组合的模式。在JavaScript中，正则表达式也是对象。这种模式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。</p>\n<h3 id=\"JavaScript中的正则表达式\"><a href=\"#JavaScript中的正则表达式\" class=\"headerlink\" title=\"JavaScript中的正则表达式\"></a>JavaScript中的正则表达式</h3><p>在JavaScript中，通过下面两种方法创建一个正则表达式：</p>\n<p>使用一个正则表达式字面量，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/ab+c/</span>;</span><br></pre></td></tr></table></figure>\n<p>正则表达式字面量在脚本加载后编译。若你的正则表达式是常量，使用这种方式可以获得更好的性能。</p>\n<p>调用RegExp对象的构造函数，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"ab+c\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用构造函数，提供了对正则表达式运行时的编译。当你知道正则表达式的模式会发生改变， 或者你事先并不了解它的模式或者是从其他地方（比如用户的输入），得到的代码这时比较适合用构造函数的方式。</p>\n<h3 id=\"正则表达式特殊符号\"><a href=\"#正则表达式特殊符号\" class=\"headerlink\" title=\"正则表达式特殊符号\"></a>正则表达式特殊符号</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\</td>\n<td>匹配将依照下列规则：反斜杠,对于其后的平常被当作字面量的字符，将其转义为特殊字符。比如，/b/匹配了字符’b’.通过在b的前面放一个反斜杠，即用作/\\b/，这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a<em>/ 代表会匹配 0 个或者多个 a。相反，模式 /a\\</em>/ 将 ‘<em>‘ 的特殊性移除，从而可以匹配像 “a</em>“ 这样的字符串。使用 new RegExp(“pattern”) 的时候不要忘记将 \\ 进行转义，因为 \\ 在字符串里面也是一个转义字符。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合 一节有详细介绍和示例。</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。还可以运用于向前断言，在本表格的 x(?=y) 和 x(?!y) 中有描述。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>（小数点）匹配除了换行符（\\n）之外的任何单个字符。例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</td>\n</tr>\n<tr>\n<td>(x)</td>\n<td>匹配 ‘x’ 并且记住匹配项，就像下面的例子展示的那样。括号被称为 <strong>捕获括号</strong>。模式 /(foo) (bar) \\1 \\2/ 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \\1 和 \\2 匹配字符串的后两个单词。注意 \\1、\\2、\\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，’bar foo’.replace( /(…) (…)/, ‘$2 $1’ )。</td>\n</tr>\n<tr>\n<td>(?:x)</td>\n<td>匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。</td>\n</tr>\n<tr>\n<td>x(?=y)</td>\n<td>匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat&#124;Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td>\n</tr>\n<tr>\n<td>x(?!y)</td>\n<td>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’</td>\n</tr>\n<tr>\n<td>x&#124;y</td>\n<td>匹配‘x’或者‘y’。例如，/green&#124; red/匹配“green apple”中的‘green’和“red apple”中的‘red’</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个’a’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。</td>\n</tr>\n<tr>\n<td>[xyz]</td>\n<td>一个字符集合。匹配方括号的中任意字符。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转意，不过转意也是起作用的。例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/都匹配“test.i.ng”中得所有字符。</td>\n</tr>\n<tr>\n<td>[^xyz]</td>\n<td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中得‘r’，也匹配“chop”中的‘h’。</td>\n</tr>\n<tr>\n<td>[\\b]</td>\n<td>匹配一个退格(U+0008)。（不要和\\b混淆了。）</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\\b]混淆了）例子：/\\bm/匹配“moon”中得‘m’；/oo\\b/并不匹配”moon”中得’oo’，因为’oo’被一个词汇字符’n’紧跟着。/oon\\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\\w\\b\\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。例如，/\\B../匹配”noonday”中得’oo’, 而/y\\B./匹配”possibly yesterday”中得’ye‘</td>\n</tr>\n<tr>\n<td>\\cX</td>\n<td>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，/\\cM/ 匹配字符串中的 control-M (U+000D)。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字。等价于[0-9]。例如， /\\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符。等价于[^0-9]。例如， /\\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符 (U+000C)。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符 (U+000A)。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符 (U+000D)。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如, /\\s\\w*/ 匹配”foo bar.”中的’ bar’。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配一个非空白字符。等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如， /\\S\\w*/ 匹配”foo bar.”中的’foo’。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个水平制表符 (U+0009)。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符 (U+000B)。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配一个非单字字符。等价于[^A-Za-z0-9_]。例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>当 n 是一个正整数，一个返回引用到最后一个与有n插入的正值表达式(counting left parentheses)匹配的副字符串。比如 /apple(,)\\sorange\\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。</digits></td>\n</tr>\n<tr>\n<td>\\xhh</td>\n<td>匹配带有两位小数代码（hh）的字符</td>\n</tr>\n<tr>\n<td>\\uhhhh</td>\n<td>匹配带有四位小数代码（hh）的字符</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"在JavaScript中使用正则表达式\"><a href=\"#在JavaScript中使用正则表达式\" class=\"headerlink\" title=\"在JavaScript中使用正则表达式\"></a>在JavaScript中使用正则表达式</h3><p>正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>exec</td>\n<td>一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。</td>\n</tr>\n<tr>\n<td>test</td>\n<td>一个在字符串中测试是否匹配的RegExp方法，它返回true或false。</td>\n</tr>\n<tr>\n<td>match</td>\n<td>一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。</td>\n</tr>\n<tr>\n<td>search</td>\n<td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>\n</tr>\n<tr>\n<td>replace</td>\n<td>一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td>\n</tr>\n<tr>\n<td>split</td>\n<td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。</td>\n</tr>\n</tbody>\n</table>\n<p>当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象）。如果匹配失败，那么exec方法返回null（也就是false）。</p>\n<p>下面是一个例子：<br>使用exec方法在一个字符串中查找一个匹配。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myRe = <span class=\"regexp\">/d(b+)d/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray = myRe.exec(<span class=\"string\">\"cdbbdbsbz\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>通过这些JavaScript，匹配成功后将返回一个数组并且更新正则表达式的属性，如下表所示。</p>\n<h4 id=\"正则表达式执行返回信息\"><a href=\"#正则表达式执行返回信息\" class=\"headerlink\" title=\"正则表达式执行返回信息\"></a>正则表达式执行返回信息</h4><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>属性或索引</th>\n<th>描述</th>\n<th>在例子中对应的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>myArray</td>\n<td></td>\n<td>匹配到的字符串和所有被记住的子字符串。</td>\n<td>[“dbbd”, “bb”]</td>\n</tr>\n<tr>\n<td>  myArray</td>\n<td>index</td>\n<td>在输入的字符串中匹配到的以0开始的索引值。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>  myArray</td>\n<td>input</td>\n<td>初始字符串。</td>\n<td>“cdbbdbsbz”</td>\n</tr>\n<tr>\n<td>    myArray</td>\n<td>[0]</td>\n<td>匹配到的所有字符串（并不是匹配后记住的字符串）。</td>\n<td>“dbbd”</td>\n</tr>\n<tr>\n<td>myRe</td>\n<td>lastIndex</td>\n<td>下一个匹配的索引值。（这个属性只有在使用g参数时可用)</td>\n<td>5</td>\n</tr>\n<tr>\n<td>myRe</td>\n<td>source</td>\n<td>模式文本。在正则表达式创建时更新，不执行。</td>\n<td>“d(b+)d”</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"通过标志进行高级搜索\"><a href=\"#通过标志进行高级搜索\" class=\"headerlink\" title=\"通过标志进行高级搜索\"></a>通过标志进行高级搜索</h3><p>正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。</p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>g</td>\n<td>全局搜索。</td>\n</tr>\n<tr>\n<td>i</td>\n<td>不区分大小写搜索。</td>\n</tr>\n<tr>\n<td>m</td>\n<td>多行搜索。</td>\n</tr>\n<tr>\n<td>y</td>\n<td>执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。</td>\n</tr>\n</tbody>\n</table>\n<p>例如，re = /\\w+\\s/g 将创建一个查找一个或多个字符后有一个空格的正则表达式，或者组合起来像此要求的字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\w+\\s/g</span>; <span class=\"comment\">//var re = new RegExp(\"\\\\w+\\\\s\", \"g\");</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"fee fi fo fum\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray = str.match(re);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray);</span><br></pre></td></tr></table></figure>\n<p>这段代码将输出 :</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"fee \"</span>, <span class=\"string\">\"fi \"</span>, <span class=\"string\">\"fo \"</span>]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>正则表达式可以用来完成各种复杂的文本处理工作，更重要的是，它可以在几乎所有的程序设计语言里和几乎所有的计算机平台上使用。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/reg.jpg\" alt=\"image\"></p>","more":"<h3 id=\"正则表达式初识\"><a href=\"#正则表达式初识\" class=\"headerlink\" title=\"正则表达式初识\"></a>正则表达式初识</h3><p>正则表达式是被用来匹配字符串中的字符组合的模式。在JavaScript中，正则表达式也是对象。这种模式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。</p>\n<h3 id=\"JavaScript中的正则表达式\"><a href=\"#JavaScript中的正则表达式\" class=\"headerlink\" title=\"JavaScript中的正则表达式\"></a>JavaScript中的正则表达式</h3><p>在JavaScript中，通过下面两种方法创建一个正则表达式：</p>\n<p>使用一个正则表达式字面量，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/ab+c/</span>;</span><br></pre></td></tr></table></figure>\n<p>正则表达式字面量在脚本加载后编译。若你的正则表达式是常量，使用这种方式可以获得更好的性能。</p>\n<p>调用RegExp对象的构造函数，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"ab+c\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用构造函数，提供了对正则表达式运行时的编译。当你知道正则表达式的模式会发生改变， 或者你事先并不了解它的模式或者是从其他地方（比如用户的输入），得到的代码这时比较适合用构造函数的方式。</p>\n<h3 id=\"正则表达式特殊符号\"><a href=\"#正则表达式特殊符号\" class=\"headerlink\" title=\"正则表达式特殊符号\"></a>正则表达式特殊符号</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\</td>\n<td>匹配将依照下列规则：反斜杠,对于其后的平常被当作字面量的字符，将其转义为特殊字符。比如，/b/匹配了字符’b’.通过在b的前面放一个反斜杠，即用作/\\b/，这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a<em>/ 代表会匹配 0 个或者多个 a。相反，模式 /a\\</em>/ 将 ‘<em>‘ 的特殊性移除，从而可以匹配像 “a</em>“ 这样的字符串。使用 new RegExp(“pattern”) 的时候不要忘记将 \\ 进行转义，因为 \\ 在字符串里面也是一个转义字符。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合 一节有详细介绍和示例。</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。还可以运用于向前断言，在本表格的 x(?=y) 和 x(?!y) 中有描述。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>（小数点）匹配除了换行符（\\n）之外的任何单个字符。例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</td>\n</tr>\n<tr>\n<td>(x)</td>\n<td>匹配 ‘x’ 并且记住匹配项，就像下面的例子展示的那样。括号被称为 <strong>捕获括号</strong>。模式 /(foo) (bar) \\1 \\2/ 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \\1 和 \\2 匹配字符串的后两个单词。注意 \\1、\\2、\\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，’bar foo’.replace( /(…) (…)/, ‘$2 $1’ )。</td>\n</tr>\n<tr>\n<td>(?:x)</td>\n<td>匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。</td>\n</tr>\n<tr>\n<td>x(?=y)</td>\n<td>匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat&#124;Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td>\n</tr>\n<tr>\n<td>x(?!y)</td>\n<td>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’</td>\n</tr>\n<tr>\n<td>x&#124;y</td>\n<td>匹配‘x’或者‘y’。例如，/green&#124; red/匹配“green apple”中的‘green’和“red apple”中的‘red’</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个’a’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。</td>\n</tr>\n<tr>\n<td>[xyz]</td>\n<td>一个字符集合。匹配方括号的中任意字符。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转意，不过转意也是起作用的。例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/都匹配“test.i.ng”中得所有字符。</td>\n</tr>\n<tr>\n<td>[^xyz]</td>\n<td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中得‘r’，也匹配“chop”中的‘h’。</td>\n</tr>\n<tr>\n<td>[\\b]</td>\n<td>匹配一个退格(U+0008)。（不要和\\b混淆了。）</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\\b]混淆了）例子：/\\bm/匹配“moon”中得‘m’；/oo\\b/并不匹配”moon”中得’oo’，因为’oo’被一个词汇字符’n’紧跟着。/oon\\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\\w\\b\\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。例如，/\\B../匹配”noonday”中得’oo’, 而/y\\B./匹配”possibly yesterday”中得’ye‘</td>\n</tr>\n<tr>\n<td>\\cX</td>\n<td>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，/\\cM/ 匹配字符串中的 control-M (U+000D)。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字。等价于[0-9]。例如， /\\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符。等价于[^0-9]。例如， /\\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符 (U+000C)。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符 (U+000A)。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符 (U+000D)。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如, /\\s\\w*/ 匹配”foo bar.”中的’ bar’。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配一个非空白字符。等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如， /\\S\\w*/ 匹配”foo bar.”中的’foo’。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个水平制表符 (U+0009)。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符 (U+000B)。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配一个非单字字符。等价于[^A-Za-z0-9_]。例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>当 n 是一个正整数，一个返回引用到最后一个与有n插入的正值表达式(counting left parentheses)匹配的副字符串。比如 /apple(,)\\sorange\\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。</digits></td>\n</tr>\n<tr>\n<td>\\xhh</td>\n<td>匹配带有两位小数代码（hh）的字符</td>\n</tr>\n<tr>\n<td>\\uhhhh</td>\n<td>匹配带有四位小数代码（hh）的字符</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"在JavaScript中使用正则表达式\"><a href=\"#在JavaScript中使用正则表达式\" class=\"headerlink\" title=\"在JavaScript中使用正则表达式\"></a>在JavaScript中使用正则表达式</h3><p>正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>exec</td>\n<td>一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。</td>\n</tr>\n<tr>\n<td>test</td>\n<td>一个在字符串中测试是否匹配的RegExp方法，它返回true或false。</td>\n</tr>\n<tr>\n<td>match</td>\n<td>一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。</td>\n</tr>\n<tr>\n<td>search</td>\n<td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>\n</tr>\n<tr>\n<td>replace</td>\n<td>一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td>\n</tr>\n<tr>\n<td>split</td>\n<td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。</td>\n</tr>\n</tbody>\n</table>\n<p>当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象）。如果匹配失败，那么exec方法返回null（也就是false）。</p>\n<p>下面是一个例子：<br>使用exec方法在一个字符串中查找一个匹配。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myRe = <span class=\"regexp\">/d(b+)d/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray = myRe.exec(<span class=\"string\">\"cdbbdbsbz\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>通过这些JavaScript，匹配成功后将返回一个数组并且更新正则表达式的属性，如下表所示。</p>\n<h4 id=\"正则表达式执行返回信息\"><a href=\"#正则表达式执行返回信息\" class=\"headerlink\" title=\"正则表达式执行返回信息\"></a>正则表达式执行返回信息</h4><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>属性或索引</th>\n<th>描述</th>\n<th>在例子中对应的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>myArray</td>\n<td></td>\n<td>匹配到的字符串和所有被记住的子字符串。</td>\n<td>[“dbbd”, “bb”]</td>\n</tr>\n<tr>\n<td>  myArray</td>\n<td>index</td>\n<td>在输入的字符串中匹配到的以0开始的索引值。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>  myArray</td>\n<td>input</td>\n<td>初始字符串。</td>\n<td>“cdbbdbsbz”</td>\n</tr>\n<tr>\n<td>    myArray</td>\n<td>[0]</td>\n<td>匹配到的所有字符串（并不是匹配后记住的字符串）。</td>\n<td>“dbbd”</td>\n</tr>\n<tr>\n<td>myRe</td>\n<td>lastIndex</td>\n<td>下一个匹配的索引值。（这个属性只有在使用g参数时可用)</td>\n<td>5</td>\n</tr>\n<tr>\n<td>myRe</td>\n<td>source</td>\n<td>模式文本。在正则表达式创建时更新，不执行。</td>\n<td>“d(b+)d”</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"通过标志进行高级搜索\"><a href=\"#通过标志进行高级搜索\" class=\"headerlink\" title=\"通过标志进行高级搜索\"></a>通过标志进行高级搜索</h3><p>正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。</p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>g</td>\n<td>全局搜索。</td>\n</tr>\n<tr>\n<td>i</td>\n<td>不区分大小写搜索。</td>\n</tr>\n<tr>\n<td>m</td>\n<td>多行搜索。</td>\n</tr>\n<tr>\n<td>y</td>\n<td>执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。</td>\n</tr>\n</tbody>\n</table>\n<p>例如，re = /\\w+\\s/g 将创建一个查找一个或多个字符后有一个空格的正则表达式，或者组合起来像此要求的字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\w+\\s/g</span>; <span class=\"comment\">//var re = new RegExp(\"\\\\w+\\\\s\", \"g\");</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"fee fi fo fum\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray = str.match(re);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray);</span><br></pre></td></tr></table></figure>\n<p>这段代码将输出 :</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"fee \"</span>, <span class=\"string\">\"fi \"</span>, <span class=\"string\">\"fo \"</span>]</span><br></pre></td></tr></table></figure>"},{"title":"浅析HTTP缓存","date":"2018-08-22T14:18:58.000Z","banner":"http://img.yanyuanfe.cn/photo-1462331940025-496dfbfc7564.jpeg","_content":"> HTTP缓存，面试必问，总结了一波。\n\n![image](http://img.yanyuanfe.cn/photo-1462331940025-496dfbfc7564.jpeg)\n\n<!--more-->\n\n### 强缓存和协商缓存\n浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：\n\n浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信。\n\n如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。\n\n强缓存与协商缓存的区别\n\n\n 类型 | 获取资源形式 | 状态码 | 发送请求到服务器\n---|--- |--- |--- \n强缓存 | 从缓存 |  200（from cache) | 否，直接从缓存取\n协商缓存 | 从缓存取 | 304（not modified）| 是，正如其名，通过服务器来告知缓存是否可用\n\n\n### Expires\n在HTTP1.0版本，强缓存通过Expires实现。\nExpires是HTTP的响应头部，标识未来资源会过期的时间，在响应HTTP请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，如果发起请求的时间超过Expires的时间则会发送请求到服务器重新获取资源。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大。\n\n### Cache-Control\n在HTTP 1.1版开始，强缓存使用响应头Cache-Control: max-age=秒替代。\nCache-Control与Expires的作用一致，都是标识当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器获取数据。只是Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。\n\n### Last-Modifield Date\n在HTTP1.0版本中，协商缓存通过Last-Modifield实现。Last-Modifield标识资源的最新修改时间。当第一次请求资源时，服务器返回资源并在响应头中加入资源的最新修改时间Last-Modifield。再次请求时，浏览器在请求头中带上If-Modifield-Since将最新修改日期传回到服务器以进行比较。如果服务器上资源的最新修改日期与浏览器传回的If-Modifield-Since值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源，并且更新Last-Modifield。\n\n### Entity Tags\n在HTTP1.0版本中，协商缓存通过ETag实现。ETag标识资源的唯一性。当第一次请求资源时，服务器返回资源并在响应头中加入ETag。再次请求时，浏览器在请求头中带上If-None-Match将ETag信息传回到服务器以进行比较。如果服务器上资源标识与浏览器传回的If-None-Match值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源和新的ETag。\n\nIf-None-Match比If-Modifield-Since具有更高的优先级。根据HTTP规范，如果请求中同时出现了这两个头，则原始服务器禁止返回304。\n\nLast-Modified与ETag一起使用时，服务器会优先验证ETag。\n\nHTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：\n1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\n1. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存\n1. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形\n\n\n### 总结\n强制缓存只有首次请求才会与服务端进行通信，读取缓存时不会发送请求，响应状态码为200（from disk cache或者from memory cache），HTTP1.1版本的Cache-Control其优先级高于HTTP1.0的Expires。\n协商缓存每次请求都会与服务器进行通信，第一次请求数据和标识，第二次询问服务器是否有资源更新。如果命中缓存，响应状态码为304，HTTP1.1版本的ETag优先级高于HTTP1.0的Last-Modifield。\n\n\n### 相关HTTP头\n\nCache-Control：\n值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age\n各个消息中的指令含义如下：\n- Public指示响应可被任何缓存区缓存。\n- Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。\n- no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~\n- no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。\n- max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。\n- min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n- max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\nLast-Modified/If-Modified-Since要配合Cache-Control使用。\n\nLast-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。\nIf-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。\n\nEtag/If-None-Match也要配合Cache-Control使用。\n\nEtag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\nIf-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。\n","source":"_posts/浅析HTTP缓存.md","raw":"---\ntitle: 浅析HTTP缓存\ndate: 2018-8-22 22:18:58\nbanner: http://img.yanyuanfe.cn/photo-1462331940025-496dfbfc7564.jpeg\ntags:\n\t- HTTP\n---\n> HTTP缓存，面试必问，总结了一波。\n\n![image](http://img.yanyuanfe.cn/photo-1462331940025-496dfbfc7564.jpeg)\n\n<!--more-->\n\n### 强缓存和协商缓存\n浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：\n\n浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信。\n\n如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。\n\n强缓存与协商缓存的区别\n\n\n 类型 | 获取资源形式 | 状态码 | 发送请求到服务器\n---|--- |--- |--- \n强缓存 | 从缓存 |  200（from cache) | 否，直接从缓存取\n协商缓存 | 从缓存取 | 304（not modified）| 是，正如其名，通过服务器来告知缓存是否可用\n\n\n### Expires\n在HTTP1.0版本，强缓存通过Expires实现。\nExpires是HTTP的响应头部，标识未来资源会过期的时间，在响应HTTP请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，如果发起请求的时间超过Expires的时间则会发送请求到服务器重新获取资源。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大。\n\n### Cache-Control\n在HTTP 1.1版开始，强缓存使用响应头Cache-Control: max-age=秒替代。\nCache-Control与Expires的作用一致，都是标识当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器获取数据。只是Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。\n\n### Last-Modifield Date\n在HTTP1.0版本中，协商缓存通过Last-Modifield实现。Last-Modifield标识资源的最新修改时间。当第一次请求资源时，服务器返回资源并在响应头中加入资源的最新修改时间Last-Modifield。再次请求时，浏览器在请求头中带上If-Modifield-Since将最新修改日期传回到服务器以进行比较。如果服务器上资源的最新修改日期与浏览器传回的If-Modifield-Since值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源，并且更新Last-Modifield。\n\n### Entity Tags\n在HTTP1.0版本中，协商缓存通过ETag实现。ETag标识资源的唯一性。当第一次请求资源时，服务器返回资源并在响应头中加入ETag。再次请求时，浏览器在请求头中带上If-None-Match将ETag信息传回到服务器以进行比较。如果服务器上资源标识与浏览器传回的If-None-Match值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源和新的ETag。\n\nIf-None-Match比If-Modifield-Since具有更高的优先级。根据HTTP规范，如果请求中同时出现了这两个头，则原始服务器禁止返回304。\n\nLast-Modified与ETag一起使用时，服务器会优先验证ETag。\n\nHTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：\n1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\n1. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存\n1. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形\n\n\n### 总结\n强制缓存只有首次请求才会与服务端进行通信，读取缓存时不会发送请求，响应状态码为200（from disk cache或者from memory cache），HTTP1.1版本的Cache-Control其优先级高于HTTP1.0的Expires。\n协商缓存每次请求都会与服务器进行通信，第一次请求数据和标识，第二次询问服务器是否有资源更新。如果命中缓存，响应状态码为304，HTTP1.1版本的ETag优先级高于HTTP1.0的Last-Modifield。\n\n\n### 相关HTTP头\n\nCache-Control：\n值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age\n各个消息中的指令含义如下：\n- Public指示响应可被任何缓存区缓存。\n- Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。\n- no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~\n- no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。\n- max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。\n- min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n- max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\nLast-Modified/If-Modified-Since要配合Cache-Control使用。\n\nLast-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。\nIf-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。\n\nEtag/If-None-Match也要配合Cache-Control使用。\n\nEtag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\nIf-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。\n","slug":"浅析HTTP缓存","published":1,"updated":"2020-07-16T13:56:47.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenoa001xp70vf8ucgh8b","content":"<blockquote>\n<p>HTTP缓存，面试必问，总结了一波。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/photo-1462331940025-496dfbfc7564.jpeg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"强缓存和协商缓存\"><a href=\"#强缓存和协商缓存\" class=\"headerlink\" title=\"强缓存和协商缓存\"></a>强缓存和协商缓存</h3><p>浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：</p>\n<p>浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信。</p>\n<p>如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。</p>\n<p>强缓存与协商缓存的区别</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>获取资源形式</th>\n<th>状态码</th>\n<th>发送请求到服务器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强缓存</td>\n<td>从缓存</td>\n<td>200（from cache)</td>\n<td>否，直接从缓存取</td>\n</tr>\n<tr>\n<td>协商缓存</td>\n<td>从缓存取</td>\n<td>304（not modified）</td>\n<td>是，正如其名，通过服务器来告知缓存是否可用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h3><p>在HTTP1.0版本，强缓存通过Expires实现。<br>Expires是HTTP的响应头部，标识未来资源会过期的时间，在响应HTTP请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，如果发起请求的时间超过Expires的时间则会发送请求到服务器重新获取资源。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><p>在HTTP 1.1版开始，强缓存使用响应头Cache-Control: max-age=秒替代。<br>Cache-Control与Expires的作用一致，都是标识当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器获取数据。只是Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p>\n<h3 id=\"Last-Modifield-Date\"><a href=\"#Last-Modifield-Date\" class=\"headerlink\" title=\"Last-Modifield Date\"></a>Last-Modifield Date</h3><p>在HTTP1.0版本中，协商缓存通过Last-Modifield实现。Last-Modifield标识资源的最新修改时间。当第一次请求资源时，服务器返回资源并在响应头中加入资源的最新修改时间Last-Modifield。再次请求时，浏览器在请求头中带上If-Modifield-Since将最新修改日期传回到服务器以进行比较。如果服务器上资源的最新修改日期与浏览器传回的If-Modifield-Since值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源，并且更新Last-Modifield。</p>\n<h3 id=\"Entity-Tags\"><a href=\"#Entity-Tags\" class=\"headerlink\" title=\"Entity Tags\"></a>Entity Tags</h3><p>在HTTP1.0版本中，协商缓存通过ETag实现。ETag标识资源的唯一性。当第一次请求资源时，服务器返回资源并在响应头中加入ETag。再次请求时，浏览器在请求头中带上If-None-Match将ETag信息传回到服务器以进行比较。如果服务器上资源标识与浏览器传回的If-None-Match值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源和新的ETag。</p>\n<p>If-None-Match比If-Modifield-Since具有更高的优先级。根据HTTP规范，如果请求中同时出现了这两个头，则原始服务器禁止返回304。</p>\n<p>Last-Modified与ETag一起使用时，服务器会优先验证ETag。</p>\n<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>\n<ol>\n<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>\n<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>\n<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>强制缓存只有首次请求才会与服务端进行通信，读取缓存时不会发送请求，响应状态码为200（from disk cache或者from memory cache），HTTP1.1版本的Cache-Control其优先级高于HTTP1.0的Expires。<br>协商缓存每次请求都会与服务器进行通信，第一次请求数据和标识，第二次询问服务器是否有资源更新。如果命中缓存，响应状态码为304，HTTP1.1版本的ETag优先级高于HTTP1.0的Last-Modifield。</p>\n<h3 id=\"相关HTTP头\"><a href=\"#相关HTTP头\" class=\"headerlink\" title=\"相关HTTP头\"></a>相关HTTP头</h3><p>Cache-Control：<br>值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age<br>各个消息中的指令含义如下：</p>\n<ul>\n<li>Public指示响应可被任何缓存区缓存。</li>\n<li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>\n<li>no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~</li>\n<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。</li>\n<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>\n<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>\n<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>\n</ul>\n<p>Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>\n<p>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p>\n<p>Etag/If-None-Match也要配合Cache-Control使用。</p>\n<p>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>HTTP缓存，面试必问，总结了一波。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/photo-1462331940025-496dfbfc7564.jpeg\" alt=\"image\"></p>","more":"<h3 id=\"强缓存和协商缓存\"><a href=\"#强缓存和协商缓存\" class=\"headerlink\" title=\"强缓存和协商缓存\"></a>强缓存和协商缓存</h3><p>浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：</p>\n<p>浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信。</p>\n<p>如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。</p>\n<p>强缓存与协商缓存的区别</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>获取资源形式</th>\n<th>状态码</th>\n<th>发送请求到服务器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强缓存</td>\n<td>从缓存</td>\n<td>200（from cache)</td>\n<td>否，直接从缓存取</td>\n</tr>\n<tr>\n<td>协商缓存</td>\n<td>从缓存取</td>\n<td>304（not modified）</td>\n<td>是，正如其名，通过服务器来告知缓存是否可用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h3><p>在HTTP1.0版本，强缓存通过Expires实现。<br>Expires是HTTP的响应头部，标识未来资源会过期的时间，在响应HTTP请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，如果发起请求的时间超过Expires的时间则会发送请求到服务器重新获取资源。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><p>在HTTP 1.1版开始，强缓存使用响应头Cache-Control: max-age=秒替代。<br>Cache-Control与Expires的作用一致，都是标识当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器获取数据。只是Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p>\n<h3 id=\"Last-Modifield-Date\"><a href=\"#Last-Modifield-Date\" class=\"headerlink\" title=\"Last-Modifield Date\"></a>Last-Modifield Date</h3><p>在HTTP1.0版本中，协商缓存通过Last-Modifield实现。Last-Modifield标识资源的最新修改时间。当第一次请求资源时，服务器返回资源并在响应头中加入资源的最新修改时间Last-Modifield。再次请求时，浏览器在请求头中带上If-Modifield-Since将最新修改日期传回到服务器以进行比较。如果服务器上资源的最新修改日期与浏览器传回的If-Modifield-Since值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源，并且更新Last-Modifield。</p>\n<h3 id=\"Entity-Tags\"><a href=\"#Entity-Tags\" class=\"headerlink\" title=\"Entity Tags\"></a>Entity Tags</h3><p>在HTTP1.0版本中，协商缓存通过ETag实现。ETag标识资源的唯一性。当第一次请求资源时，服务器返回资源并在响应头中加入ETag。再次请求时，浏览器在请求头中带上If-None-Match将ETag信息传回到服务器以进行比较。如果服务器上资源标识与浏览器传回的If-None-Match值匹配，会返回一个304响应，浏览器读取本地缓存，否则，服务器返回新的资源和新的ETag。</p>\n<p>If-None-Match比If-Modifield-Since具有更高的优先级。根据HTTP规范，如果请求中同时出现了这两个头，则原始服务器禁止返回304。</p>\n<p>Last-Modified与ETag一起使用时，服务器会优先验证ETag。</p>\n<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>\n<ol>\n<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>\n<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>\n<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>强制缓存只有首次请求才会与服务端进行通信，读取缓存时不会发送请求，响应状态码为200（from disk cache或者from memory cache），HTTP1.1版本的Cache-Control其优先级高于HTTP1.0的Expires。<br>协商缓存每次请求都会与服务器进行通信，第一次请求数据和标识，第二次询问服务器是否有资源更新。如果命中缓存，响应状态码为304，HTTP1.1版本的ETag优先级高于HTTP1.0的Last-Modifield。</p>\n<h3 id=\"相关HTTP头\"><a href=\"#相关HTTP头\" class=\"headerlink\" title=\"相关HTTP头\"></a>相关HTTP头</h3><p>Cache-Control：<br>值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age<br>各个消息中的指令含义如下：</p>\n<ul>\n<li>Public指示响应可被任何缓存区缓存。</li>\n<li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>\n<li>no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~</li>\n<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。</li>\n<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>\n<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>\n<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>\n</ul>\n<p>Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>\n<p>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p>\n<p>Etag/If-None-Match也要配合Cache-Control使用。</p>\n<p>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</p>"},{"title":"深入理解JavaScript之this","date":"2016-07-14T08:50:13.000Z","banner":"http://img.yanyuanfe.cn/js.png","_content":"\n\n\n> JavaScript非常重要。这并不总是如此，但现在确实如此\n\n![image](http://img.yanyuanfe.cn/js.png)\n\n<!--more-->\n\nthis是JavaScript中的一个很特别的关键字，同时，它也是JavaScript中最复杂的机制之一，重要性同闭包、原型不相伯仲。如果你缺乏对this的清晰认识，this的指向足以让你眼花缭乱，这完全就是一种魔法。\n\n### this是什么\n\n当一个函数被调用时，除了传入了函数的显式参数以外，名为this的隐式参数也被传入了函数。this引用了与该函数调用进行隐式关联的一个对象，被称之为函数上下文。函数上下文包含了函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this在函数运行时进行绑定，并不是在编写时绑定，它的上下文取决于函数调用时得各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式，而this则指的是调用函数的那个对象。\n\n现在，我们来看看在具体的调用方式中this是怎样的。\n\n### 一. 作为函数进行调用 \n\n当一个函数作为函数进行调用时，是区别于其他调用机制：方法、构造器以及apply、call。\n\n使用这种方式进行调用通常在函数上使用了()操作符，使用了()操作符的表达式并没有将函数作为对象的一个属性。\n下面是一个示例：\n\n``` js\nfunction foo(){\n\tconsole.log(this.a);\n}\nvar a=2;\n\nfoo();//2\n```\n如你所见，a是声明在全局作用域中的变量，a也是全局对象的一个同名属性。当foo()被调用时，this.a被解析称为了全局变量a，因此this指向全局对象，函数的上下文是全局上下文——window对象。\n\n如果使用严格模式(strict mode)，则this并不能指向全局对象，this此时将会指向undefined：\n\n\n\n``` js\nfunction foo(){\n\t\"use strict\";\n\tconsole.log(this.a);\n}\nvar a=2;\n\nfoo();\n//TypeError: Cannot read property 'a' of undefined(…)\n```\n\n\n### 二. 作为方法进行调用\n\n当一个函数被赋值为对象的一个属性，并使用引用该函数的这个属性进行调用时，那么函数就是作为对象的一个方法进行调用的。\n\n示例如下：\n\n``` js\nvar obj={\n\ta:2\n};\nobj.foo=function(){\n\tconsole.log(this.a);\n};\nobj.foo();//2\n\n```\n\n如果你对面向对象了解的话，你肯定知道，一个方法所属的对象在该方法体内可以以this的形式进行引用。在这里，将函数作为对象的一个方法进行调用时，该对象就变成了函数的上下文，并且在函数内部可以以this参数的形式进行访问。\n\n请看下面示例：\n\n\n``` js\nfunction foo(){\n\t\n\tconsole.log(this.a);\n}\n\n\nvar obj={\n\ta:2,\n\tfoo:foo\n};\nvar bar=obj.foo;\n\nvar a=\"two\";\nbar();//\"two\"\n```\n在这里，虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此this指向全局对象。当使用严格模式时，this指向undefined。\n\n### 三. 作为构造器进行调用\n\n将函数进行构造器(constructor)进行调用，我们要在函数进行调用前使用new关键字。 \n\n``` js\nfunction foo(){\n\t\n\treturn this\n}\nnew foo();\n```\n\n将函数作为构造器进行调用，或者说使用new来调用函数，会自动执行下面的操作。\n\n- 创建一个新的空对象。\n- 传递给构造器的对象是this参数，从而成为构造器的函数上下文。\n- 如果没有显式的返回值，新创建的对象则作为构造器的返回值进行返回。\n\n请看下面代码：\n\n\n``` js\nfunction foo(a){\n\t\n\tthis.a=a;\n}\nvar bar=new foo(2);\n\nconsole.log(bar.a);\n```\n\n作为构造函数调用时foo()时，我们会构造一个新对象并把它绑定到foo(...)调用中的this上。\n\n### 四. 使用apply()/call()方法进行调用\n\n在函数调用的时候，JavaScript为我们提供了一种方式，可以显式指定任何一个对象作为其函数上下文。JavaScript的每个函数都有apply()和call()方法，它们的功能相同，仅仅是传入参数不同。\n\n通过函数的apply()方法来调用函数，我们要给apply()传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。call()方法的使用方式类似，唯一不同的是，给函数传入的参数是一个参数列表，而不是单个数组。\n\n请看示例：\n\n``` js\nfunction foo(){\n\tconsole.log(this.a);\n}\n\nvar obj={\n\ta:2,\n};\nfoo.call(obj);\n```\n在这段代码中，通过foo.call(...),我们在调用foo时强制把它的this绑定到obj上。\n\n### 总结\n\n如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置，然后根据其调用方式来判断this的绑定对象。\n1. 作为构造器进行调用，this指向新创建的对象。\n2. 使用call/apply方法调用时，this指向指定的对象。\n3. 作为方法进行调用时，this指向拥有该方法的对象\n4. 作为普通函数进行调用时，this指向全局对象window，严格模式下指向undefined。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/深入理解JavaScript之this.md","raw":"---\ntitle: 深入理解JavaScript之this\ndate: 2016-07-14 16:50:13\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/js.png\ntags:\n\t- JavaScript\n---\n\n\n\n> JavaScript非常重要。这并不总是如此，但现在确实如此\n\n![image](http://img.yanyuanfe.cn/js.png)\n\n<!--more-->\n\nthis是JavaScript中的一个很特别的关键字，同时，它也是JavaScript中最复杂的机制之一，重要性同闭包、原型不相伯仲。如果你缺乏对this的清晰认识，this的指向足以让你眼花缭乱，这完全就是一种魔法。\n\n### this是什么\n\n当一个函数被调用时，除了传入了函数的显式参数以外，名为this的隐式参数也被传入了函数。this引用了与该函数调用进行隐式关联的一个对象，被称之为函数上下文。函数上下文包含了函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this在函数运行时进行绑定，并不是在编写时绑定，它的上下文取决于函数调用时得各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式，而this则指的是调用函数的那个对象。\n\n现在，我们来看看在具体的调用方式中this是怎样的。\n\n### 一. 作为函数进行调用 \n\n当一个函数作为函数进行调用时，是区别于其他调用机制：方法、构造器以及apply、call。\n\n使用这种方式进行调用通常在函数上使用了()操作符，使用了()操作符的表达式并没有将函数作为对象的一个属性。\n下面是一个示例：\n\n``` js\nfunction foo(){\n\tconsole.log(this.a);\n}\nvar a=2;\n\nfoo();//2\n```\n如你所见，a是声明在全局作用域中的变量，a也是全局对象的一个同名属性。当foo()被调用时，this.a被解析称为了全局变量a，因此this指向全局对象，函数的上下文是全局上下文——window对象。\n\n如果使用严格模式(strict mode)，则this并不能指向全局对象，this此时将会指向undefined：\n\n\n\n``` js\nfunction foo(){\n\t\"use strict\";\n\tconsole.log(this.a);\n}\nvar a=2;\n\nfoo();\n//TypeError: Cannot read property 'a' of undefined(…)\n```\n\n\n### 二. 作为方法进行调用\n\n当一个函数被赋值为对象的一个属性，并使用引用该函数的这个属性进行调用时，那么函数就是作为对象的一个方法进行调用的。\n\n示例如下：\n\n``` js\nvar obj={\n\ta:2\n};\nobj.foo=function(){\n\tconsole.log(this.a);\n};\nobj.foo();//2\n\n```\n\n如果你对面向对象了解的话，你肯定知道，一个方法所属的对象在该方法体内可以以this的形式进行引用。在这里，将函数作为对象的一个方法进行调用时，该对象就变成了函数的上下文，并且在函数内部可以以this参数的形式进行访问。\n\n请看下面示例：\n\n\n``` js\nfunction foo(){\n\t\n\tconsole.log(this.a);\n}\n\n\nvar obj={\n\ta:2,\n\tfoo:foo\n};\nvar bar=obj.foo;\n\nvar a=\"two\";\nbar();//\"two\"\n```\n在这里，虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此this指向全局对象。当使用严格模式时，this指向undefined。\n\n### 三. 作为构造器进行调用\n\n将函数进行构造器(constructor)进行调用，我们要在函数进行调用前使用new关键字。 \n\n``` js\nfunction foo(){\n\t\n\treturn this\n}\nnew foo();\n```\n\n将函数作为构造器进行调用，或者说使用new来调用函数，会自动执行下面的操作。\n\n- 创建一个新的空对象。\n- 传递给构造器的对象是this参数，从而成为构造器的函数上下文。\n- 如果没有显式的返回值，新创建的对象则作为构造器的返回值进行返回。\n\n请看下面代码：\n\n\n``` js\nfunction foo(a){\n\t\n\tthis.a=a;\n}\nvar bar=new foo(2);\n\nconsole.log(bar.a);\n```\n\n作为构造函数调用时foo()时，我们会构造一个新对象并把它绑定到foo(...)调用中的this上。\n\n### 四. 使用apply()/call()方法进行调用\n\n在函数调用的时候，JavaScript为我们提供了一种方式，可以显式指定任何一个对象作为其函数上下文。JavaScript的每个函数都有apply()和call()方法，它们的功能相同，仅仅是传入参数不同。\n\n通过函数的apply()方法来调用函数，我们要给apply()传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。call()方法的使用方式类似，唯一不同的是，给函数传入的参数是一个参数列表，而不是单个数组。\n\n请看示例：\n\n``` js\nfunction foo(){\n\tconsole.log(this.a);\n}\n\nvar obj={\n\ta:2,\n};\nfoo.call(obj);\n```\n在这段代码中，通过foo.call(...),我们在调用foo时强制把它的this绑定到obj上。\n\n### 总结\n\n如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置，然后根据其调用方式来判断this的绑定对象。\n1. 作为构造器进行调用，this指向新创建的对象。\n2. 使用call/apply方法调用时，this指向指定的对象。\n3. 作为方法进行调用时，this指向拥有该方法的对象\n4. 作为普通函数进行调用时，this指向全局对象window，严格模式下指向undefined。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"深入理解JavaScript之this","published":1,"updated":"2020-07-16T13:56:47.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenob0020p70vld9itxio","content":"<blockquote>\n<p>JavaScript非常重要。这并不总是如此，但现在确实如此</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>this是JavaScript中的一个很特别的关键字，同时，它也是JavaScript中最复杂的机制之一，重要性同闭包、原型不相伯仲。如果你缺乏对this的清晰认识，this的指向足以让你眼花缭乱，这完全就是一种魔法。</p>\n<h3 id=\"this是什么\"><a href=\"#this是什么\" class=\"headerlink\" title=\"this是什么\"></a>this是什么</h3><p>当一个函数被调用时，除了传入了函数的显式参数以外，名为this的隐式参数也被传入了函数。this引用了与该函数调用进行隐式关联的一个对象，被称之为函数上下文。函数上下文包含了函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this在函数运行时进行绑定，并不是在编写时绑定，它的上下文取决于函数调用时得各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式，而this则指的是调用函数的那个对象。</p>\n<p>现在，我们来看看在具体的调用方式中this是怎样的。</p>\n<h3 id=\"一-作为函数进行调用\"><a href=\"#一-作为函数进行调用\" class=\"headerlink\" title=\"一. 作为函数进行调用\"></a>一. 作为函数进行调用</h3><p>当一个函数作为函数进行调用时，是区别于其他调用机制：方法、构造器以及apply、call。</p>\n<p>使用这种方式进行调用通常在函数上使用了()操作符，使用了()操作符的表达式并没有将函数作为对象的一个属性。<br>下面是一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>如你所见，a是声明在全局作用域中的变量，a也是全局对象的一个同名属性。当foo()被调用时，this.a被解析称为了全局变量a，因此this指向全局对象，函数的上下文是全局上下文——window对象。</p>\n<p>如果使用严格模式(strict mode)，则this并不能指向全局对象，this此时将会指向undefined：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">\t\"use strict\"</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br><span class=\"line\"><span class=\"comment\">//TypeError: Cannot read property 'a' of undefined(…)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-作为方法进行调用\"><a href=\"#二-作为方法进行调用\" class=\"headerlink\" title=\"二. 作为方法进行调用\"></a>二. 作为方法进行调用</h3><p>当一个函数被赋值为对象的一个属性，并使用引用该函数的这个属性进行调用时，那么函数就是作为对象的一个方法进行调用的。</p>\n<p>示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\ta:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo();<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>如果你对面向对象了解的话，你肯定知道，一个方法所属的对象在该方法体内可以以this的形式进行引用。在这里，将函数作为对象的一个方法进行调用时，该对象就变成了函数的上下文，并且在函数内部可以以this参数的形式进行访问。</p>\n<p>请看下面示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\ta:<span class=\"number\">2</span>,</span><br><span class=\"line\">\tfoo:foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar=obj.foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">\"two\"</span>;</span><br><span class=\"line\">bar();<span class=\"comment\">//\"two\"</span></span><br></pre></td></tr></table></figure>\n<p>在这里，虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此this指向全局对象。当使用严格模式时，this指向undefined。</p>\n<h3 id=\"三-作为构造器进行调用\"><a href=\"#三-作为构造器进行调用\" class=\"headerlink\" title=\"三. 作为构造器进行调用\"></a>三. 作为构造器进行调用</h3><p>将函数进行构造器(constructor)进行调用，我们要在函数进行调用前使用new关键字。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> foo();</span><br></pre></td></tr></table></figure>\n<p>将函数作为构造器进行调用，或者说使用new来调用函数，会自动执行下面的操作。</p>\n<ul>\n<li>创建一个新的空对象。</li>\n<li>传递给构造器的对象是this参数，从而成为构造器的函数上下文。</li>\n<li>如果没有显式的返回值，新创建的对象则作为构造器的返回值进行返回。</li>\n</ul>\n<p>请看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.a=a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar=<span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.a);</span><br></pre></td></tr></table></figure>\n<p>作为构造函数调用时foo()时，我们会构造一个新对象并把它绑定到foo(…)调用中的this上。</p>\n<h3 id=\"四-使用apply-call-方法进行调用\"><a href=\"#四-使用apply-call-方法进行调用\" class=\"headerlink\" title=\"四. 使用apply()/call()方法进行调用\"></a>四. 使用apply()/call()方法进行调用</h3><p>在函数调用的时候，JavaScript为我们提供了一种方式，可以显式指定任何一个对象作为其函数上下文。JavaScript的每个函数都有apply()和call()方法，它们的功能相同，仅仅是传入参数不同。</p>\n<p>通过函数的apply()方法来调用函数，我们要给apply()传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。call()方法的使用方式类似，唯一不同的是，给函数传入的参数是一个参数列表，而不是单个数组。</p>\n<p>请看示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\ta:<span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call(obj);</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，通过foo.call(…),我们在调用foo时强制把它的this绑定到obj上。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置，然后根据其调用方式来判断this的绑定对象。</p>\n<ol>\n<li>作为构造器进行调用，this指向新创建的对象。</li>\n<li>使用call/apply方法调用时，this指向指定的对象。</li>\n<li>作为方法进行调用时，this指向拥有该方法的对象</li>\n<li>作为普通函数进行调用时，this指向全局对象window，严格模式下指向undefined。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>JavaScript非常重要。这并不总是如此，但现在确实如此</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js.png\" alt=\"image\"></p>","more":"<p>this是JavaScript中的一个很特别的关键字，同时，它也是JavaScript中最复杂的机制之一，重要性同闭包、原型不相伯仲。如果你缺乏对this的清晰认识，this的指向足以让你眼花缭乱，这完全就是一种魔法。</p>\n<h3 id=\"this是什么\"><a href=\"#this是什么\" class=\"headerlink\" title=\"this是什么\"></a>this是什么</h3><p>当一个函数被调用时，除了传入了函数的显式参数以外，名为this的隐式参数也被传入了函数。this引用了与该函数调用进行隐式关联的一个对象，被称之为函数上下文。函数上下文包含了函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this在函数运行时进行绑定，并不是在编写时绑定，它的上下文取决于函数调用时得各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式，而this则指的是调用函数的那个对象。</p>\n<p>现在，我们来看看在具体的调用方式中this是怎样的。</p>\n<h3 id=\"一-作为函数进行调用\"><a href=\"#一-作为函数进行调用\" class=\"headerlink\" title=\"一. 作为函数进行调用\"></a>一. 作为函数进行调用</h3><p>当一个函数作为函数进行调用时，是区别于其他调用机制：方法、构造器以及apply、call。</p>\n<p>使用这种方式进行调用通常在函数上使用了()操作符，使用了()操作符的表达式并没有将函数作为对象的一个属性。<br>下面是一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>如你所见，a是声明在全局作用域中的变量，a也是全局对象的一个同名属性。当foo()被调用时，this.a被解析称为了全局变量a，因此this指向全局对象，函数的上下文是全局上下文——window对象。</p>\n<p>如果使用严格模式(strict mode)，则this并不能指向全局对象，this此时将会指向undefined：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">\t\"use strict\"</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br><span class=\"line\"><span class=\"comment\">//TypeError: Cannot read property 'a' of undefined(…)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"二-作为方法进行调用\"><a href=\"#二-作为方法进行调用\" class=\"headerlink\" title=\"二. 作为方法进行调用\"></a>二. 作为方法进行调用</h3><p>当一个函数被赋值为对象的一个属性，并使用引用该函数的这个属性进行调用时，那么函数就是作为对象的一个方法进行调用的。</p>\n<p>示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\ta:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo();<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>如果你对面向对象了解的话，你肯定知道，一个方法所属的对象在该方法体内可以以this的形式进行引用。在这里，将函数作为对象的一个方法进行调用时，该对象就变成了函数的上下文，并且在函数内部可以以this参数的形式进行访问。</p>\n<p>请看下面示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\ta:<span class=\"number\">2</span>,</span><br><span class=\"line\">\tfoo:foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar=obj.foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">\"two\"</span>;</span><br><span class=\"line\">bar();<span class=\"comment\">//\"two\"</span></span><br></pre></td></tr></table></figure>\n<p>在这里，虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此this指向全局对象。当使用严格模式时，this指向undefined。</p>\n<h3 id=\"三-作为构造器进行调用\"><a href=\"#三-作为构造器进行调用\" class=\"headerlink\" title=\"三. 作为构造器进行调用\"></a>三. 作为构造器进行调用</h3><p>将函数进行构造器(constructor)进行调用，我们要在函数进行调用前使用new关键字。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> foo();</span><br></pre></td></tr></table></figure>\n<p>将函数作为构造器进行调用，或者说使用new来调用函数，会自动执行下面的操作。</p>\n<ul>\n<li>创建一个新的空对象。</li>\n<li>传递给构造器的对象是this参数，从而成为构造器的函数上下文。</li>\n<li>如果没有显式的返回值，新创建的对象则作为构造器的返回值进行返回。</li>\n</ul>\n<p>请看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.a=a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar=<span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.a);</span><br></pre></td></tr></table></figure>\n<p>作为构造函数调用时foo()时，我们会构造一个新对象并把它绑定到foo(…)调用中的this上。</p>\n<h3 id=\"四-使用apply-call-方法进行调用\"><a href=\"#四-使用apply-call-方法进行调用\" class=\"headerlink\" title=\"四. 使用apply()/call()方法进行调用\"></a>四. 使用apply()/call()方法进行调用</h3><p>在函数调用的时候，JavaScript为我们提供了一种方式，可以显式指定任何一个对象作为其函数上下文。JavaScript的每个函数都有apply()和call()方法，它们的功能相同，仅仅是传入参数不同。</p>\n<p>通过函数的apply()方法来调用函数，我们要给apply()传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。call()方法的使用方式类似，唯一不同的是，给函数传入的参数是一个参数列表，而不是单个数组。</p>\n<p>请看示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">\ta:<span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call(obj);</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，通过foo.call(…),我们在调用foo时强制把它的this绑定到obj上。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置，然后根据其调用方式来判断this的绑定对象。</p>\n<ol>\n<li>作为构造器进行调用，this指向新创建的对象。</li>\n<li>使用call/apply方法调用时，this指向指定的对象。</li>\n<li>作为方法进行调用时，this指向拥有该方法的对象</li>\n<li>作为普通函数进行调用时，this指向全局对象window，严格模式下指向undefined。</li>\n</ol>"},{"title":"深入理解JavaScript之克隆","date":"2016-09-24T05:43:41.000Z","banner":"http://img.yanyuanfe.cn/js001.png","_content":"\n\n\n> JavaScript中万物皆是对象，这显然是错误的。\n\n![image](http://img.yanyuanfe.cn/js001.png)\n\n<!--more-->\n\n### 动态类型\n\nJavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。\n\n### 数据类型\n\n最新的 ECMAScript 标准定义了 7 种数据类型:\n\n- 六种原始类型（Primitive）\n\n- - Boolean\n- - Null\n- - Undefined\n- - Number\n- - String\n- - Symbol（ECMAScript 6）\n\n\n- 对象类型（Object）\n\n在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。\n而后，这些属性还可以被增减。属性的值可以是任意类型，包括具有复杂数据结构的对象。属性使用键来标识，它的键值可以是一个字符串或者符号值（Symbol）。\n在对象中，又有两个特殊的对象——函数和数组。\n\n从以上可知JavaScript的数据类型分为两类，而这两种类型在进行复制克隆时候是不同的。原始数据类型存储的是对象的实际数据，而对象类型存储的是对象的引用地址，对象的实际内容单独存放（为了减小数据开销通常存放在内存中）。此外，对象的原型也是引用对象，它将原型的方法和属性放在内存当中，通过原型链的方式来指向这个内存地址。\n\n### 克隆\n所谓对象克隆，就是对一个对象生成一个一模一样的对象，但是在JavaScript中，使用简单的复制语句所实现的是对原对象的一个引用，对新复制的对象的任何一个属性方法的改变，都将会影响原对象的属性方法。\n\n根据克隆的特点，克隆有两种类型：\n影子克隆（浅复制）：仅仅复制所考虑的对象，而不复制它所引用的对象。对于原始类型，为值传递，对象类型为引用传递。\n深度克隆（深复制）：把要复制的对象所引用的对象都复制一遍。所有元素或属性均完全复制，与原对象完全脱离，最终所有对于新对象的修改都不会反映到原对象中。\n\n### 影子克隆\n\n1. 原始类型\n\n1.1 字符串的克隆\n\n``` js\nvar a=\"1\";\nvar b=a;\nb=\"2\";\nconsole.log(a);//1\nconsole.log(b);//2\n```\n1.2 数值的克隆\n``` js\nvar a=1;\nvar b=a;\nb=2;\nconsole.log(a);//1\nconsole.log(b);//2\n```\n1.2 布尔值的克隆\n``` js\nvar a=true;\nvar b=a;\nb=false;\nconsole.log(a);//true\nconsole.log(b);//false\n```\n由上面的代码可知，原始类型采用普通的克隆方式就能得到正确的结果，因为原始类型中存储的是对象的真实数据。\n\n2. 深度克隆\n\n2.1 函数\n\n函数虽然属于对象类型，但是函数的克隆通过浅复制即可实现。\n``` js\nvar a=function(){\nconsole.log(1)};\nvar b=a;\nb=function(){\nconsole.log(2)};\nconsole.log(a());//1\nconsole.log(b());//2\n```\n在这里，我们通过普通赋值的形式，就可以实现函数的克隆，并且不会影响之前的对象。原因是函数的克隆会在内容单独开辟一块空间，互不影响。\n\n2.2 对象\n\n在对JavaScript引用类型中的数组进行克隆的时候，直接赋值就会导致一些问题的发生了，请看如下代码。\n\n``` js\nvar arr1=[1,2,3];\nvar arr2=arr1;\narr2[1]=1;\nconsole.log(arr1);//[1, 1, 3]\nconsole.log(arr2);//[1, 1, 3]\n```\n这种克隆方式称之为影子克隆、浅复制，但是这并不是我们想要的结果，我们想要让arr1的值不变。\n\n1. 对象的深度克隆\n之前在其他博客上看到过有人讨论数组的深度克隆，提出使用数组的slice方法和concat方法可以实现深度克隆，后来我查看MDN的文档时，看到关于这两个方法的解释：\n- Array.prototype.slice()\n\nslice() 方法会浅复制（shallow copy）数组的一部分到一个新的数组，并返回这个新数组。\nslice不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：\n- 如果该元素是个对象引用（不是实际的对象），slice会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。\n- 对于字符串、数字及布尔值来说（不是String、Number或者Boolean对象），slice会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。\n\n如果向两个数组任一中添加了新元素，则另一个不会受到影响。\n下面看一个代码示例：\n\n``` js\nvar myCar = [{color: \"red\"},5, {wheels: 4}];\nvar newCar = myCar.slice(0);\nnewCar[0].color=\"purple\";\nnewCar[1]=1;\nnewCar.push(\"engine\");\nconsole.log(myCar);//[{color: \"purple\"},5,{wheels: 4}]\nconsole.log(newCar);//[{color: \"purple\"},1,{wheels: 4},\"engine\"]\n\n```\n从这段代码我们隐约可以知道，slice方法对数组元素是\n字符串、数字及布尔值等原始类型会执行深拷贝，对引用对象类型，则会执行浅拷贝。\n\n- Array.prototype.concat()\nconcat() 方法将传入的数组或非数组值与原数组合并,组成一个新的数组并返回.\n\nconcat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组.\n\nconcat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:\n\n- 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.\n- 字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象):concat方法会复制字符串和数字的值放到新数组里\n\n``` js\nvar myCar = [{color: \"red\"},5, {wheels: 4}];\nvar newCar = myCar.concat();\nnewCar[0].color=\"purple\";\nnewCar[1]=1;\nnewCar.push(\"engine\");\nconsole.log(myCar);//[{color: \"purple\"},5,{wheels: 4}]\nconsole.log(newCar);//[{color: \"purple\"},1,{wheels: 4},\"engine\"]\n\n```\n\n结果不言而喻。\n\n所谓抛砖引玉，砖已经抛出去了，下面来实现对象的深度克隆。为什么不是数组呢？因为数组也是对象，数组的元素也可能是对象，在深度克隆的过程中，当对象的值也是一个对象时，对对象的值也要进行深度克隆。\n下面是一个深度克隆函数：\n\n``` js\nfunction clone(obj) {\n    var newobj;\n    if (obj === null || obj == undefined || typeof(obj) != \"object\") {\n        return obj;\n    }\n    if (obj instanceof Array) {\n        newobj = [];\n        for (var i = 0; i < obj.length; i++) {\n            if (typeof obj[i] == \"object\" && obj[i] != null) {\n                newobj[i] = arguments.callee(obj[i]);\n            } else {\n                newobj[i] = obj[i];\n            }\n\n        }\n    }else{\n        newobj={};\n        for(var key in obj){\n            if(typeof obj[key]==\"object\" && obj[key]!=null){\n                obj[key]=arguments.calle(obj[key]);\n            }else{\n                newobj[key]=obj[key];\n            }\n        }\n    }\n    return newobj;\n    \n}\n\nvar myCar = [{color: \"red\"},5, {wheels: 4}];\nvar newCar=clone(myCar);\nnewCar[0].color=\"purple\";\nnewCar[1]=1;\nnewCar.push(\"engine\");\nconsole.log(myCar);//[{color: \"red\"},5,{wheels: 4}]\nconsole.log(newCar);//[{color: \"purple\"},1,{wheels: 4},\"engine\"]\n\n```\n从结果我们看到，这个深度克隆函数是成功的，它不仅可以克隆原始类型，也可以克隆引用类型。说明如下：\n1. 判断对象是否为null、undefined或者非object之外的数据类型，如果为真，则直接返回该对象。\n2. 判断对象是否为数组，如果为真，则遍历数组，对其成员进行递归调用克隆函数。\n3. 如果为非数组对象，遍历对象成员并递归调用成员对象，最后返回克隆对象。\n\n\n\n### 拥抱未来的深度克隆方法\n在MDN上面看到一个对象复制函数，用到了*Object.create()、Object.isPrototypeOf()*等比较新的方法，基本只能在 IE9+ 使用，称之为拥抱未来的深度克隆方法。\n\n``` js\n//对象复制函数\nfunction copy(obj){\n    var objproto = Object.getPrototypeOf(obj); //返回该对象的原型。\n    \n    var copy = Object.create(objproto); //创建一个拥有指定原型和若干个指定属性的对象。\n    \n    //返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。\n    var propNames = Object.getOwnPropertyNames(obj);\n\n    \n    propNames.forEach(function(name) {\n    \t//返回指定对象上一个自有属性对应的属性描述符\n        var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n        //直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。\n        Object.defineProperty(copy, name, desc); \n        \n    });\n    return copy;\n}\n```\n### 参考资料\n\n\n> [MDN-Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n\n\n","source":"_posts/深入理解JavaScript之克隆.md","raw":"---\ntitle: 深入理解JavaScript之克隆\ndate: 2016-09-24 13:43:41\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/js001.png\ntags:\n\t- JavaScript\n---\n\n\n\n> JavaScript中万物皆是对象，这显然是错误的。\n\n![image](http://img.yanyuanfe.cn/js001.png)\n\n<!--more-->\n\n### 动态类型\n\nJavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。\n\n### 数据类型\n\n最新的 ECMAScript 标准定义了 7 种数据类型:\n\n- 六种原始类型（Primitive）\n\n- - Boolean\n- - Null\n- - Undefined\n- - Number\n- - String\n- - Symbol（ECMAScript 6）\n\n\n- 对象类型（Object）\n\n在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。\n而后，这些属性还可以被增减。属性的值可以是任意类型，包括具有复杂数据结构的对象。属性使用键来标识，它的键值可以是一个字符串或者符号值（Symbol）。\n在对象中，又有两个特殊的对象——函数和数组。\n\n从以上可知JavaScript的数据类型分为两类，而这两种类型在进行复制克隆时候是不同的。原始数据类型存储的是对象的实际数据，而对象类型存储的是对象的引用地址，对象的实际内容单独存放（为了减小数据开销通常存放在内存中）。此外，对象的原型也是引用对象，它将原型的方法和属性放在内存当中，通过原型链的方式来指向这个内存地址。\n\n### 克隆\n所谓对象克隆，就是对一个对象生成一个一模一样的对象，但是在JavaScript中，使用简单的复制语句所实现的是对原对象的一个引用，对新复制的对象的任何一个属性方法的改变，都将会影响原对象的属性方法。\n\n根据克隆的特点，克隆有两种类型：\n影子克隆（浅复制）：仅仅复制所考虑的对象，而不复制它所引用的对象。对于原始类型，为值传递，对象类型为引用传递。\n深度克隆（深复制）：把要复制的对象所引用的对象都复制一遍。所有元素或属性均完全复制，与原对象完全脱离，最终所有对于新对象的修改都不会反映到原对象中。\n\n### 影子克隆\n\n1. 原始类型\n\n1.1 字符串的克隆\n\n``` js\nvar a=\"1\";\nvar b=a;\nb=\"2\";\nconsole.log(a);//1\nconsole.log(b);//2\n```\n1.2 数值的克隆\n``` js\nvar a=1;\nvar b=a;\nb=2;\nconsole.log(a);//1\nconsole.log(b);//2\n```\n1.2 布尔值的克隆\n``` js\nvar a=true;\nvar b=a;\nb=false;\nconsole.log(a);//true\nconsole.log(b);//false\n```\n由上面的代码可知，原始类型采用普通的克隆方式就能得到正确的结果，因为原始类型中存储的是对象的真实数据。\n\n2. 深度克隆\n\n2.1 函数\n\n函数虽然属于对象类型，但是函数的克隆通过浅复制即可实现。\n``` js\nvar a=function(){\nconsole.log(1)};\nvar b=a;\nb=function(){\nconsole.log(2)};\nconsole.log(a());//1\nconsole.log(b());//2\n```\n在这里，我们通过普通赋值的形式，就可以实现函数的克隆，并且不会影响之前的对象。原因是函数的克隆会在内容单独开辟一块空间，互不影响。\n\n2.2 对象\n\n在对JavaScript引用类型中的数组进行克隆的时候，直接赋值就会导致一些问题的发生了，请看如下代码。\n\n``` js\nvar arr1=[1,2,3];\nvar arr2=arr1;\narr2[1]=1;\nconsole.log(arr1);//[1, 1, 3]\nconsole.log(arr2);//[1, 1, 3]\n```\n这种克隆方式称之为影子克隆、浅复制，但是这并不是我们想要的结果，我们想要让arr1的值不变。\n\n1. 对象的深度克隆\n之前在其他博客上看到过有人讨论数组的深度克隆，提出使用数组的slice方法和concat方法可以实现深度克隆，后来我查看MDN的文档时，看到关于这两个方法的解释：\n- Array.prototype.slice()\n\nslice() 方法会浅复制（shallow copy）数组的一部分到一个新的数组，并返回这个新数组。\nslice不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：\n- 如果该元素是个对象引用（不是实际的对象），slice会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。\n- 对于字符串、数字及布尔值来说（不是String、Number或者Boolean对象），slice会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。\n\n如果向两个数组任一中添加了新元素，则另一个不会受到影响。\n下面看一个代码示例：\n\n``` js\nvar myCar = [{color: \"red\"},5, {wheels: 4}];\nvar newCar = myCar.slice(0);\nnewCar[0].color=\"purple\";\nnewCar[1]=1;\nnewCar.push(\"engine\");\nconsole.log(myCar);//[{color: \"purple\"},5,{wheels: 4}]\nconsole.log(newCar);//[{color: \"purple\"},1,{wheels: 4},\"engine\"]\n\n```\n从这段代码我们隐约可以知道，slice方法对数组元素是\n字符串、数字及布尔值等原始类型会执行深拷贝，对引用对象类型，则会执行浅拷贝。\n\n- Array.prototype.concat()\nconcat() 方法将传入的数组或非数组值与原数组合并,组成一个新的数组并返回.\n\nconcat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组.\n\nconcat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:\n\n- 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.\n- 字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象):concat方法会复制字符串和数字的值放到新数组里\n\n``` js\nvar myCar = [{color: \"red\"},5, {wheels: 4}];\nvar newCar = myCar.concat();\nnewCar[0].color=\"purple\";\nnewCar[1]=1;\nnewCar.push(\"engine\");\nconsole.log(myCar);//[{color: \"purple\"},5,{wheels: 4}]\nconsole.log(newCar);//[{color: \"purple\"},1,{wheels: 4},\"engine\"]\n\n```\n\n结果不言而喻。\n\n所谓抛砖引玉，砖已经抛出去了，下面来实现对象的深度克隆。为什么不是数组呢？因为数组也是对象，数组的元素也可能是对象，在深度克隆的过程中，当对象的值也是一个对象时，对对象的值也要进行深度克隆。\n下面是一个深度克隆函数：\n\n``` js\nfunction clone(obj) {\n    var newobj;\n    if (obj === null || obj == undefined || typeof(obj) != \"object\") {\n        return obj;\n    }\n    if (obj instanceof Array) {\n        newobj = [];\n        for (var i = 0; i < obj.length; i++) {\n            if (typeof obj[i] == \"object\" && obj[i] != null) {\n                newobj[i] = arguments.callee(obj[i]);\n            } else {\n                newobj[i] = obj[i];\n            }\n\n        }\n    }else{\n        newobj={};\n        for(var key in obj){\n            if(typeof obj[key]==\"object\" && obj[key]!=null){\n                obj[key]=arguments.calle(obj[key]);\n            }else{\n                newobj[key]=obj[key];\n            }\n        }\n    }\n    return newobj;\n    \n}\n\nvar myCar = [{color: \"red\"},5, {wheels: 4}];\nvar newCar=clone(myCar);\nnewCar[0].color=\"purple\";\nnewCar[1]=1;\nnewCar.push(\"engine\");\nconsole.log(myCar);//[{color: \"red\"},5,{wheels: 4}]\nconsole.log(newCar);//[{color: \"purple\"},1,{wheels: 4},\"engine\"]\n\n```\n从结果我们看到，这个深度克隆函数是成功的，它不仅可以克隆原始类型，也可以克隆引用类型。说明如下：\n1. 判断对象是否为null、undefined或者非object之外的数据类型，如果为真，则直接返回该对象。\n2. 判断对象是否为数组，如果为真，则遍历数组，对其成员进行递归调用克隆函数。\n3. 如果为非数组对象，遍历对象成员并递归调用成员对象，最后返回克隆对象。\n\n\n\n### 拥抱未来的深度克隆方法\n在MDN上面看到一个对象复制函数，用到了*Object.create()、Object.isPrototypeOf()*等比较新的方法，基本只能在 IE9+ 使用，称之为拥抱未来的深度克隆方法。\n\n``` js\n//对象复制函数\nfunction copy(obj){\n    var objproto = Object.getPrototypeOf(obj); //返回该对象的原型。\n    \n    var copy = Object.create(objproto); //创建一个拥有指定原型和若干个指定属性的对象。\n    \n    //返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。\n    var propNames = Object.getOwnPropertyNames(obj);\n\n    \n    propNames.forEach(function(name) {\n    \t//返回指定对象上一个自有属性对应的属性描述符\n        var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n        //直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。\n        Object.defineProperty(copy, name, desc); \n        \n    });\n    return copy;\n}\n```\n### 参考资料\n\n\n> [MDN-Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n\n\n","slug":"深入理解JavaScript之克隆","published":1,"updated":"2020-07-16T13:56:47.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenoc0023p70vnknf8rxo","content":"<blockquote>\n<p>JavaScript中万物皆是对象，这显然是错误的。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js001.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>最新的 ECMAScript 标准定义了 7 种数据类型:</p>\n<ul>\n<li><p>六种原始类型（Primitive）</p>\n</li>\n<li><ul>\n<li>Boolean</li>\n</ul>\n</li>\n<li><ul>\n<li>Null</li>\n</ul>\n</li>\n<li><ul>\n<li>Undefined</li>\n</ul>\n</li>\n<li><ul>\n<li>Number</li>\n</ul>\n</li>\n<li><ul>\n<li>String</li>\n</ul>\n</li>\n<li><ul>\n<li>Symbol（ECMAScript 6）</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>对象类型（Object）</li>\n</ul>\n<p>在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。<br>而后，这些属性还可以被增减。属性的值可以是任意类型，包括具有复杂数据结构的对象。属性使用键来标识，它的键值可以是一个字符串或者符号值（Symbol）。<br>在对象中，又有两个特殊的对象——函数和数组。</p>\n<p>从以上可知JavaScript的数据类型分为两类，而这两种类型在进行复制克隆时候是不同的。原始数据类型存储的是对象的实际数据，而对象类型存储的是对象的引用地址，对象的实际内容单独存放（为了减小数据开销通常存放在内存中）。此外，对象的原型也是引用对象，它将原型的方法和属性放在内存当中，通过原型链的方式来指向这个内存地址。</p>\n<h3 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h3><p>所谓对象克隆，就是对一个对象生成一个一模一样的对象，但是在JavaScript中，使用简单的复制语句所实现的是对原对象的一个引用，对新复制的对象的任何一个属性方法的改变，都将会影响原对象的属性方法。</p>\n<p>根据克隆的特点，克隆有两种类型：<br>影子克隆（浅复制）：仅仅复制所考虑的对象，而不复制它所引用的对象。对于原始类型，为值传递，对象类型为引用传递。<br>深度克隆（深复制）：把要复制的对象所引用的对象都复制一遍。所有元素或属性均完全复制，与原对象完全脱离，最终所有对于新对象的修改都不会反映到原对象中。</p>\n<h3 id=\"影子克隆\"><a href=\"#影子克隆\" class=\"headerlink\" title=\"影子克隆\"></a>影子克隆</h3><ol>\n<li>原始类型</li>\n</ol>\n<p>1.1 字符串的克隆</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">\"1\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"string\">\"2\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>1.2 数值的克隆<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>1.2 布尔值的克隆<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>由上面的代码可知，原始类型采用普通的克隆方式就能得到正确的结果，因为原始类型中存储的是对象的真实数据。</p>\n<ol start=\"2\">\n<li>深度克隆</li>\n</ol>\n<p>2.1 函数</p>\n<p>函数虽然属于对象类型，但是函数的克隆通过浅复制即可实现。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a());<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b());<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们通过普通赋值的形式，就可以实现函数的克隆，并且不会影响之前的对象。原因是函数的克隆会在内容单独开辟一块空间，互不影响。</p>\n<p>2.2 对象</p>\n<p>在对JavaScript引用类型中的数组进行克隆的时候，直接赋值就会导致一些问题的发生了，请看如下代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2=arr1;</span><br><span class=\"line\">arr2[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);<span class=\"comment\">//[1, 1, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);<span class=\"comment\">//[1, 1, 3]</span></span><br></pre></td></tr></table></figure>\n<p>这种克隆方式称之为影子克隆、浅复制，但是这并不是我们想要的结果，我们想要让arr1的值不变。</p>\n<ol>\n<li>对象的深度克隆<br>之前在其他博客上看到过有人讨论数组的深度克隆，提出使用数组的slice方法和concat方法可以实现深度克隆，后来我查看MDN的文档时，看到关于这两个方法的解释：</li>\n</ol>\n<ul>\n<li>Array.prototype.slice()</li>\n</ul>\n<p>slice() 方法会浅复制（shallow copy）数组的一部分到一个新的数组，并返回这个新数组。<br>slice不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：</p>\n<ul>\n<li>如果该元素是个对象引用（不是实际的对象），slice会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。</li>\n<li>对于字符串、数字及布尔值来说（不是String、Number或者Boolean对象），slice会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li>\n</ul>\n<p>如果向两个数组任一中添加了新元素，则另一个不会受到影响。<br>下面看一个代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myCar = [&#123;<span class=\"attr\">color</span>: <span class=\"string\">\"red\"</span>&#125;,<span class=\"number\">5</span>, &#123;<span class=\"attr\">wheels</span>: <span class=\"number\">4</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newCar = myCar.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">newCar[<span class=\"number\">0</span>].color=<span class=\"string\">\"purple\"</span>;</span><br><span class=\"line\">newCar[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">newCar.push(<span class=\"string\">\"engine\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,5,&#123;wheels: 4&#125;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,1,&#123;wheels: 4&#125;,\"engine\"]</span></span><br></pre></td></tr></table></figure>\n<p>从这段代码我们隐约可以知道，slice方法对数组元素是<br>字符串、数字及布尔值等原始类型会执行深拷贝，对引用对象类型，则会执行浅拷贝。</p>\n<ul>\n<li>Array.prototype.concat()<br>concat() 方法将传入的数组或非数组值与原数组合并,组成一个新的数组并返回.</li>\n</ul>\n<p>concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组.</p>\n<p>concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:</p>\n<ul>\n<li>对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>\n<li>字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象):concat方法会复制字符串和数字的值放到新数组里</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myCar = [&#123;<span class=\"attr\">color</span>: <span class=\"string\">\"red\"</span>&#125;,<span class=\"number\">5</span>, &#123;<span class=\"attr\">wheels</span>: <span class=\"number\">4</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newCar = myCar.concat();</span><br><span class=\"line\">newCar[<span class=\"number\">0</span>].color=<span class=\"string\">\"purple\"</span>;</span><br><span class=\"line\">newCar[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">newCar.push(<span class=\"string\">\"engine\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,5,&#123;wheels: 4&#125;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,1,&#123;wheels: 4&#125;,\"engine\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果不言而喻。</p>\n<p>所谓抛砖引玉，砖已经抛出去了，下面来实现对象的深度克隆。为什么不是数组呢？因为数组也是对象，数组的元素也可能是对象，在深度克隆的过程中，当对象的值也是一个对象时，对对象的值也要进行深度克隆。<br>下面是一个深度克隆函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newobj;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span> || obj == <span class=\"literal\">undefined</span> || <span class=\"keyword\">typeof</span>(obj) != <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">        newobj = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj[i] == <span class=\"string\">\"object\"</span> &amp;&amp; obj[i] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                newobj[i] = <span class=\"built_in\">arguments</span>.callee(obj[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newobj[i] = obj[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        newobj=&#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> obj[key]==<span class=\"string\">\"object\"</span> &amp;&amp; obj[key]!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                obj[key]=<span class=\"built_in\">arguments</span>.calle(obj[key]);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                newobj[key]=obj[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newobj;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myCar = [&#123;<span class=\"attr\">color</span>: <span class=\"string\">\"red\"</span>&#125;,<span class=\"number\">5</span>, &#123;<span class=\"attr\">wheels</span>: <span class=\"number\">4</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newCar=clone(myCar);</span><br><span class=\"line\">newCar[<span class=\"number\">0</span>].color=<span class=\"string\">\"purple\"</span>;</span><br><span class=\"line\">newCar[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">newCar.push(<span class=\"string\">\"engine\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myCar);<span class=\"comment\">//[&#123;color: \"red\"&#125;,5,&#123;wheels: 4&#125;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,1,&#123;wheels: 4&#125;,\"engine\"]</span></span><br></pre></td></tr></table></figure>\n<p>从结果我们看到，这个深度克隆函数是成功的，它不仅可以克隆原始类型，也可以克隆引用类型。说明如下：</p>\n<ol>\n<li>判断对象是否为null、undefined或者非object之外的数据类型，如果为真，则直接返回该对象。</li>\n<li>判断对象是否为数组，如果为真，则遍历数组，对其成员进行递归调用克隆函数。</li>\n<li>如果为非数组对象，遍历对象成员并递归调用成员对象，最后返回克隆对象。</li>\n</ol>\n<h3 id=\"拥抱未来的深度克隆方法\"><a href=\"#拥抱未来的深度克隆方法\" class=\"headerlink\" title=\"拥抱未来的深度克隆方法\"></a>拥抱未来的深度克隆方法</h3><p>在MDN上面看到一个对象复制函数，用到了<em>Object.create()、Object.isPrototypeOf()</em>等比较新的方法，基本只能在 IE9+ 使用，称之为拥抱未来的深度克隆方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象复制函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> objproto = <span class=\"built_in\">Object</span>.getPrototypeOf(obj); <span class=\"comment\">//返回该对象的原型。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.create(objproto); <span class=\"comment\">//创建一个拥有指定原型和若干个指定属性的对象。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> propNames = <span class=\"built_in\">Object</span>.getOwnPropertyNames(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    propNames.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//返回指定对象上一个自有属性对应的属性描述符</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> desc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, name);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</span></span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(copy, name, desc); </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\" target=\"_blank\" rel=\"noopener\">MDN-Array</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>JavaScript中万物皆是对象，这显然是错误的。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js001.png\" alt=\"image\"></p>","more":"<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>最新的 ECMAScript 标准定义了 7 种数据类型:</p>\n<ul>\n<li><p>六种原始类型（Primitive）</p>\n</li>\n<li><ul>\n<li>Boolean</li>\n</ul>\n</li>\n<li><ul>\n<li>Null</li>\n</ul>\n</li>\n<li><ul>\n<li>Undefined</li>\n</ul>\n</li>\n<li><ul>\n<li>Number</li>\n</ul>\n</li>\n<li><ul>\n<li>String</li>\n</ul>\n</li>\n<li><ul>\n<li>Symbol（ECMAScript 6）</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>对象类型（Object）</li>\n</ul>\n<p>在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。<br>而后，这些属性还可以被增减。属性的值可以是任意类型，包括具有复杂数据结构的对象。属性使用键来标识，它的键值可以是一个字符串或者符号值（Symbol）。<br>在对象中，又有两个特殊的对象——函数和数组。</p>\n<p>从以上可知JavaScript的数据类型分为两类，而这两种类型在进行复制克隆时候是不同的。原始数据类型存储的是对象的实际数据，而对象类型存储的是对象的引用地址，对象的实际内容单独存放（为了减小数据开销通常存放在内存中）。此外，对象的原型也是引用对象，它将原型的方法和属性放在内存当中，通过原型链的方式来指向这个内存地址。</p>\n<h3 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h3><p>所谓对象克隆，就是对一个对象生成一个一模一样的对象，但是在JavaScript中，使用简单的复制语句所实现的是对原对象的一个引用，对新复制的对象的任何一个属性方法的改变，都将会影响原对象的属性方法。</p>\n<p>根据克隆的特点，克隆有两种类型：<br>影子克隆（浅复制）：仅仅复制所考虑的对象，而不复制它所引用的对象。对于原始类型，为值传递，对象类型为引用传递。<br>深度克隆（深复制）：把要复制的对象所引用的对象都复制一遍。所有元素或属性均完全复制，与原对象完全脱离，最终所有对于新对象的修改都不会反映到原对象中。</p>\n<h3 id=\"影子克隆\"><a href=\"#影子克隆\" class=\"headerlink\" title=\"影子克隆\"></a>影子克隆</h3><ol>\n<li>原始类型</li>\n</ol>\n<p>1.1 字符串的克隆</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">\"1\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"string\">\"2\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>1.2 数值的克隆<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>1.2 布尔值的克隆<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>由上面的代码可知，原始类型采用普通的克隆方式就能得到正确的结果，因为原始类型中存储的是对象的真实数据。</p>\n<ol start=\"2\">\n<li>深度克隆</li>\n</ol>\n<p>2.1 函数</p>\n<p>函数虽然属于对象类型，但是函数的克隆通过浅复制即可实现。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b=a;</span><br><span class=\"line\">b=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a());<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b());<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们通过普通赋值的形式，就可以实现函数的克隆，并且不会影响之前的对象。原因是函数的克隆会在内容单独开辟一块空间，互不影响。</p>\n<p>2.2 对象</p>\n<p>在对JavaScript引用类型中的数组进行克隆的时候，直接赋值就会导致一些问题的发生了，请看如下代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2=arr1;</span><br><span class=\"line\">arr2[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);<span class=\"comment\">//[1, 1, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);<span class=\"comment\">//[1, 1, 3]</span></span><br></pre></td></tr></table></figure>\n<p>这种克隆方式称之为影子克隆、浅复制，但是这并不是我们想要的结果，我们想要让arr1的值不变。</p>\n<ol>\n<li>对象的深度克隆<br>之前在其他博客上看到过有人讨论数组的深度克隆，提出使用数组的slice方法和concat方法可以实现深度克隆，后来我查看MDN的文档时，看到关于这两个方法的解释：</li>\n</ol>\n<ul>\n<li>Array.prototype.slice()</li>\n</ul>\n<p>slice() 方法会浅复制（shallow copy）数组的一部分到一个新的数组，并返回这个新数组。<br>slice不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：</p>\n<ul>\n<li>如果该元素是个对象引用（不是实际的对象），slice会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。</li>\n<li>对于字符串、数字及布尔值来说（不是String、Number或者Boolean对象），slice会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li>\n</ul>\n<p>如果向两个数组任一中添加了新元素，则另一个不会受到影响。<br>下面看一个代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myCar = [&#123;<span class=\"attr\">color</span>: <span class=\"string\">\"red\"</span>&#125;,<span class=\"number\">5</span>, &#123;<span class=\"attr\">wheels</span>: <span class=\"number\">4</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newCar = myCar.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">newCar[<span class=\"number\">0</span>].color=<span class=\"string\">\"purple\"</span>;</span><br><span class=\"line\">newCar[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">newCar.push(<span class=\"string\">\"engine\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,5,&#123;wheels: 4&#125;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,1,&#123;wheels: 4&#125;,\"engine\"]</span></span><br></pre></td></tr></table></figure>\n<p>从这段代码我们隐约可以知道，slice方法对数组元素是<br>字符串、数字及布尔值等原始类型会执行深拷贝，对引用对象类型，则会执行浅拷贝。</p>\n<ul>\n<li>Array.prototype.concat()<br>concat() 方法将传入的数组或非数组值与原数组合并,组成一个新的数组并返回.</li>\n</ul>\n<p>concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组.</p>\n<p>concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:</p>\n<ul>\n<li>对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>\n<li>字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象):concat方法会复制字符串和数字的值放到新数组里</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myCar = [&#123;<span class=\"attr\">color</span>: <span class=\"string\">\"red\"</span>&#125;,<span class=\"number\">5</span>, &#123;<span class=\"attr\">wheels</span>: <span class=\"number\">4</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newCar = myCar.concat();</span><br><span class=\"line\">newCar[<span class=\"number\">0</span>].color=<span class=\"string\">\"purple\"</span>;</span><br><span class=\"line\">newCar[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">newCar.push(<span class=\"string\">\"engine\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,5,&#123;wheels: 4&#125;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,1,&#123;wheels: 4&#125;,\"engine\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果不言而喻。</p>\n<p>所谓抛砖引玉，砖已经抛出去了，下面来实现对象的深度克隆。为什么不是数组呢？因为数组也是对象，数组的元素也可能是对象，在深度克隆的过程中，当对象的值也是一个对象时，对对象的值也要进行深度克隆。<br>下面是一个深度克隆函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newobj;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span> || obj == <span class=\"literal\">undefined</span> || <span class=\"keyword\">typeof</span>(obj) != <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">        newobj = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj[i] == <span class=\"string\">\"object\"</span> &amp;&amp; obj[i] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                newobj[i] = <span class=\"built_in\">arguments</span>.callee(obj[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newobj[i] = obj[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        newobj=&#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> obj[key]==<span class=\"string\">\"object\"</span> &amp;&amp; obj[key]!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                obj[key]=<span class=\"built_in\">arguments</span>.calle(obj[key]);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                newobj[key]=obj[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newobj;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myCar = [&#123;<span class=\"attr\">color</span>: <span class=\"string\">\"red\"</span>&#125;,<span class=\"number\">5</span>, &#123;<span class=\"attr\">wheels</span>: <span class=\"number\">4</span>&#125;];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newCar=clone(myCar);</span><br><span class=\"line\">newCar[<span class=\"number\">0</span>].color=<span class=\"string\">\"purple\"</span>;</span><br><span class=\"line\">newCar[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">newCar.push(<span class=\"string\">\"engine\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myCar);<span class=\"comment\">//[&#123;color: \"red\"&#125;,5,&#123;wheels: 4&#125;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newCar);<span class=\"comment\">//[&#123;color: \"purple\"&#125;,1,&#123;wheels: 4&#125;,\"engine\"]</span></span><br></pre></td></tr></table></figure>\n<p>从结果我们看到，这个深度克隆函数是成功的，它不仅可以克隆原始类型，也可以克隆引用类型。说明如下：</p>\n<ol>\n<li>判断对象是否为null、undefined或者非object之外的数据类型，如果为真，则直接返回该对象。</li>\n<li>判断对象是否为数组，如果为真，则遍历数组，对其成员进行递归调用克隆函数。</li>\n<li>如果为非数组对象，遍历对象成员并递归调用成员对象，最后返回克隆对象。</li>\n</ol>\n<h3 id=\"拥抱未来的深度克隆方法\"><a href=\"#拥抱未来的深度克隆方法\" class=\"headerlink\" title=\"拥抱未来的深度克隆方法\"></a>拥抱未来的深度克隆方法</h3><p>在MDN上面看到一个对象复制函数，用到了<em>Object.create()、Object.isPrototypeOf()</em>等比较新的方法，基本只能在 IE9+ 使用，称之为拥抱未来的深度克隆方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象复制函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> objproto = <span class=\"built_in\">Object</span>.getPrototypeOf(obj); <span class=\"comment\">//返回该对象的原型。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.create(objproto); <span class=\"comment\">//创建一个拥有指定原型和若干个指定属性的对象。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> propNames = <span class=\"built_in\">Object</span>.getOwnPropertyNames(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    propNames.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//返回指定对象上一个自有属性对应的属性描述符</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> desc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, name);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</span></span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(copy, name, desc); </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\" target=\"_blank\" rel=\"noopener\">MDN-Array</a></p>\n</blockquote>"},{"title":"深入理解JavaScript之变量提升","date":"2016-07-16T12:29:10.000Z","banner":"http://img.yanyuanfe.cn/js.png","_content":"> Javascript的变量声明具有Hoisting机制(变量提升)，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。\n\n![image](http://img.yanyuanfe.cn/js.png)\n\n<!--more-->\n\n### 从一个栗子说起\n在学习JavaScript的时候，你可能会陷入一个误区，以为JavaScript的代码在执行时是一行一行由上到下依次执行的。但是，在实际上，这并不完全正确。\n\n下面是一个简单的示例：\n\n\n``` js\na=2;\n\nvar a;\n\nconsole.log(a);\n```\n你可能会以为会输出undefined，因为var a声明在a=2之后，变量被重新赋值，因此a被赋予默认值undefined。但是，你错了，真正的输出结果是2。\n\n再看一个示例：\n\n\n\n``` js\nconsole.log(a);\n\nvar a=2;\n```\n看了上一个例子的不寻常的特点，你可能会认为这里也会同样的输出2。还有人可能会以为，由于变量a在使用前没有先进行声明，因此会抛出如下异常：\n\n``` js\nUncaught ReferenceError: a is not defined(…)\n```\n结局充满意外，两种猜测都不正确，真正的输出结果是undefined。\n\n### 揭开秘密\n\n> 当秘密被揭开的时候，和各种各样的魔术把戏一样，几乎令人失望。\n\n在JavaScript中，当变量被声明时，声明会被提升到它所在函数的顶部，并被赋予undefined值，而初始化仍旧在原来的地方。这就使得在函数的任意位置声明的变量存在于整个函数中，尽管在赋值之前，它的值一直是undefined。\n\n当你看到var a=2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明：var a;和a=2;。第一个声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行。\n\n第一个示例将会以如下形式处理：\n\n``` js\nvar a;\n\na=2;\n\nconsole.log(a);\n```\n结果不言而喻，其中第一部分是编译，第二部分是执行。\n\n同样的，相信你已经知道第二个示例是如何处理的了吧：\n\n``` js\nvar a;\n\nconsole.log(a);\n\na=2;\n\n```\n因此，这个过程就好像变量的声明从它们在代码中出现的位置被“移动”到了最上面，这个过程叫做提升。\n\n### 函数提升\n\n上面我们讲了JavaScript的变量提升，除了变量提升，JavaScript还有函数提升。\n\n下面是一个示例：\n\n\n``` js\nfoo();\n\nfunction foo(){\n\n\tconsole.log(a);//undefined\n\tvar a=2;\n}\n```\n理解了变量提升的原理，这个示例的结果也就明显了。foo函数的声明被提升了，因此第一行代码可以正常执行。\n\n在JavaScript中，每个作用域都会进行提升操作。前面的代码都是简化在全局作用域中进行，而这里的foo(...)函数自身也会在内部对var a进行提升（注意：并不是提升到整个程序的最上方）。因此这段代码实际上会按照如下形式进行处理：\n\n``` js\n\n\nfunction foo(){\n    var a;\n    \n\tconsole.log(a); //undefined\n\t\n\ta=2;\n}\n\nfoo();\n```\n请注意，函数声明会被提升，但是函数表达式却不会被提升。\n\n``` js\nfoo();\n\nvar foo=function bar(){\n    //...\n};\n```\n输出结果：\n\n``` js\nUncaught TypeError: foo is not a function(…)\n```\n而不是：\n\n``` js\nUncaught ReferenceError\n```\n在这段代码中，变量标识符foo()被提升并分配给所在的作用域（此处为全局作用域），因此foo()不会导致ReferenceError。但是foo并没有赋值（如果它是一个函数声明，那么就会赋值）。foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常。\n\n同时请注意，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用，如下：\n\n``` js\nfoo();//TypeError\n\nbar();//ReferenceError\n\nvar foo=function bar(){\n    //...\n};\n```\n这段代码经过提升后变为如下形式：\n\n``` js\nvar foo;\n\nfoo();//TypeError\n\nbar();//ReferenceError\n\nfoo=function bar(){\n    //...\n};\n```\n### 优先提升\n\n在JavaScript中，变量声明和函数声明都会被提升，但是，需要注意的一个细节是，函数会优先被提升，然后才是变量。\n\n下面是一个示例：\n\n``` js\n\nfoo();\n\nvar foo;\n\nfunction foo(){\n    console.log(1);\n};\n\nfoo=function (){\n    console.log(2);\n};\n```\n根据上面的结论我们知道结果会输出1。这段代码会被引擎理解为如下形式：\n\n``` js\n\n\nfunction foo(){\n    console.log(1);\n};\n\nfoo(); //1\n\nfoo=function (){\n    console.log(2);\n};\n```\n在这段代码中，var foo虽然出现在function foo()...的声明之前，但是它是重复声明，会被忽略，因为函数声明会被提升到普通变量之前。\n\n虽然重复的变量声明会被忽略，但是出现在后面的函数声明却可以覆盖前面的。\n``` js\nfoo(); //3\n\nfunction foo(){\n    console.log(1);\n};\n\nfoo=function (){\n    console.log(2);\n};\n\nfunction foo(){\n    console.log(3);\n};\n\n```\n### 结论\n\n当你理解了变量提升，那么这对于Javascript编码意味着什么？最重要的一点是，总是用var定义你的变量。而且，对于一个名称，在一个作用域里面永远只有一次var声明。如果你这么做，你就不会遇到作用域和变量提升问题。\n\nECMAScript参考文档关于作用域和变量提升的部分：\n> 如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序（译者以为，就是全局性质的代码执行）才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。","source":"_posts/深入理解JavaScript之变量提升.md","raw":"---\ntitle: 深入理解JavaScript之变量提升\ndate: 2016-07-16 20:29:10\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/js.png\ntags:\n\t- JavaScript\n---\n> Javascript的变量声明具有Hoisting机制(变量提升)，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。\n\n![image](http://img.yanyuanfe.cn/js.png)\n\n<!--more-->\n\n### 从一个栗子说起\n在学习JavaScript的时候，你可能会陷入一个误区，以为JavaScript的代码在执行时是一行一行由上到下依次执行的。但是，在实际上，这并不完全正确。\n\n下面是一个简单的示例：\n\n\n``` js\na=2;\n\nvar a;\n\nconsole.log(a);\n```\n你可能会以为会输出undefined，因为var a声明在a=2之后，变量被重新赋值，因此a被赋予默认值undefined。但是，你错了，真正的输出结果是2。\n\n再看一个示例：\n\n\n\n``` js\nconsole.log(a);\n\nvar a=2;\n```\n看了上一个例子的不寻常的特点，你可能会认为这里也会同样的输出2。还有人可能会以为，由于变量a在使用前没有先进行声明，因此会抛出如下异常：\n\n``` js\nUncaught ReferenceError: a is not defined(…)\n```\n结局充满意外，两种猜测都不正确，真正的输出结果是undefined。\n\n### 揭开秘密\n\n> 当秘密被揭开的时候，和各种各样的魔术把戏一样，几乎令人失望。\n\n在JavaScript中，当变量被声明时，声明会被提升到它所在函数的顶部，并被赋予undefined值，而初始化仍旧在原来的地方。这就使得在函数的任意位置声明的变量存在于整个函数中，尽管在赋值之前，它的值一直是undefined。\n\n当你看到var a=2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明：var a;和a=2;。第一个声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行。\n\n第一个示例将会以如下形式处理：\n\n``` js\nvar a;\n\na=2;\n\nconsole.log(a);\n```\n结果不言而喻，其中第一部分是编译，第二部分是执行。\n\n同样的，相信你已经知道第二个示例是如何处理的了吧：\n\n``` js\nvar a;\n\nconsole.log(a);\n\na=2;\n\n```\n因此，这个过程就好像变量的声明从它们在代码中出现的位置被“移动”到了最上面，这个过程叫做提升。\n\n### 函数提升\n\n上面我们讲了JavaScript的变量提升，除了变量提升，JavaScript还有函数提升。\n\n下面是一个示例：\n\n\n``` js\nfoo();\n\nfunction foo(){\n\n\tconsole.log(a);//undefined\n\tvar a=2;\n}\n```\n理解了变量提升的原理，这个示例的结果也就明显了。foo函数的声明被提升了，因此第一行代码可以正常执行。\n\n在JavaScript中，每个作用域都会进行提升操作。前面的代码都是简化在全局作用域中进行，而这里的foo(...)函数自身也会在内部对var a进行提升（注意：并不是提升到整个程序的最上方）。因此这段代码实际上会按照如下形式进行处理：\n\n``` js\n\n\nfunction foo(){\n    var a;\n    \n\tconsole.log(a); //undefined\n\t\n\ta=2;\n}\n\nfoo();\n```\n请注意，函数声明会被提升，但是函数表达式却不会被提升。\n\n``` js\nfoo();\n\nvar foo=function bar(){\n    //...\n};\n```\n输出结果：\n\n``` js\nUncaught TypeError: foo is not a function(…)\n```\n而不是：\n\n``` js\nUncaught ReferenceError\n```\n在这段代码中，变量标识符foo()被提升并分配给所在的作用域（此处为全局作用域），因此foo()不会导致ReferenceError。但是foo并没有赋值（如果它是一个函数声明，那么就会赋值）。foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常。\n\n同时请注意，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用，如下：\n\n``` js\nfoo();//TypeError\n\nbar();//ReferenceError\n\nvar foo=function bar(){\n    //...\n};\n```\n这段代码经过提升后变为如下形式：\n\n``` js\nvar foo;\n\nfoo();//TypeError\n\nbar();//ReferenceError\n\nfoo=function bar(){\n    //...\n};\n```\n### 优先提升\n\n在JavaScript中，变量声明和函数声明都会被提升，但是，需要注意的一个细节是，函数会优先被提升，然后才是变量。\n\n下面是一个示例：\n\n``` js\n\nfoo();\n\nvar foo;\n\nfunction foo(){\n    console.log(1);\n};\n\nfoo=function (){\n    console.log(2);\n};\n```\n根据上面的结论我们知道结果会输出1。这段代码会被引擎理解为如下形式：\n\n``` js\n\n\nfunction foo(){\n    console.log(1);\n};\n\nfoo(); //1\n\nfoo=function (){\n    console.log(2);\n};\n```\n在这段代码中，var foo虽然出现在function foo()...的声明之前，但是它是重复声明，会被忽略，因为函数声明会被提升到普通变量之前。\n\n虽然重复的变量声明会被忽略，但是出现在后面的函数声明却可以覆盖前面的。\n``` js\nfoo(); //3\n\nfunction foo(){\n    console.log(1);\n};\n\nfoo=function (){\n    console.log(2);\n};\n\nfunction foo(){\n    console.log(3);\n};\n\n```\n### 结论\n\n当你理解了变量提升，那么这对于Javascript编码意味着什么？最重要的一点是，总是用var定义你的变量。而且，对于一个名称，在一个作用域里面永远只有一次var声明。如果你这么做，你就不会遇到作用域和变量提升问题。\n\nECMAScript参考文档关于作用域和变量提升的部分：\n> 如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序（译者以为，就是全局性质的代码执行）才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。","slug":"深入理解JavaScript之变量提升","published":1,"updated":"2020-07-16T13:56:47.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenod0026p70vmsyiv666","content":"<blockquote>\n<p>Javascript的变量声明具有Hoisting机制(变量提升)，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"从一个栗子说起\"><a href=\"#从一个栗子说起\" class=\"headerlink\" title=\"从一个栗子说起\"></a>从一个栗子说起</h3><p>在学习JavaScript的时候，你可能会陷入一个误区，以为JavaScript的代码在执行时是一行一行由上到下依次执行的。但是，在实际上，这并不完全正确。</p>\n<p>下面是一个简单的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>你可能会以为会输出undefined，因为var a声明在a=2之后，变量被重新赋值，因此a被赋予默认值undefined。但是，你错了，真正的输出结果是2。</p>\n<p>再看一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>看了上一个例子的不寻常的特点，你可能会认为这里也会同样的输出2。还有人可能会以为，由于变量a在使用前没有先进行声明，因此会抛出如下异常：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">ReferenceError</span>: a is not defined(…)</span><br></pre></td></tr></table></figure>\n<p>结局充满意外，两种猜测都不正确，真正的输出结果是undefined。</p>\n<h3 id=\"揭开秘密\"><a href=\"#揭开秘密\" class=\"headerlink\" title=\"揭开秘密\"></a>揭开秘密</h3><blockquote>\n<p>当秘密被揭开的时候，和各种各样的魔术把戏一样，几乎令人失望。</p>\n</blockquote>\n<p>在JavaScript中，当变量被声明时，声明会被提升到它所在函数的顶部，并被赋予undefined值，而初始化仍旧在原来的地方。这就使得在函数的任意位置声明的变量存在于整个函数中，尽管在赋值之前，它的值一直是undefined。</p>\n<p>当你看到var a=2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明：var a;和a=2;。第一个声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行。</p>\n<p>第一个示例将会以如下形式处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>结果不言而喻，其中第一部分是编译，第二部分是执行。</p>\n<p>同样的，相信你已经知道第二个示例是如何处理的了吧：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\">a=<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>因此，这个过程就好像变量的声明从它们在代码中出现的位置被“移动”到了最上面，这个过程叫做提升。</p>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3><p>上面我们讲了JavaScript的变量提升，除了变量提升，JavaScript还有函数提升。</p>\n<p>下面是一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//undefined</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解了变量提升的原理，这个示例的结果也就明显了。foo函数的声明被提升了，因此第一行代码可以正常执行。</p>\n<p>在JavaScript中，每个作用域都会进行提升操作。前面的代码都是简化在全局作用域中进行，而这里的foo(…)函数自身也会在内部对var a进行提升（注意：并不是提升到整个程序的最上方）。因此这段代码实际上会按照如下形式进行处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\ta=<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>请注意，函数声明会被提升，但是函数表达式却不会被提升。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo=<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">TypeError</span>: foo is not a <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">…</span>)</span></span><br></pre></td></tr></table></figure>\n<p>而不是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>在这段代码中，变量标识符foo()被提升并分配给所在的作用域（此处为全局作用域），因此foo()不会导致ReferenceError。但是foo并没有赋值（如果它是一个函数声明，那么就会赋值）。foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常。</p>\n<p>同时请注意，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo();<span class=\"comment\">//TypeError</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar();<span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo=<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这段代码经过提升后变为如下形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();<span class=\"comment\">//TypeError</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar();<span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"优先提升\"><a href=\"#优先提升\" class=\"headerlink\" title=\"优先提升\"></a>优先提升</h3><p>在JavaScript中，变量声明和函数声明都会被提升，但是，需要注意的一个细节是，函数会优先被提升，然后才是变量。</p>\n<p>下面是一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>根据上面的结论我们知道结果会输出1。这段代码会被引擎理解为如下形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">//1</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，var foo虽然出现在function foo()…的声明之前，但是它是重复声明，会被忽略，因为函数声明会被提升到普通变量之前。</p>\n<p>虽然重复的变量声明会被忽略，但是出现在后面的函数声明却可以覆盖前面的。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>当你理解了变量提升，那么这对于Javascript编码意味着什么？最重要的一点是，总是用var定义你的变量。而且，对于一个名称，在一个作用域里面永远只有一次var声明。如果你这么做，你就不会遇到作用域和变量提升问题。</p>\n<p>ECMAScript参考文档关于作用域和变量提升的部分：</p>\n<blockquote>\n<p>如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序（译者以为，就是全局性质的代码执行）才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Javascript的变量声明具有Hoisting机制(变量提升)，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js.png\" alt=\"image\"></p>","more":"<h3 id=\"从一个栗子说起\"><a href=\"#从一个栗子说起\" class=\"headerlink\" title=\"从一个栗子说起\"></a>从一个栗子说起</h3><p>在学习JavaScript的时候，你可能会陷入一个误区，以为JavaScript的代码在执行时是一行一行由上到下依次执行的。但是，在实际上，这并不完全正确。</p>\n<p>下面是一个简单的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>你可能会以为会输出undefined，因为var a声明在a=2之后，变量被重新赋值，因此a被赋予默认值undefined。但是，你错了，真正的输出结果是2。</p>\n<p>再看一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>看了上一个例子的不寻常的特点，你可能会认为这里也会同样的输出2。还有人可能会以为，由于变量a在使用前没有先进行声明，因此会抛出如下异常：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">ReferenceError</span>: a is not defined(…)</span><br></pre></td></tr></table></figure>\n<p>结局充满意外，两种猜测都不正确，真正的输出结果是undefined。</p>\n<h3 id=\"揭开秘密\"><a href=\"#揭开秘密\" class=\"headerlink\" title=\"揭开秘密\"></a>揭开秘密</h3><blockquote>\n<p>当秘密被揭开的时候，和各种各样的魔术把戏一样，几乎令人失望。</p>\n</blockquote>\n<p>在JavaScript中，当变量被声明时，声明会被提升到它所在函数的顶部，并被赋予undefined值，而初始化仍旧在原来的地方。这就使得在函数的任意位置声明的变量存在于整个函数中，尽管在赋值之前，它的值一直是undefined。</p>\n<p>当你看到var a=2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明：var a;和a=2;。第一个声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行。</p>\n<p>第一个示例将会以如下形式处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">a=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n<p>结果不言而喻，其中第一部分是编译，第二部分是执行。</p>\n<p>同样的，相信你已经知道第二个示例是如何处理的了吧：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\">a=<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>因此，这个过程就好像变量的声明从它们在代码中出现的位置被“移动”到了最上面，这个过程叫做提升。</p>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3><p>上面我们讲了JavaScript的变量提升，除了变量提升，JavaScript还有函数提升。</p>\n<p>下面是一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//undefined</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解了变量提升的原理，这个示例的结果也就明显了。foo函数的声明被提升了，因此第一行代码可以正常执行。</p>\n<p>在JavaScript中，每个作用域都会进行提升操作。前面的代码都是简化在全局作用域中进行，而这里的foo(…)函数自身也会在内部对var a进行提升（注意：并不是提升到整个程序的最上方）。因此这段代码实际上会按照如下形式进行处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\ta=<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>请注意，函数声明会被提升，但是函数表达式却不会被提升。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo=<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">TypeError</span>: foo is not a <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">…</span>)</span></span><br></pre></td></tr></table></figure>\n<p>而不是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>在这段代码中，变量标识符foo()被提升并分配给所在的作用域（此处为全局作用域），因此foo()不会导致ReferenceError。但是foo并没有赋值（如果它是一个函数声明，那么就会赋值）。foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常。</p>\n<p>同时请注意，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo();<span class=\"comment\">//TypeError</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar();<span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo=<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这段代码经过提升后变为如下形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();<span class=\"comment\">//TypeError</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar();<span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"优先提升\"><a href=\"#优先提升\" class=\"headerlink\" title=\"优先提升\"></a>优先提升</h3><p>在JavaScript中，变量声明和函数声明都会被提升，但是，需要注意的一个细节是，函数会优先被提升，然后才是变量。</p>\n<p>下面是一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>根据上面的结论我们知道结果会输出1。这段代码会被引擎理解为如下形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">//1</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，var foo虽然出现在function foo()…的声明之前，但是它是重复声明，会被忽略，因为函数声明会被提升到普通变量之前。</p>\n<p>虽然重复的变量声明会被忽略，但是出现在后面的函数声明却可以覆盖前面的。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>当你理解了变量提升，那么这对于Javascript编码意味着什么？最重要的一点是，总是用var定义你的变量。而且，对于一个名称，在一个作用域里面永远只有一次var声明。如果你这么做，你就不会遇到作用域和变量提升问题。</p>\n<p>ECMAScript参考文档关于作用域和变量提升的部分：</p>\n<blockquote>\n<p>如果变量在函数体类声明，则它是函数作用域。否则，它是全局作用域（作为global的属性）。变量将会在执行进入作用域的时候被创建。块不会定义新的作用域，只有函数声明和程序（译者以为，就是全局性质的代码执行）才会创造新的作用域。变量在创建的时候会被初始化为undefined。如果变量声明语句里面带有赋值操作，则赋值操作只有被执行到的时候才会发生，而不是创建的时候。</p>\n</blockquote>"},{"title":"深拷贝探秘","date":"2018-11-06T13:24:54.000Z","banner":"http://img.yanyuanfe.cn/js3.jpg","_content":"\n> 本文总结了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。\n\n![image](http://img.yanyuanfe.cn/js3.jpg)\n\n<!--more-->\n\n在 JavaScript 中，深拷贝已经是一个老生常谈的问题，也无数次被面试官用来考核一个前端的 JS 水平，同时，在开发中，如果对深拷贝理解不够深刻，也会出现很难发现的 BUG。此前，我已经写过一篇文章《深入理解 JavaScript 之克隆》，其中分析了深拷贝的概念，但是其解决方法还很粗浅，这篇文章，记录了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。\n\n### 递归拷贝\n\n递归拷贝应该是最开始了解深拷贝时遇到的解决办法，其原理是对引用类型进行遍历，判断其值是否为引用类型，如果为引用类型则递归调用该函数并传入该值，否则为简单数据类型则执行常规赋值拷贝。\n\n```js\nfunction deepClone(obj) {\n  var result;\n  if (!(obj instanceof Object)) {\n    return obj;\n  } else if (obj instanceof Function) {\n    result = eval(obj.toString());\n  } else {\n    result = Array.isArray(obj) ? [] : {};\n  }\n  for (let key in obj) {\n    result[key] = deepClone(obj[key]);\n  }\n  return result;\n}\n```\n\n这是一个简单的深拷贝方法，处理了对象、数组和函数，但是 Date、Regexp、Map 等引用类型都没有处理，而且无法解决对象循环引用的场景。\n\n### JSON.parse(JSON.stringify(object))\n\n深拷贝一般用 JSON.parse(JSON.stringify(object))就可以解决了，\n\n这种方法的局限性：\n\n- 会忽略 undefined\n- 不能序列化函数\n- 不能解决循环引用的对象\n  undefined 和函数会被忽略，而尝试拷贝循环引用的对象则会报错：\n\n``` js\nUncaught TypeError：Converting circular structure to JSON\n```\n\n另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。\n\n但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。\n\n### Structured Clone 结构化克隆算法\n\nStructured cloning 是一种现有的算法，用于将值从一个地方转移到另一地方。例如，每当您调用 postMessage 将消息发送到另一个窗口或 WebWorker 时，都会使用它。关于结构化克隆的好处在于它处理循环对象并 支持大量的内置类型。结构化克隆包含使用 MessageChannel 和 History API。\n\n#### MessageChannel\n\nMessageChannel API 允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。\n我们可以创建一个 MessageChannel 并发送消息。在接收端，消息包含我们原始数据对象的结构化克隆。\nMessageChannel 的 postMessage 传递的数据也是深拷贝的，这和 web worker 的 postMessage 一样。而且还可以拷贝 undefined 和循环引用的对象。\n\n```js\n// 有undefined + 循环引用\nlet obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3\n  },\n  f: undefined\n};\nobj.c = obj.b;\nobj.e = obj.a;\nobj.b.c = obj.c;\nobj.b.d = obj.b;\nobj.b.e = obj.b.c;\n\nfunction deepCopy(obj) {\n  return new Promise(resolve => {\n    const { port1, port2 } = new MessageChannel();\n    port2.onmessage = ev => resolve(ev.data);\n    port1.postMessage(obj);\n  });\n}\n\n// MessageChannel是异步的\ndeepCopy(obj).then(copy => {\n  let copyObj = copy;\n  console.log(copyObj, obj);\n  console.log(copyObj == obj);\n});\n```\n\n但拷贝有函数的对象时，还是会报错：\n\n```\nUncaught （in promise） DOMException：Failed to execute 'postMessage' on 'MessagePort': function() {} could not be cloned.\n```\n\n这种方法的缺点是它是异步的，但是你可以使用 await 来解决。\n\n```js\nconst clone = await structuralClone(obj);\n```\n\n#### History\n\n如果你曾经使用 history.pushState()写过 SPA，你可以提供一个状态对象来保存 URL。事实证明，这个状态对象使用结构化克隆，而且是同步的。我们必须小心使用，不要把原有的路由状态搞乱了，所以我们需要在完成克隆之后恢复原始状态。为了防止发生任何意外，请使用 history.replaceState()而不是 history.pushState()。\n\n```js\nconst structuralClone = obj => {\n  const oldState = history.state;\n  history.replaceState(obj, document.title);\n  const copy = history.state;\n  history.replaceState(oldState, document.title);\n  return copy;\n};\n```\n\n此方法的优点是：能解决循环对象的问题，并且支持许多内置类型的克隆，也是同步的。缺点是有的浏览器对调用频率有限制。比如 Safari 30 秒内只允许调用 100 次\n\n#### Notification\n\nNotification 是用于桌面通知的。也可以用来实现 JS 对象的深拷贝。\n\n```js\nfunction structuralClone(obj) {\n    return new Notification('', {data: obj, silent: true}).data;\n}\nconst obj = /* ... */;\nconst clone = structuralClone(obj);\n```\n\n此方法的优点就是可以解决循环对象问题，也支持许多内置类型的克隆，并且是同步的。缺点就是这个 api 的使用需要向用户请求权限，但是用在这里克隆数据的时候，不经用户授权也可以使用。在 http 协议的情况下会提示你再 https 的场景下使用。\n由于某种原因，Safari 总是返回 undefined。\n\n### lodash 的深拷贝函数\n\nlodash 的\\_.cloneDeep()支持循环对象，和大量的内置类型，对很多细节都处理的比较不错，推荐使用。\n\n### 解决循环引用\n\n通过分析上述的方法，发现只有结构化克隆算法才能解决循环引用的问题，那么使用原生 JS 如何解决呢？这里尝试使用闭包来解决循环问题。\n\n```js\nfunction deepClone(object) {\n  const memo = {};\n  function clone(obj) {\n    var result;\n    if (!(obj instanceof Object)) {\n      return obj;\n    } else if (obj instanceof Function) {\n      result = eval(obj.toString());\n    } else {\n      result = Array.isArray(obj) ? [] : {};\n    }\n    for (let key in obj) {\n      if (memo[obj[key]]) {\n        result[key] = memo[obj[key]];\n      } else {\n        memo[obj[key]] = obj[key];\n        result[key] = clone(obj[key]);\n      }\n    }\n    return result;\n  }\n  return clone(object);\n}\n\nvar obj = {};\nvar b = { obj };\nobj.b = b;\n\nvar obj2 = deepClone(obj);\n```\n\n在上述代码中，对递归拷贝进行了优化，使用闭包来解决循环拷贝的问题，使用了 memo 这个变量来记录被拷贝的引用地址，在每次递归前，记录递归的参数值，这样在递归内部就可以跳出递归，解决循环引用问题。\n\n### 总结\n\n- 如果您没有循环对象，并且不需要保留内置类型，则可以使用跨浏览器的 JSON.parse(JSON.stringify())获得最快的克隆性能。\n- 如果你想要一个适当的结构化克隆，MessageChannel 是你唯一可靠的跨浏览器的选择。\n","source":"_posts/深拷贝探秘.md","raw":"---\ntitle: 深拷贝探秘\ndate: 2018-11-06 21:24:54\nbanner: http://img.yanyuanfe.cn/js3.jpg\ntags:\n  - JavaScript\n---\n\n> 本文总结了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。\n\n![image](http://img.yanyuanfe.cn/js3.jpg)\n\n<!--more-->\n\n在 JavaScript 中，深拷贝已经是一个老生常谈的问题，也无数次被面试官用来考核一个前端的 JS 水平，同时，在开发中，如果对深拷贝理解不够深刻，也会出现很难发现的 BUG。此前，我已经写过一篇文章《深入理解 JavaScript 之克隆》，其中分析了深拷贝的概念，但是其解决方法还很粗浅，这篇文章，记录了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。\n\n### 递归拷贝\n\n递归拷贝应该是最开始了解深拷贝时遇到的解决办法，其原理是对引用类型进行遍历，判断其值是否为引用类型，如果为引用类型则递归调用该函数并传入该值，否则为简单数据类型则执行常规赋值拷贝。\n\n```js\nfunction deepClone(obj) {\n  var result;\n  if (!(obj instanceof Object)) {\n    return obj;\n  } else if (obj instanceof Function) {\n    result = eval(obj.toString());\n  } else {\n    result = Array.isArray(obj) ? [] : {};\n  }\n  for (let key in obj) {\n    result[key] = deepClone(obj[key]);\n  }\n  return result;\n}\n```\n\n这是一个简单的深拷贝方法，处理了对象、数组和函数，但是 Date、Regexp、Map 等引用类型都没有处理，而且无法解决对象循环引用的场景。\n\n### JSON.parse(JSON.stringify(object))\n\n深拷贝一般用 JSON.parse(JSON.stringify(object))就可以解决了，\n\n这种方法的局限性：\n\n- 会忽略 undefined\n- 不能序列化函数\n- 不能解决循环引用的对象\n  undefined 和函数会被忽略，而尝试拷贝循环引用的对象则会报错：\n\n``` js\nUncaught TypeError：Converting circular structure to JSON\n```\n\n另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。\n\n但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。\n\n### Structured Clone 结构化克隆算法\n\nStructured cloning 是一种现有的算法，用于将值从一个地方转移到另一地方。例如，每当您调用 postMessage 将消息发送到另一个窗口或 WebWorker 时，都会使用它。关于结构化克隆的好处在于它处理循环对象并 支持大量的内置类型。结构化克隆包含使用 MessageChannel 和 History API。\n\n#### MessageChannel\n\nMessageChannel API 允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。\n我们可以创建一个 MessageChannel 并发送消息。在接收端，消息包含我们原始数据对象的结构化克隆。\nMessageChannel 的 postMessage 传递的数据也是深拷贝的，这和 web worker 的 postMessage 一样。而且还可以拷贝 undefined 和循环引用的对象。\n\n```js\n// 有undefined + 循环引用\nlet obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3\n  },\n  f: undefined\n};\nobj.c = obj.b;\nobj.e = obj.a;\nobj.b.c = obj.c;\nobj.b.d = obj.b;\nobj.b.e = obj.b.c;\n\nfunction deepCopy(obj) {\n  return new Promise(resolve => {\n    const { port1, port2 } = new MessageChannel();\n    port2.onmessage = ev => resolve(ev.data);\n    port1.postMessage(obj);\n  });\n}\n\n// MessageChannel是异步的\ndeepCopy(obj).then(copy => {\n  let copyObj = copy;\n  console.log(copyObj, obj);\n  console.log(copyObj == obj);\n});\n```\n\n但拷贝有函数的对象时，还是会报错：\n\n```\nUncaught （in promise） DOMException：Failed to execute 'postMessage' on 'MessagePort': function() {} could not be cloned.\n```\n\n这种方法的缺点是它是异步的，但是你可以使用 await 来解决。\n\n```js\nconst clone = await structuralClone(obj);\n```\n\n#### History\n\n如果你曾经使用 history.pushState()写过 SPA，你可以提供一个状态对象来保存 URL。事实证明，这个状态对象使用结构化克隆，而且是同步的。我们必须小心使用，不要把原有的路由状态搞乱了，所以我们需要在完成克隆之后恢复原始状态。为了防止发生任何意外，请使用 history.replaceState()而不是 history.pushState()。\n\n```js\nconst structuralClone = obj => {\n  const oldState = history.state;\n  history.replaceState(obj, document.title);\n  const copy = history.state;\n  history.replaceState(oldState, document.title);\n  return copy;\n};\n```\n\n此方法的优点是：能解决循环对象的问题，并且支持许多内置类型的克隆，也是同步的。缺点是有的浏览器对调用频率有限制。比如 Safari 30 秒内只允许调用 100 次\n\n#### Notification\n\nNotification 是用于桌面通知的。也可以用来实现 JS 对象的深拷贝。\n\n```js\nfunction structuralClone(obj) {\n    return new Notification('', {data: obj, silent: true}).data;\n}\nconst obj = /* ... */;\nconst clone = structuralClone(obj);\n```\n\n此方法的优点就是可以解决循环对象问题，也支持许多内置类型的克隆，并且是同步的。缺点就是这个 api 的使用需要向用户请求权限，但是用在这里克隆数据的时候，不经用户授权也可以使用。在 http 协议的情况下会提示你再 https 的场景下使用。\n由于某种原因，Safari 总是返回 undefined。\n\n### lodash 的深拷贝函数\n\nlodash 的\\_.cloneDeep()支持循环对象，和大量的内置类型，对很多细节都处理的比较不错，推荐使用。\n\n### 解决循环引用\n\n通过分析上述的方法，发现只有结构化克隆算法才能解决循环引用的问题，那么使用原生 JS 如何解决呢？这里尝试使用闭包来解决循环问题。\n\n```js\nfunction deepClone(object) {\n  const memo = {};\n  function clone(obj) {\n    var result;\n    if (!(obj instanceof Object)) {\n      return obj;\n    } else if (obj instanceof Function) {\n      result = eval(obj.toString());\n    } else {\n      result = Array.isArray(obj) ? [] : {};\n    }\n    for (let key in obj) {\n      if (memo[obj[key]]) {\n        result[key] = memo[obj[key]];\n      } else {\n        memo[obj[key]] = obj[key];\n        result[key] = clone(obj[key]);\n      }\n    }\n    return result;\n  }\n  return clone(object);\n}\n\nvar obj = {};\nvar b = { obj };\nobj.b = b;\n\nvar obj2 = deepClone(obj);\n```\n\n在上述代码中，对递归拷贝进行了优化，使用闭包来解决循环拷贝的问题，使用了 memo 这个变量来记录被拷贝的引用地址，在每次递归前，记录递归的参数值，这样在递归内部就可以跳出递归，解决循环引用问题。\n\n### 总结\n\n- 如果您没有循环对象，并且不需要保留内置类型，则可以使用跨浏览器的 JSON.parse(JSON.stringify())获得最快的克隆性能。\n- 如果你想要一个适当的结构化克隆，MessageChannel 是你唯一可靠的跨浏览器的选择。\n","slug":"深拷贝探秘","published":1,"updated":"2020-07-16T13:56:47.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenof0029p70v9mqwbpc7","content":"<blockquote>\n<p>本文总结了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js3.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>在 JavaScript 中，深拷贝已经是一个老生常谈的问题，也无数次被面试官用来考核一个前端的 JS 水平，同时，在开发中，如果对深拷贝理解不够深刻，也会出现很难发现的 BUG。此前，我已经写过一篇文章《深入理解 JavaScript 之克隆》，其中分析了深拷贝的概念，但是其解决方法还很粗浅，这篇文章，记录了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。</p>\n<h3 id=\"递归拷贝\"><a href=\"#递归拷贝\" class=\"headerlink\" title=\"递归拷贝\"></a>递归拷贝</h3><p>递归拷贝应该是最开始了解深拷贝时遇到的解决办法，其原理是对引用类型进行遍历，判断其值是否为引用类型，如果为引用类型则递归调用该函数并传入该值，否则为简单数据类型则执行常规赋值拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"built_in\">eval</span>(obj.toString());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    result[key] = deepClone(obj[key]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的深拷贝方法，处理了对象、数组和函数，但是 Date、Regexp、Map 等引用类型都没有处理，而且无法解决对象循环引用的场景。</p>\n<h3 id=\"JSON-parse-JSON-stringify-object\"><a href=\"#JSON-parse-JSON-stringify-object\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify(object))\"></a>JSON.parse(JSON.stringify(object))</h3><p>深拷贝一般用 JSON.parse(JSON.stringify(object))就可以解决了，</p>\n<p>这种方法的局限性：</p>\n<ul>\n<li>会忽略 undefined</li>\n<li>不能序列化函数</li>\n<li>不能解决循环引用的对象<br>undefined 和函数会被忽略，而尝试拷贝循环引用的对象则会报错：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">TypeError</span>：Converting circular structure to <span class=\"built_in\">JSON</span></span><br></pre></td></tr></table></figure>\n<p>另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。</p>\n<p>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。</p>\n<h3 id=\"Structured-Clone-结构化克隆算法\"><a href=\"#Structured-Clone-结构化克隆算法\" class=\"headerlink\" title=\"Structured Clone 结构化克隆算法\"></a>Structured Clone 结构化克隆算法</h3><p>Structured cloning 是一种现有的算法，用于将值从一个地方转移到另一地方。例如，每当您调用 postMessage 将消息发送到另一个窗口或 WebWorker 时，都会使用它。关于结构化克隆的好处在于它处理循环对象并 支持大量的内置类型。结构化克隆包含使用 MessageChannel 和 History API。</p>\n<h4 id=\"MessageChannel\"><a href=\"#MessageChannel\" class=\"headerlink\" title=\"MessageChannel\"></a>MessageChannel</h4><p>MessageChannel API 允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。<br>我们可以创建一个 MessageChannel 并发送消息。在接收端，消息包含我们原始数据对象的结构化克隆。<br>MessageChannel 的 postMessage 传递的数据也是深拷贝的，这和 web worker 的 postMessage 一样。而且还可以拷贝 undefined 和循环引用的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有undefined + 循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: &#123;</span><br><span class=\"line\">    c: <span class=\"number\">2</span>,</span><br><span class=\"line\">    d: <span class=\"number\">3</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  f: <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.c = obj.b;</span><br><span class=\"line\">obj.e = obj.a;</span><br><span class=\"line\">obj.b.c = obj.c;</span><br><span class=\"line\">obj.b.d = obj.b;</span><br><span class=\"line\">obj.b.e = obj.b.c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\">    port2.onmessage = <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class=\"line\">    port1.postMessage(obj);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MessageChannel是异步的</span></span><br><span class=\"line\">deepCopy(obj).then(<span class=\"function\"><span class=\"params\">copy</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> copyObj = copy;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(copyObj, obj);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(copyObj == obj);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>但拷贝有函数的对象时，还是会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught （in promise） DOMException：Failed to execute &apos;postMessage&apos; on &apos;MessagePort&apos;: function() &#123;&#125; could not be cloned.</span><br></pre></td></tr></table></figure>\n<p>这种方法的缺点是它是异步的，但是你可以使用 await 来解决。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"keyword\">await</span> structuralClone(obj);</span><br></pre></td></tr></table></figure>\n<h4 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h4><p>如果你曾经使用 history.pushState()写过 SPA，你可以提供一个状态对象来保存 URL。事实证明，这个状态对象使用结构化克隆，而且是同步的。我们必须小心使用，不要把原有的路由状态搞乱了，所以我们需要在完成克隆之后恢复原始状态。为了防止发生任何意外，请使用 history.replaceState()而不是 history.pushState()。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> structuralClone = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldState = history.state;</span><br><span class=\"line\">  history.replaceState(obj, <span class=\"built_in\">document</span>.title);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = history.state;</span><br><span class=\"line\">  history.replaceState(oldState, <span class=\"built_in\">document</span>.title);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>此方法的优点是：能解决循环对象的问题，并且支持许多内置类型的克隆，也是同步的。缺点是有的浏览器对调用频率有限制。比如 Safari 30 秒内只允许调用 100 次</p>\n<h4 id=\"Notification\"><a href=\"#Notification\" class=\"headerlink\" title=\"Notification\"></a>Notification</h4><p>Notification 是用于桌面通知的。也可以用来实现 JS 对象的深拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">structuralClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Notification(<span class=\"string\">''</span>, &#123;<span class=\"attr\">data</span>: obj, <span class=\"attr\">silent</span>: <span class=\"literal\">true</span>&#125;).data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"comment\">/* ... */</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure>\n<p>此方法的优点就是可以解决循环对象问题，也支持许多内置类型的克隆，并且是同步的。缺点就是这个 api 的使用需要向用户请求权限，但是用在这里克隆数据的时候，不经用户授权也可以使用。在 http 协议的情况下会提示你再 https 的场景下使用。<br>由于某种原因，Safari 总是返回 undefined。</p>\n<h3 id=\"lodash-的深拷贝函数\"><a href=\"#lodash-的深拷贝函数\" class=\"headerlink\" title=\"lodash 的深拷贝函数\"></a>lodash 的深拷贝函数</h3><p>lodash 的_.cloneDeep()支持循环对象，和大量的内置类型，对很多细节都处理的比较不错，推荐使用。</p>\n<h3 id=\"解决循环引用\"><a href=\"#解决循环引用\" class=\"headerlink\" title=\"解决循环引用\"></a>解决循环引用</h3><p>通过分析上述的方法，发现只有结构化克隆算法才能解决循环引用的问题，那么使用原生 JS 如何解决呢？这里尝试使用闭包来解决循环问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> memo = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</span><br><span class=\"line\">      result = <span class=\"built_in\">eval</span>(obj.toString());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (memo[obj[key]]) &#123;</span><br><span class=\"line\">        result[key] = memo[obj[key]];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        memo[obj[key]] = obj[key];</span><br><span class=\"line\">        result[key] = clone(obj[key]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone(object);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123; obj &#125;;</span><br><span class=\"line\">obj.b = b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = deepClone(obj);</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，对递归拷贝进行了优化，使用闭包来解决循环拷贝的问题，使用了 memo 这个变量来记录被拷贝的引用地址，在每次递归前，记录递归的参数值，这样在递归内部就可以跳出递归，解决循环引用问题。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>如果您没有循环对象，并且不需要保留内置类型，则可以使用跨浏览器的 JSON.parse(JSON.stringify())获得最快的克隆性能。</li>\n<li>如果你想要一个适当的结构化克隆，MessageChannel 是你唯一可靠的跨浏览器的选择。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文总结了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/js3.jpg\" alt=\"image\"></p>","more":"<p>在 JavaScript 中，深拷贝已经是一个老生常谈的问题，也无数次被面试官用来考核一个前端的 JS 水平，同时，在开发中，如果对深拷贝理解不够深刻，也会出现很难发现的 BUG。此前，我已经写过一篇文章《深入理解 JavaScript 之克隆》，其中分析了深拷贝的概念，但是其解决方法还很粗浅，这篇文章，记录了一些解决深拷贝的常用方法，没有银弹，每种方法都有其优劣，使用时要区分其场景。</p>\n<h3 id=\"递归拷贝\"><a href=\"#递归拷贝\" class=\"headerlink\" title=\"递归拷贝\"></a>递归拷贝</h3><p>递归拷贝应该是最开始了解深拷贝时遇到的解决办法，其原理是对引用类型进行遍历，判断其值是否为引用类型，如果为引用类型则递归调用该函数并传入该值，否则为简单数据类型则执行常规赋值拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"built_in\">eval</span>(obj.toString());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    result[key] = deepClone(obj[key]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的深拷贝方法，处理了对象、数组和函数，但是 Date、Regexp、Map 等引用类型都没有处理，而且无法解决对象循环引用的场景。</p>\n<h3 id=\"JSON-parse-JSON-stringify-object\"><a href=\"#JSON-parse-JSON-stringify-object\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify(object))\"></a>JSON.parse(JSON.stringify(object))</h3><p>深拷贝一般用 JSON.parse(JSON.stringify(object))就可以解决了，</p>\n<p>这种方法的局限性：</p>\n<ul>\n<li>会忽略 undefined</li>\n<li>不能序列化函数</li>\n<li>不能解决循环引用的对象<br>undefined 和函数会被忽略，而尝试拷贝循环引用的对象则会报错：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught <span class=\"built_in\">TypeError</span>：Converting circular structure to <span class=\"built_in\">JSON</span></span><br></pre></td></tr></table></figure>\n<p>另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。</p>\n<p>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。</p>\n<h3 id=\"Structured-Clone-结构化克隆算法\"><a href=\"#Structured-Clone-结构化克隆算法\" class=\"headerlink\" title=\"Structured Clone 结构化克隆算法\"></a>Structured Clone 结构化克隆算法</h3><p>Structured cloning 是一种现有的算法，用于将值从一个地方转移到另一地方。例如，每当您调用 postMessage 将消息发送到另一个窗口或 WebWorker 时，都会使用它。关于结构化克隆的好处在于它处理循环对象并 支持大量的内置类型。结构化克隆包含使用 MessageChannel 和 History API。</p>\n<h4 id=\"MessageChannel\"><a href=\"#MessageChannel\" class=\"headerlink\" title=\"MessageChannel\"></a>MessageChannel</h4><p>MessageChannel API 允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。<br>我们可以创建一个 MessageChannel 并发送消息。在接收端，消息包含我们原始数据对象的结构化克隆。<br>MessageChannel 的 postMessage 传递的数据也是深拷贝的，这和 web worker 的 postMessage 一样。而且还可以拷贝 undefined 和循环引用的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有undefined + 循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: &#123;</span><br><span class=\"line\">    c: <span class=\"number\">2</span>,</span><br><span class=\"line\">    d: <span class=\"number\">3</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  f: <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.c = obj.b;</span><br><span class=\"line\">obj.e = obj.a;</span><br><span class=\"line\">obj.b.c = obj.c;</span><br><span class=\"line\">obj.b.d = obj.b;</span><br><span class=\"line\">obj.b.e = obj.b.c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\">    port2.onmessage = <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class=\"line\">    port1.postMessage(obj);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MessageChannel是异步的</span></span><br><span class=\"line\">deepCopy(obj).then(<span class=\"function\"><span class=\"params\">copy</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> copyObj = copy;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(copyObj, obj);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(copyObj == obj);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>但拷贝有函数的对象时，还是会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught （in promise） DOMException：Failed to execute &apos;postMessage&apos; on &apos;MessagePort&apos;: function() &#123;&#125; could not be cloned.</span><br></pre></td></tr></table></figure>\n<p>这种方法的缺点是它是异步的，但是你可以使用 await 来解决。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"keyword\">await</span> structuralClone(obj);</span><br></pre></td></tr></table></figure>\n<h4 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h4><p>如果你曾经使用 history.pushState()写过 SPA，你可以提供一个状态对象来保存 URL。事实证明，这个状态对象使用结构化克隆，而且是同步的。我们必须小心使用，不要把原有的路由状态搞乱了，所以我们需要在完成克隆之后恢复原始状态。为了防止发生任何意外，请使用 history.replaceState()而不是 history.pushState()。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> structuralClone = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldState = history.state;</span><br><span class=\"line\">  history.replaceState(obj, <span class=\"built_in\">document</span>.title);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = history.state;</span><br><span class=\"line\">  history.replaceState(oldState, <span class=\"built_in\">document</span>.title);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>此方法的优点是：能解决循环对象的问题，并且支持许多内置类型的克隆，也是同步的。缺点是有的浏览器对调用频率有限制。比如 Safari 30 秒内只允许调用 100 次</p>\n<h4 id=\"Notification\"><a href=\"#Notification\" class=\"headerlink\" title=\"Notification\"></a>Notification</h4><p>Notification 是用于桌面通知的。也可以用来实现 JS 对象的深拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">structuralClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Notification(<span class=\"string\">''</span>, &#123;<span class=\"attr\">data</span>: obj, <span class=\"attr\">silent</span>: <span class=\"literal\">true</span>&#125;).data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"comment\">/* ... */</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure>\n<p>此方法的优点就是可以解决循环对象问题，也支持许多内置类型的克隆，并且是同步的。缺点就是这个 api 的使用需要向用户请求权限，但是用在这里克隆数据的时候，不经用户授权也可以使用。在 http 协议的情况下会提示你再 https 的场景下使用。<br>由于某种原因，Safari 总是返回 undefined。</p>\n<h3 id=\"lodash-的深拷贝函数\"><a href=\"#lodash-的深拷贝函数\" class=\"headerlink\" title=\"lodash 的深拷贝函数\"></a>lodash 的深拷贝函数</h3><p>lodash 的_.cloneDeep()支持循环对象，和大量的内置类型，对很多细节都处理的比较不错，推荐使用。</p>\n<h3 id=\"解决循环引用\"><a href=\"#解决循环引用\" class=\"headerlink\" title=\"解决循环引用\"></a>解决循环引用</h3><p>通过分析上述的方法，发现只有结构化克隆算法才能解决循环引用的问题，那么使用原生 JS 如何解决呢？这里尝试使用闭包来解决循环问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> memo = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</span><br><span class=\"line\">      result = <span class=\"built_in\">eval</span>(obj.toString());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (memo[obj[key]]) &#123;</span><br><span class=\"line\">        result[key] = memo[obj[key]];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        memo[obj[key]] = obj[key];</span><br><span class=\"line\">        result[key] = clone(obj[key]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone(object);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123; obj &#125;;</span><br><span class=\"line\">obj.b = b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = deepClone(obj);</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，对递归拷贝进行了优化，使用闭包来解决循环拷贝的问题，使用了 memo 这个变量来记录被拷贝的引用地址，在每次递归前，记录递归的参数值，这样在递归内部就可以跳出递归，解决循环引用问题。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>如果您没有循环对象，并且不需要保留内置类型，则可以使用跨浏览器的 JSON.parse(JSON.stringify())获得最快的克隆性能。</li>\n<li>如果你想要一个适当的结构化克隆，MessageChannel 是你唯一可靠的跨浏览器的选择。</li>\n</ul>"},{"title":"理解ES6之箭头函数","date":"2017-02-02T11:49:49.000Z","banner":"http://img.yanyuanfe.cn/es6.png","_content":"\n\n\n> 当你看到箭头函数（Arrow Function）和（=>）的时候，我想你也能很容易将他们联系到一块儿。\n\n![image](http://img.yanyuanfe.cn/es6.png)\n\n<!--more-->\n\n<div class=\"tip\">\n    实习的时候，项目采用了React架构，代码中应用了ES6/7的规范，并使用了babel转译，也加入了相应的Polyfill库。可以预见ES6的发展已经越来越深入人心，在此处总结了ES6中箭头函数的用法。\n</div>\n\n### 箭袋中的新羽\n\nES6中引入了一种编写函数的新语法。  \n  \n  箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this, arguments, super 和 new.target 等对象）。此外，箭头函数总是匿名的。  \n  箭头函数的定义由一个参数列表（零个或多个参数，如果参数不是只有一个，需要有一个( .. )包围这些参数）组成，紧跟着是一个=>符号，然后是一个函数体。  \n  当你的函数中只有一个参数时，箭头函数的语法非常简单：标识符=>表达式。你无需输入function和return，一些小括号、大括号以及分号也可以省略。 \n``` js\n// ES5\nfunction foo(x) {\n    return ++x;\n}\n\n// ES6\nvar foo = x => ++x;\n```\n当你的函数中含有多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）时，你需要用小括号包裹参数list。\n\n``` js\n// ES5\nfunction foo(x,y) {\n    return x + y;\n}\n\nfunction bar() {\n    return 100\n}\n\n// ES6\nvar foo = (x,y) => x+y;\nvar bar = () => 100;\n```\n除表达式外，箭头函数还可以包含一个块语句。\n\n``` js\n// ES5\nfunction handleClick(e) {\n    e.preventDefault();\n    console.log('The link was clicked.');\n}\n\n// ES6\nfunction handleClick = e => {\n    e.preventDefault();\n    console.log('The link was clicked.');\n}\n```\n<div class=\"tip\">\n    注意:使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回。\n</div>\n\n<div class=\"tip\">\n提示：由于花括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上小括号。\n</div>\n\n\n```js\nlet name_maker = (first,last) => {firstname: first,lastname:last};  // 这样写会报SyntaxError！\n\nlet name_maker = (first,last) => ({firstname: first,lastname:last});\n```\n\n用小括号包裹空对象就可以了。\n\n不幸的是，一个空对象{}和一个空的块{}看起来完全一样。ES6中的规则是，紧随箭头的{被解析为块的开始，而不是对象的开始。因此，=>{}这段代码就被解析为没有任何行为并返回undefined的箭头函数。\n\n更令人困惑的是，你的JavaScript引擎会将类似{key: value}的对象字面量解析为一个包含标记语句的块。幸运的是，{是唯一一个有歧义的字符，所以用小括号包裹对象字面量是唯一一个你需要牢记的小窍门。\n\n### 箭头函数的this？\n\n在箭头函数出现之前，每个新定义的函数都有其自己的  this 值（例如，构造函数的 this 指向了一个新的对象；严格模式下的函数的 this 值为 undefined；如果函数是作为对象的方法被调用的，则其 this 指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。\n在ECMAScript 3/5中的普通function函数中，为了得到期望的this值，你可能会新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。除此之外，你也可以使用 bind 函数，把期望的 this 值传递给当前 函数。  \n箭头函数的出现解决了这个问题，箭头函数没有它自己的this值，它会捕获其所在上下文的this 值，作为自己的 this 值。\n来看看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n的例子。\n```js\nfunction Person() {\n  // 构造函数 Person() 定义的 `this` 就是新实例对象自己\n  this.age = 0;\n  setInterval(function growUp() {\n    // 在非严格模式下，growUp() 函数定义了其内部的 `this`\n    // 为全局对象, 不同于构造函数Person()的定义的 `this`\n    this.age++; \n  }, 1000);\n}\n\nvar p = new Person();\n\n```\n\n```js\n//ES5\nfunction Person() {\n  var self = this; // 也有人选择使用 `that` 而非 `self`. \n                   // 只要保证一致就好.\n  self.age = 0;\n\n  setInterval(function growUp() {\n    // 回调里面的 `self` 变量就指向了期望的那个对象了\n    self.age++;\n  }, 1000);\n}\n```\n在这里，你希望在内层函数里写的是this.agg++，不幸的是，内层函数并未从外层函数继承this的值。在内层函数里，this会是window或undefined，临时变量self用来将外部的this值导入内部函数。（另一种方式是在内部函数上执行.bind(this)，两种方法都不甚美观。）  \n在ES6中，不需要再hackthis了。\n```js\n//ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    this.age++; // |this| 正确地指向了 person 对象\n  }, 1000);\n}\n\nvar p = new Person();\n```\n```js\nvar adder = {\n  base : 1,\n    \n  add : function(a) {\n    var f = v => v + this.base;\n    return f(a);\n  },\n\n  addThruCall: function(a) {\n    var f = v => v + this.base;\n    var b = {\n      base : 2\n    };\n            \n    return f.call(b, a);\n  }\n};\n\nconsole.log(adder.add(1));         // 输出 2\nconsole.log(adder.addThruCall(1)); // 仍然输出 2（而不是3）\n```\n\n<div class=\"tip\">\n由于 this 已经在词法层面完成了绑定，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\n</div>\n\n\n当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。  \n\n箭头函数与非箭头函数间还有一个细微的区别，箭头函数不会获取它们自己的arguments对象。诚然，在ES6中，你可能更多地会使用不定参数和默认参数值这些新特性。\n\n### 箭头函数绑定\n\n箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。\n\n函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。  \n\n``` js\n// ES5\nbar.bind(foo);\n// ES7\nfoo::bar;\n\n// ES5\nbar.apply(foo, arguments);\n// ES7\nfoo::bar(...arguments);\n\n\n```\n\n如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。\n\n```js\n// ES5\nvar method = ::obj.foo;\n// ES7\nvar method = obj::obj.foo;\n```\n\n### 总结\n\n箭头函数有几个使用注意点。\n\n- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n- 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n- 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。  \n\n### 参考资料\n\n- [ES6标准入门](http://es6.ruanyifeng.com/#docs/function)\n\n- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n\n","source":"_posts/理解ES6之箭头函数.md","raw":"---\ntitle: 理解ES6之箭头函数\ndate: 2017-02-02 19:49:49\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/es6.png\ntags:\n\t- ES6\n---\n\n\n\n> 当你看到箭头函数（Arrow Function）和（=>）的时候，我想你也能很容易将他们联系到一块儿。\n\n![image](http://img.yanyuanfe.cn/es6.png)\n\n<!--more-->\n\n<div class=\"tip\">\n    实习的时候，项目采用了React架构，代码中应用了ES6/7的规范，并使用了babel转译，也加入了相应的Polyfill库。可以预见ES6的发展已经越来越深入人心，在此处总结了ES6中箭头函数的用法。\n</div>\n\n### 箭袋中的新羽\n\nES6中引入了一种编写函数的新语法。  \n  \n  箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this, arguments, super 和 new.target 等对象）。此外，箭头函数总是匿名的。  \n  箭头函数的定义由一个参数列表（零个或多个参数，如果参数不是只有一个，需要有一个( .. )包围这些参数）组成，紧跟着是一个=>符号，然后是一个函数体。  \n  当你的函数中只有一个参数时，箭头函数的语法非常简单：标识符=>表达式。你无需输入function和return，一些小括号、大括号以及分号也可以省略。 \n``` js\n// ES5\nfunction foo(x) {\n    return ++x;\n}\n\n// ES6\nvar foo = x => ++x;\n```\n当你的函数中含有多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）时，你需要用小括号包裹参数list。\n\n``` js\n// ES5\nfunction foo(x,y) {\n    return x + y;\n}\n\nfunction bar() {\n    return 100\n}\n\n// ES6\nvar foo = (x,y) => x+y;\nvar bar = () => 100;\n```\n除表达式外，箭头函数还可以包含一个块语句。\n\n``` js\n// ES5\nfunction handleClick(e) {\n    e.preventDefault();\n    console.log('The link was clicked.');\n}\n\n// ES6\nfunction handleClick = e => {\n    e.preventDefault();\n    console.log('The link was clicked.');\n}\n```\n<div class=\"tip\">\n    注意:使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回。\n</div>\n\n<div class=\"tip\">\n提示：由于花括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上小括号。\n</div>\n\n\n```js\nlet name_maker = (first,last) => {firstname: first,lastname:last};  // 这样写会报SyntaxError！\n\nlet name_maker = (first,last) => ({firstname: first,lastname:last});\n```\n\n用小括号包裹空对象就可以了。\n\n不幸的是，一个空对象{}和一个空的块{}看起来完全一样。ES6中的规则是，紧随箭头的{被解析为块的开始，而不是对象的开始。因此，=>{}这段代码就被解析为没有任何行为并返回undefined的箭头函数。\n\n更令人困惑的是，你的JavaScript引擎会将类似{key: value}的对象字面量解析为一个包含标记语句的块。幸运的是，{是唯一一个有歧义的字符，所以用小括号包裹对象字面量是唯一一个你需要牢记的小窍门。\n\n### 箭头函数的this？\n\n在箭头函数出现之前，每个新定义的函数都有其自己的  this 值（例如，构造函数的 this 指向了一个新的对象；严格模式下的函数的 this 值为 undefined；如果函数是作为对象的方法被调用的，则其 this 指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。\n在ECMAScript 3/5中的普通function函数中，为了得到期望的this值，你可能会新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。除此之外，你也可以使用 bind 函数，把期望的 this 值传递给当前 函数。  \n箭头函数的出现解决了这个问题，箭头函数没有它自己的this值，它会捕获其所在上下文的this 值，作为自己的 this 值。\n来看看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n的例子。\n```js\nfunction Person() {\n  // 构造函数 Person() 定义的 `this` 就是新实例对象自己\n  this.age = 0;\n  setInterval(function growUp() {\n    // 在非严格模式下，growUp() 函数定义了其内部的 `this`\n    // 为全局对象, 不同于构造函数Person()的定义的 `this`\n    this.age++; \n  }, 1000);\n}\n\nvar p = new Person();\n\n```\n\n```js\n//ES5\nfunction Person() {\n  var self = this; // 也有人选择使用 `that` 而非 `self`. \n                   // 只要保证一致就好.\n  self.age = 0;\n\n  setInterval(function growUp() {\n    // 回调里面的 `self` 变量就指向了期望的那个对象了\n    self.age++;\n  }, 1000);\n}\n```\n在这里，你希望在内层函数里写的是this.agg++，不幸的是，内层函数并未从外层函数继承this的值。在内层函数里，this会是window或undefined，临时变量self用来将外部的this值导入内部函数。（另一种方式是在内部函数上执行.bind(this)，两种方法都不甚美观。）  \n在ES6中，不需要再hackthis了。\n```js\n//ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    this.age++; // |this| 正确地指向了 person 对象\n  }, 1000);\n}\n\nvar p = new Person();\n```\n```js\nvar adder = {\n  base : 1,\n    \n  add : function(a) {\n    var f = v => v + this.base;\n    return f(a);\n  },\n\n  addThruCall: function(a) {\n    var f = v => v + this.base;\n    var b = {\n      base : 2\n    };\n            \n    return f.call(b, a);\n  }\n};\n\nconsole.log(adder.add(1));         // 输出 2\nconsole.log(adder.addThruCall(1)); // 仍然输出 2（而不是3）\n```\n\n<div class=\"tip\">\n由于 this 已经在词法层面完成了绑定，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\n</div>\n\n\n当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。  \n\n箭头函数与非箭头函数间还有一个细微的区别，箭头函数不会获取它们自己的arguments对象。诚然，在ES6中，你可能更多地会使用不定参数和默认参数值这些新特性。\n\n### 箭头函数绑定\n\n箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。\n\n函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。  \n\n``` js\n// ES5\nbar.bind(foo);\n// ES7\nfoo::bar;\n\n// ES5\nbar.apply(foo, arguments);\n// ES7\nfoo::bar(...arguments);\n\n\n```\n\n如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。\n\n```js\n// ES5\nvar method = ::obj.foo;\n// ES7\nvar method = obj::obj.foo;\n```\n\n### 总结\n\n箭头函数有几个使用注意点。\n\n- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n- 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n- 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。  \n\n### 参考资料\n\n- [ES6标准入门](http://es6.ruanyifeng.com/#docs/function)\n\n- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n\n","slug":"理解ES6之箭头函数","published":1,"updated":"2020-07-16T13:56:47.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenog002cp70vqhjpj5uz","content":"<blockquote>\n<p>当你看到箭头函数（Arrow Function）和（=&gt;）的时候，我想你也能很容易将他们联系到一块儿。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/es6.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<div class=\"tip\"><br>    实习的时候，项目采用了React架构，代码中应用了ES6/7的规范，并使用了babel转译，也加入了相应的Polyfill库。可以预见ES6的发展已经越来越深入人心，在此处总结了ES6中箭头函数的用法。<br></div>\n\n<h3 id=\"箭袋中的新羽\"><a href=\"#箭袋中的新羽\" class=\"headerlink\" title=\"箭袋中的新羽\"></a>箭袋中的新羽</h3><p>ES6中引入了一种编写函数的新语法。  </p>\n<p>  箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this, arguments, super 和 new.target 等对象）。此外，箭头函数总是匿名的。<br>  箭头函数的定义由一个参数列表（零个或多个参数，如果参数不是只有一个，需要有一个( .. )包围这些参数）组成，紧跟着是一个=&gt;符号，然后是一个函数体。<br>  当你的函数中只有一个参数时，箭头函数的语法非常简单：标识符=&gt;表达式。你无需输入function和return，一些小括号、大括号以及分号也可以省略。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> ++x;</span><br></pre></td></tr></table></figure></p>\n<p>当你的函数中含有多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）时，你需要用小括号包裹参数list。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> x+y;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<p>除表达式外，箭头函数还可以包含一个块语句。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The link was clicked.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span> = <span class=\"title\">e</span> =&gt; </span>&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The link was clicked.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>    注意:使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回。<br></div>\n\n<div class=\"tip\"><br>提示：由于花括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上小括号。<br></div>\n\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name_maker = <span class=\"function\">(<span class=\"params\">first,last</span>) =&gt;</span> &#123;<span class=\"attr\">firstname</span>: first,<span class=\"attr\">lastname</span>:last&#125;;  <span class=\"comment\">// 这样写会报SyntaxError！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> name_maker = <span class=\"function\">(<span class=\"params\">first,last</span>) =&gt;</span> (&#123;<span class=\"attr\">firstname</span>: first,<span class=\"attr\">lastname</span>:last&#125;);</span><br></pre></td></tr></table></figure>\n<p>用小括号包裹空对象就可以了。</p>\n<p>不幸的是，一个空对象{}和一个空的块{}看起来完全一样。ES6中的规则是，紧随箭头的{被解析为块的开始，而不是对象的开始。因此，=&gt;{}这段代码就被解析为没有任何行为并返回undefined的箭头函数。</p>\n<p>更令人困惑的是，你的JavaScript引擎会将类似{key: value}的对象字面量解析为一个包含标记语句的块。幸运的是，{是唯一一个有歧义的字符，所以用小括号包裹对象字面量是唯一一个你需要牢记的小窍门。</p>\n<h3 id=\"箭头函数的this？\"><a href=\"#箭头函数的this？\" class=\"headerlink\" title=\"箭头函数的this？\"></a>箭头函数的this？</h3><p>在箭头函数出现之前，每个新定义的函数都有其自己的  this 值（例如，构造函数的 this 指向了一个新的对象；严格模式下的函数的 this 值为 undefined；如果函数是作为对象的方法被调用的，则其 this 指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。<br>在ECMAScript 3/5中的普通function函数中，为了得到期望的this值，你可能会新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。除此之外，你也可以使用 bind 函数，把期望的 this 值传递给当前 函数。<br>箭头函数的出现解决了这个问题，箭头函数没有它自己的this值，它会捕获其所在上下文的this 值，作为自己的 this 值。<br>来看看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">MDN</a><br>的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 构造函数 Person() 定义的 `this` 就是新实例对象自己</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在非严格模式下，growUp() 函数定义了其内部的 `this`</span></span><br><span class=\"line\">    <span class=\"comment\">// 为全局对象, 不同于构造函数Person()的定义的 `this`</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age++; </span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">// 也有人选择使用 `that` 而非 `self`. </span></span><br><span class=\"line\">                   <span class=\"comment\">// 只要保证一致就好.</span></span><br><span class=\"line\">  self.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回调里面的 `self` 变量就指向了期望的那个对象了</span></span><br><span class=\"line\">    self.age++;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，你希望在内层函数里写的是this.agg++，不幸的是，内层函数并未从外层函数继承this的值。在内层函数里，this会是window或undefined，临时变量self用来将外部的this值导入内部函数。（另一种方式是在内部函数上执行.bind(this)，两种方法都不甚美观。）<br>在ES6中，不需要再hackthis了。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age++; <span class=\"comment\">// |this| 正确地指向了 person 对象</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> adder = &#123;</span><br><span class=\"line\">  base : <span class=\"number\">1</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">  add : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(a);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  addThruCall: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">      base : <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(b, a);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.add(<span class=\"number\">1</span>));         <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.addThruCall(<span class=\"number\">1</span>)); <span class=\"comment\">// 仍然输出 2（而不是3）</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>由于 this 已经在词法层面完成了绑定，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。<br></div>\n\n\n<p>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。  </p>\n<p>箭头函数与非箭头函数间还有一个细微的区别，箭头函数不会获取它们自己的arguments对象。诚然，在ES6中，你可能更多地会使用不定参数和默认参数值这些新特性。</p>\n<h3 id=\"箭头函数绑定\"><a href=\"#箭头函数绑定\" class=\"headerlink\" title=\"箭头函数绑定\"></a>箭头函数绑定</h3><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>\n<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\">bar.bind(foo);</span><br><span class=\"line\"><span class=\"comment\">// ES7</span></span><br><span class=\"line\">foo::bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\">bar.apply(foo, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"comment\">// ES7</span></span><br><span class=\"line\">foo::bar(...arguments);</span><br></pre></td></tr></table></figure>\n<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> method = ::obj.foo;</span><br><span class=\"line\"><span class=\"comment\">// ES7</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> method = obj::obj.foo;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>箭头函数有几个使用注意点。</p>\n<ul>\n<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n</li>\n<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>\n</li>\n<li><p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。  </p>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/function\" target=\"_blank\" rel=\"noopener\">ES6标准入门</a></p>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>当你看到箭头函数（Arrow Function）和（=&gt;）的时候，我想你也能很容易将他们联系到一块儿。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/es6.png\" alt=\"image\"></p>","more":"<div class=\"tip\"><br>    实习的时候，项目采用了React架构，代码中应用了ES6/7的规范，并使用了babel转译，也加入了相应的Polyfill库。可以预见ES6的发展已经越来越深入人心，在此处总结了ES6中箭头函数的用法。<br></div>\n\n<h3 id=\"箭袋中的新羽\"><a href=\"#箭袋中的新羽\" class=\"headerlink\" title=\"箭袋中的新羽\"></a>箭袋中的新羽</h3><p>ES6中引入了一种编写函数的新语法。  </p>\n<p>  箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this, arguments, super 和 new.target 等对象）。此外，箭头函数总是匿名的。<br>  箭头函数的定义由一个参数列表（零个或多个参数，如果参数不是只有一个，需要有一个( .. )包围这些参数）组成，紧跟着是一个=&gt;符号，然后是一个函数体。<br>  当你的函数中只有一个参数时，箭头函数的语法非常简单：标识符=&gt;表达式。你无需输入function和return，一些小括号、大括号以及分号也可以省略。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> ++x;</span><br></pre></td></tr></table></figure></p>\n<p>当你的函数中含有多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）时，你需要用小括号包裹参数list。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> x+y;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<p>除表达式外，箭头函数还可以包含一个块语句。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The link was clicked.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span> = <span class=\"title\">e</span> =&gt; </span>&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The link was clicked.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>    注意:使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回。<br></div>\n\n<div class=\"tip\"><br>提示：由于花括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上小括号。<br></div>\n\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name_maker = <span class=\"function\">(<span class=\"params\">first,last</span>) =&gt;</span> &#123;<span class=\"attr\">firstname</span>: first,<span class=\"attr\">lastname</span>:last&#125;;  <span class=\"comment\">// 这样写会报SyntaxError！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> name_maker = <span class=\"function\">(<span class=\"params\">first,last</span>) =&gt;</span> (&#123;<span class=\"attr\">firstname</span>: first,<span class=\"attr\">lastname</span>:last&#125;);</span><br></pre></td></tr></table></figure>\n<p>用小括号包裹空对象就可以了。</p>\n<p>不幸的是，一个空对象{}和一个空的块{}看起来完全一样。ES6中的规则是，紧随箭头的{被解析为块的开始，而不是对象的开始。因此，=&gt;{}这段代码就被解析为没有任何行为并返回undefined的箭头函数。</p>\n<p>更令人困惑的是，你的JavaScript引擎会将类似{key: value}的对象字面量解析为一个包含标记语句的块。幸运的是，{是唯一一个有歧义的字符，所以用小括号包裹对象字面量是唯一一个你需要牢记的小窍门。</p>\n<h3 id=\"箭头函数的this？\"><a href=\"#箭头函数的this？\" class=\"headerlink\" title=\"箭头函数的this？\"></a>箭头函数的this？</h3><p>在箭头函数出现之前，每个新定义的函数都有其自己的  this 值（例如，构造函数的 this 指向了一个新的对象；严格模式下的函数的 this 值为 undefined；如果函数是作为对象的方法被调用的，则其 this 指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。<br>在ECMAScript 3/5中的普通function函数中，为了得到期望的this值，你可能会新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。除此之外，你也可以使用 bind 函数，把期望的 this 值传递给当前 函数。<br>箭头函数的出现解决了这个问题，箭头函数没有它自己的this值，它会捕获其所在上下文的this 值，作为自己的 this 值。<br>来看看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">MDN</a><br>的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 构造函数 Person() 定义的 `this` 就是新实例对象自己</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在非严格模式下，growUp() 函数定义了其内部的 `this`</span></span><br><span class=\"line\">    <span class=\"comment\">// 为全局对象, 不同于构造函数Person()的定义的 `this`</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age++; </span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">// 也有人选择使用 `that` 而非 `self`. </span></span><br><span class=\"line\">                   <span class=\"comment\">// 只要保证一致就好.</span></span><br><span class=\"line\">  self.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回调里面的 `self` 变量就指向了期望的那个对象了</span></span><br><span class=\"line\">    self.age++;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，你希望在内层函数里写的是this.agg++，不幸的是，内层函数并未从外层函数继承this的值。在内层函数里，this会是window或undefined，临时变量self用来将外部的this值导入内部函数。（另一种方式是在内部函数上执行.bind(this)，两种方法都不甚美观。）<br>在ES6中，不需要再hackthis了。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age++; <span class=\"comment\">// |this| 正确地指向了 person 对象</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> adder = &#123;</span><br><span class=\"line\">  base : <span class=\"number\">1</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">  add : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(a);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  addThruCall: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">      base : <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(b, a);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.add(<span class=\"number\">1</span>));         <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.addThruCall(<span class=\"number\">1</span>)); <span class=\"comment\">// 仍然输出 2（而不是3）</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>由于 this 已经在词法层面完成了绑定，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。<br></div>\n\n\n<p>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。  </p>\n<p>箭头函数与非箭头函数间还有一个细微的区别，箭头函数不会获取它们自己的arguments对象。诚然，在ES6中，你可能更多地会使用不定参数和默认参数值这些新特性。</p>\n<h3 id=\"箭头函数绑定\"><a href=\"#箭头函数绑定\" class=\"headerlink\" title=\"箭头函数绑定\"></a>箭头函数绑定</h3><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>\n<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\">bar.bind(foo);</span><br><span class=\"line\"><span class=\"comment\">// ES7</span></span><br><span class=\"line\">foo::bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\">bar.apply(foo, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"comment\">// ES7</span></span><br><span class=\"line\">foo::bar(...arguments);</span><br></pre></td></tr></table></figure>\n<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> method = ::obj.foo;</span><br><span class=\"line\"><span class=\"comment\">// ES7</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> method = obj::obj.foo;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>箭头函数有几个使用注意点。</p>\n<ul>\n<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n</li>\n<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>\n</li>\n<li><p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。  </p>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/function\" target=\"_blank\" rel=\"noopener\">ES6标准入门</a></p>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</li>\n</ul>"},{"title":"理解React组件生命周期","date":"2017-01-24T14:10:27.000Z","banner":"http://img.yanyuanfe.cn/react_illo_800x600_1x.png","_content":"\n\n> 了解组件生命周期将使你能够在创建或销毁组件时执行某些操作。 此外，它让您有机会决定是否应该首先更新组件，并相应地对属性（props）或状态（state）更改做出反应。\n\n![image](http://img.yanyuanfe.cn/react_illo_800x600_1x.png)\n\n<!--more-->\n\n<div class=\"tip\">\n    在公司实习已经一个月了，第一个项目是使用React+React-Redux架构的Webapp，在项目过程中对React的理解从入门到逐渐加深，所以写下这篇文章总结一下心得。\n</div>\n\n### 生命周期\nReact通过调用React.createClass（）方法来创建组件，React.createClass（）方法需要一个render方法，并触发一个生命周期，它可以通过一些所谓的生命周期方法来实现。\n\n为了清楚地理解生命周期，我们需要区分组件被创建的初始创建阶段，状态和属性变化触发的更新阶段以及组件被卸载的阶段。\n\n### 初始化（Initialization）\n![image](http://img.yanyuanfe.cn/initial.png)\n\n从上面的图我们可以看到，前两个方法被调用的是getDefaultProps和getInitialState。这两个方法只在最初渲染组件时调用一次。 getInitialState方法允许设置初始状态值，这是通过this.state在组件内部可访问的。\n\n\n```js\ngetInitialState: function(){\n    return { /* something here */};\n}\n```\n\n\n类似地，getDefaultProps可以用于定义可以通过this.props访问的任何默认属性。\n\n```js\ngetDefaultProps: function(){\n    return { /* something here */};\n}\n```\n\n另一个只有在初始化组件时才调用的方法是componentWillMount和componentDidMount。  \n  \n  **componentWillMount**在执行render方法之前被调用。重要的是要注意，在此阶段中设置状态不会触发重新渲染。  \n  \n**render**方法返回所需的组件标记，它可以是单个子组件或null或false（以防您不想要任何渲染）。  \n这是生命周期中解释属性和状态值以创建正确输出的部分。在这个函数里面不应该修改属性和状态。这一点很重要，因为根据定义，render必须是纯函数，这意味着每次调用该方法时返回相同的结果。  \n  \n  一旦render方法被执行，**componentDidMount**函数被调用。在此方法中可以访问DOM，从而能够定义DOM操作或数据请求操作。任何DOM交互应该总是发生在这个阶段，而不是render方法内部。\n\n### 状态变化（State Changes）\n状态更改将触发许多钩子函数。\n![image](http://img.yanyuanfe.cn/statechange.png)  \n\n**shouldComponentUpdate**总是在render方法之前调用，并允许定义是否需要或跳过重新渲染。显然，这种方法从来没有在初始渲染时调用。必须返回布尔值。  \n\n```js\nshouldComponentUpdate: function(nextProps, nextState){\n    // return a boolean value\n    return true;\n}\n```\n此方法可以访问当前以及即将到来的属性和状态确保可以检测到可能的改变以确定是否需要渲染。  \nshouldComponentUpdate方法 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。很多人不了解这个方法而不知道它的重要性。\n\n**componentWillUpdate**在shouldComponentUpdate返回true时立即被调用。不允许通过this.setState进行任何状态更改，因为此方法应严格用于准备即将到来的更新而不触发更新本身。  \n\n```js\ncomponentWillUpdate: function(nextProps, nextState){\n    // perform any preparations for an upcoming update\n}\n```\n最后，在render方法之后调用**componentDidUpdate**。与componentDidMount类似，此方法可用于在数据更新后执行DOM操作。\n\n```js\ncomponentDidUpdate: function(prevProps, prevState){\n    // \n}\n```\n### 属性变更（Props Changes）\n对props对象的任何更改也将触发生命周期函数，并且几乎与状态更改相同，且有一个额外的方法被调用。\n![image](http://img.yanyuanfe.cn/changeprops.png)  \n**componentWillReceiveProps**仅在属性已更改并且不是初始渲染时调用。 componentWillReceiveProps允许根据现在和即将到来的属性来更新状态，而不触发另一个渲染。这里需要记住的一个有趣的事情是，没有等效的状态的方法，因为状态变化不应该触发任何属性的变化。\n\n```js\ncomponentWillReceiveProps: function(nextProps) {\n  this.setState({\n    // set something \n  });\n}\n```\n剩余的生命周期函数与状态改变触发方法相同，在这里没有什么不同。\n\n### 卸载（Unmounting）\n![image](http://img.yanyuanfe.cn/unmount.png)  \n\n组件卸载会触发的唯一一个方法是**componentWillUnmount**，当组件从DOM中移除之前调用componentWillUnmount。当需要执行清理操作时，该方法可能是有益的。删除componentDidMount中定义的任何计时器。\n\n### 思考\n\n> 在生命周期中的哪一步你应该发起 AJAX 请求？  \n\n我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：  \n\n- React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。\n\n- 如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。\n\n### 参考资料\n- [React官方文档](https://facebook.github.io/react/docs/react-component.html)\n","source":"_posts/理解React组件生命周期.md","raw":"---\ntitle: 理解React组件生命周期\ndate: 2017-01-24 22:10:27\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/react_illo_800x600_1x.png\ntags:\n\t- React\n---\n\n\n> 了解组件生命周期将使你能够在创建或销毁组件时执行某些操作。 此外，它让您有机会决定是否应该首先更新组件，并相应地对属性（props）或状态（state）更改做出反应。\n\n![image](http://img.yanyuanfe.cn/react_illo_800x600_1x.png)\n\n<!--more-->\n\n<div class=\"tip\">\n    在公司实习已经一个月了，第一个项目是使用React+React-Redux架构的Webapp，在项目过程中对React的理解从入门到逐渐加深，所以写下这篇文章总结一下心得。\n</div>\n\n### 生命周期\nReact通过调用React.createClass（）方法来创建组件，React.createClass（）方法需要一个render方法，并触发一个生命周期，它可以通过一些所谓的生命周期方法来实现。\n\n为了清楚地理解生命周期，我们需要区分组件被创建的初始创建阶段，状态和属性变化触发的更新阶段以及组件被卸载的阶段。\n\n### 初始化（Initialization）\n![image](http://img.yanyuanfe.cn/initial.png)\n\n从上面的图我们可以看到，前两个方法被调用的是getDefaultProps和getInitialState。这两个方法只在最初渲染组件时调用一次。 getInitialState方法允许设置初始状态值，这是通过this.state在组件内部可访问的。\n\n\n```js\ngetInitialState: function(){\n    return { /* something here */};\n}\n```\n\n\n类似地，getDefaultProps可以用于定义可以通过this.props访问的任何默认属性。\n\n```js\ngetDefaultProps: function(){\n    return { /* something here */};\n}\n```\n\n另一个只有在初始化组件时才调用的方法是componentWillMount和componentDidMount。  \n  \n  **componentWillMount**在执行render方法之前被调用。重要的是要注意，在此阶段中设置状态不会触发重新渲染。  \n  \n**render**方法返回所需的组件标记，它可以是单个子组件或null或false（以防您不想要任何渲染）。  \n这是生命周期中解释属性和状态值以创建正确输出的部分。在这个函数里面不应该修改属性和状态。这一点很重要，因为根据定义，render必须是纯函数，这意味着每次调用该方法时返回相同的结果。  \n  \n  一旦render方法被执行，**componentDidMount**函数被调用。在此方法中可以访问DOM，从而能够定义DOM操作或数据请求操作。任何DOM交互应该总是发生在这个阶段，而不是render方法内部。\n\n### 状态变化（State Changes）\n状态更改将触发许多钩子函数。\n![image](http://img.yanyuanfe.cn/statechange.png)  \n\n**shouldComponentUpdate**总是在render方法之前调用，并允许定义是否需要或跳过重新渲染。显然，这种方法从来没有在初始渲染时调用。必须返回布尔值。  \n\n```js\nshouldComponentUpdate: function(nextProps, nextState){\n    // return a boolean value\n    return true;\n}\n```\n此方法可以访问当前以及即将到来的属性和状态确保可以检测到可能的改变以确定是否需要渲染。  \nshouldComponentUpdate方法 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。很多人不了解这个方法而不知道它的重要性。\n\n**componentWillUpdate**在shouldComponentUpdate返回true时立即被调用。不允许通过this.setState进行任何状态更改，因为此方法应严格用于准备即将到来的更新而不触发更新本身。  \n\n```js\ncomponentWillUpdate: function(nextProps, nextState){\n    // perform any preparations for an upcoming update\n}\n```\n最后，在render方法之后调用**componentDidUpdate**。与componentDidMount类似，此方法可用于在数据更新后执行DOM操作。\n\n```js\ncomponentDidUpdate: function(prevProps, prevState){\n    // \n}\n```\n### 属性变更（Props Changes）\n对props对象的任何更改也将触发生命周期函数，并且几乎与状态更改相同，且有一个额外的方法被调用。\n![image](http://img.yanyuanfe.cn/changeprops.png)  \n**componentWillReceiveProps**仅在属性已更改并且不是初始渲染时调用。 componentWillReceiveProps允许根据现在和即将到来的属性来更新状态，而不触发另一个渲染。这里需要记住的一个有趣的事情是，没有等效的状态的方法，因为状态变化不应该触发任何属性的变化。\n\n```js\ncomponentWillReceiveProps: function(nextProps) {\n  this.setState({\n    // set something \n  });\n}\n```\n剩余的生命周期函数与状态改变触发方法相同，在这里没有什么不同。\n\n### 卸载（Unmounting）\n![image](http://img.yanyuanfe.cn/unmount.png)  \n\n组件卸载会触发的唯一一个方法是**componentWillUnmount**，当组件从DOM中移除之前调用componentWillUnmount。当需要执行清理操作时，该方法可能是有益的。删除componentDidMount中定义的任何计时器。\n\n### 思考\n\n> 在生命周期中的哪一步你应该发起 AJAX 请求？  \n\n我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：  \n\n- React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。\n\n- 如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。\n\n### 参考资料\n- [React官方文档](https://facebook.github.io/react/docs/react-component.html)\n","slug":"理解React组件生命周期","published":1,"updated":"2020-07-16T13:56:47.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenoh002fp70v462tv2oc","content":"<blockquote>\n<p>了解组件生命周期将使你能够在创建或销毁组件时执行某些操作。 此外，它让您有机会决定是否应该首先更新组件，并相应地对属性（props）或状态（state）更改做出反应。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react_illo_800x600_1x.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<div class=\"tip\"><br>    在公司实习已经一个月了，第一个项目是使用React+React-Redux架构的Webapp，在项目过程中对React的理解从入门到逐渐加深，所以写下这篇文章总结一下心得。<br></div>\n\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>React通过调用React.createClass（）方法来创建组件，React.createClass（）方法需要一个render方法，并触发一个生命周期，它可以通过一些所谓的生命周期方法来实现。</p>\n<p>为了清楚地理解生命周期，我们需要区分组件被创建的初始创建阶段，状态和属性变化触发的更新阶段以及组件被卸载的阶段。</p>\n<h3 id=\"初始化（Initialization）\"><a href=\"#初始化（Initialization）\" class=\"headerlink\" title=\"初始化（Initialization）\"></a>初始化（Initialization）</h3><p><img src=\"http://img.yanyuanfe.cn/initial.png\" alt=\"image\"></p>\n<p>从上面的图我们可以看到，前两个方法被调用的是getDefaultProps和getInitialState。这两个方法只在最初渲染组件时调用一次。 getInitialState方法允许设置初始状态值，这是通过this.state在组件内部可访问的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"comment\">/* something here */</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似地，getDefaultProps可以用于定义可以通过this.props访问的任何默认属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getDefaultProps: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"comment\">/* something here */</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个只有在初始化组件时才调用的方法是componentWillMount和componentDidMount。  </p>\n<p>  <strong>componentWillMount</strong>在执行render方法之前被调用。重要的是要注意，在此阶段中设置状态不会触发重新渲染。  </p>\n<p><strong>render</strong>方法返回所需的组件标记，它可以是单个子组件或null或false（以防您不想要任何渲染）。<br>这是生命周期中解释属性和状态值以创建正确输出的部分。在这个函数里面不应该修改属性和状态。这一点很重要，因为根据定义，render必须是纯函数，这意味着每次调用该方法时返回相同的结果。  </p>\n<p>  一旦render方法被执行，<strong>componentDidMount</strong>函数被调用。在此方法中可以访问DOM，从而能够定义DOM操作或数据请求操作。任何DOM交互应该总是发生在这个阶段，而不是render方法内部。</p>\n<h3 id=\"状态变化（State-Changes）\"><a href=\"#状态变化（State-Changes）\" class=\"headerlink\" title=\"状态变化（State Changes）\"></a>状态变化（State Changes）</h3><p>状态更改将触发许多钩子函数。<br><img src=\"http://img.yanyuanfe.cn/statechange.png\" alt=\"image\">  </p>\n<p><strong>shouldComponentUpdate</strong>总是在render方法之前调用，并允许定义是否需要或跳过重新渲染。显然，这种方法从来没有在初始渲染时调用。必须返回布尔值。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps, nextState</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// return a boolean value</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法可以访问当前以及即将到来的属性和状态确保可以检测到可能的改变以确定是否需要渲染。<br>shouldComponentUpdate方法 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。很多人不了解这个方法而不知道它的重要性。</p>\n<p><strong>componentWillUpdate</strong>在shouldComponentUpdate返回true时立即被调用。不允许通过this.setState进行任何状态更改，因为此方法应严格用于准备即将到来的更新而不触发更新本身。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentWillUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps, nextState</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// perform any preparations for an upcoming update</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，在render方法之后调用<strong>componentDidUpdate</strong>。与componentDidMount类似，此方法可用于在数据更新后执行DOM操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevProps, prevState</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性变更（Props-Changes）\"><a href=\"#属性变更（Props-Changes）\" class=\"headerlink\" title=\"属性变更（Props Changes）\"></a>属性变更（Props Changes）</h3><p>对props对象的任何更改也将触发生命周期函数，并且几乎与状态更改相同，且有一个额外的方法被调用。<br><img src=\"http://img.yanyuanfe.cn/changeprops.png\" alt=\"image\"><br><strong>componentWillReceiveProps</strong>仅在属性已更改并且不是初始渲染时调用。 componentWillReceiveProps允许根据现在和即将到来的属性来更新状态，而不触发另一个渲染。这里需要记住的一个有趣的事情是，没有等效的状态的方法，因为状态变化不应该触发任何属性的变化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentWillReceiveProps: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// set something </span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>剩余的生命周期函数与状态改变触发方法相同，在这里没有什么不同。</p>\n<h3 id=\"卸载（Unmounting）\"><a href=\"#卸载（Unmounting）\" class=\"headerlink\" title=\"卸载（Unmounting）\"></a>卸载（Unmounting）</h3><p><img src=\"http://img.yanyuanfe.cn/unmount.png\" alt=\"image\">  </p>\n<p>组件卸载会触发的唯一一个方法是<strong>componentWillUnmount</strong>，当组件从DOM中移除之前调用componentWillUnmount。当需要执行清理操作时，该方法可能是有益的。删除componentDidMount中定义的任何计时器。</p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><blockquote>\n<p>在生命周期中的哪一步你应该发起 AJAX 请求？  </p>\n</blockquote>\n<p>我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：  </p>\n<ul>\n<li><p>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</p>\n</li>\n<li><p>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。</p>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://facebook.github.io/react/docs/react-component.html\" target=\"_blank\" rel=\"noopener\">React官方文档</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>了解组件生命周期将使你能够在创建或销毁组件时执行某些操作。 此外，它让您有机会决定是否应该首先更新组件，并相应地对属性（props）或状态（state）更改做出反应。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react_illo_800x600_1x.png\" alt=\"image\"></p>","more":"<div class=\"tip\"><br>    在公司实习已经一个月了，第一个项目是使用React+React-Redux架构的Webapp，在项目过程中对React的理解从入门到逐渐加深，所以写下这篇文章总结一下心得。<br></div>\n\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>React通过调用React.createClass（）方法来创建组件，React.createClass（）方法需要一个render方法，并触发一个生命周期，它可以通过一些所谓的生命周期方法来实现。</p>\n<p>为了清楚地理解生命周期，我们需要区分组件被创建的初始创建阶段，状态和属性变化触发的更新阶段以及组件被卸载的阶段。</p>\n<h3 id=\"初始化（Initialization）\"><a href=\"#初始化（Initialization）\" class=\"headerlink\" title=\"初始化（Initialization）\"></a>初始化（Initialization）</h3><p><img src=\"http://img.yanyuanfe.cn/initial.png\" alt=\"image\"></p>\n<p>从上面的图我们可以看到，前两个方法被调用的是getDefaultProps和getInitialState。这两个方法只在最初渲染组件时调用一次。 getInitialState方法允许设置初始状态值，这是通过this.state在组件内部可访问的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"comment\">/* something here */</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似地，getDefaultProps可以用于定义可以通过this.props访问的任何默认属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getDefaultProps: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"comment\">/* something here */</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个只有在初始化组件时才调用的方法是componentWillMount和componentDidMount。  </p>\n<p>  <strong>componentWillMount</strong>在执行render方法之前被调用。重要的是要注意，在此阶段中设置状态不会触发重新渲染。  </p>\n<p><strong>render</strong>方法返回所需的组件标记，它可以是单个子组件或null或false（以防您不想要任何渲染）。<br>这是生命周期中解释属性和状态值以创建正确输出的部分。在这个函数里面不应该修改属性和状态。这一点很重要，因为根据定义，render必须是纯函数，这意味着每次调用该方法时返回相同的结果。  </p>\n<p>  一旦render方法被执行，<strong>componentDidMount</strong>函数被调用。在此方法中可以访问DOM，从而能够定义DOM操作或数据请求操作。任何DOM交互应该总是发生在这个阶段，而不是render方法内部。</p>\n<h3 id=\"状态变化（State-Changes）\"><a href=\"#状态变化（State-Changes）\" class=\"headerlink\" title=\"状态变化（State Changes）\"></a>状态变化（State Changes）</h3><p>状态更改将触发许多钩子函数。<br><img src=\"http://img.yanyuanfe.cn/statechange.png\" alt=\"image\">  </p>\n<p><strong>shouldComponentUpdate</strong>总是在render方法之前调用，并允许定义是否需要或跳过重新渲染。显然，这种方法从来没有在初始渲染时调用。必须返回布尔值。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps, nextState</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// return a boolean value</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法可以访问当前以及即将到来的属性和状态确保可以检测到可能的改变以确定是否需要渲染。<br>shouldComponentUpdate方法 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。很多人不了解这个方法而不知道它的重要性。</p>\n<p><strong>componentWillUpdate</strong>在shouldComponentUpdate返回true时立即被调用。不允许通过this.setState进行任何状态更改，因为此方法应严格用于准备即将到来的更新而不触发更新本身。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentWillUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps, nextState</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// perform any preparations for an upcoming update</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，在render方法之后调用<strong>componentDidUpdate</strong>。与componentDidMount类似，此方法可用于在数据更新后执行DOM操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentDidUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevProps, prevState</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性变更（Props-Changes）\"><a href=\"#属性变更（Props-Changes）\" class=\"headerlink\" title=\"属性变更（Props Changes）\"></a>属性变更（Props Changes）</h3><p>对props对象的任何更改也将触发生命周期函数，并且几乎与状态更改相同，且有一个额外的方法被调用。<br><img src=\"http://img.yanyuanfe.cn/changeprops.png\" alt=\"image\"><br><strong>componentWillReceiveProps</strong>仅在属性已更改并且不是初始渲染时调用。 componentWillReceiveProps允许根据现在和即将到来的属性来更新状态，而不触发另一个渲染。这里需要记住的一个有趣的事情是，没有等效的状态的方法，因为状态变化不应该触发任何属性的变化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">componentWillReceiveProps: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// set something </span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>剩余的生命周期函数与状态改变触发方法相同，在这里没有什么不同。</p>\n<h3 id=\"卸载（Unmounting）\"><a href=\"#卸载（Unmounting）\" class=\"headerlink\" title=\"卸载（Unmounting）\"></a>卸载（Unmounting）</h3><p><img src=\"http://img.yanyuanfe.cn/unmount.png\" alt=\"image\">  </p>\n<p>组件卸载会触发的唯一一个方法是<strong>componentWillUnmount</strong>，当组件从DOM中移除之前调用componentWillUnmount。当需要执行清理操作时，该方法可能是有益的。删除componentDidMount中定义的任何计时器。</p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><blockquote>\n<p>在生命周期中的哪一步你应该发起 AJAX 请求？  </p>\n</blockquote>\n<p>我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：  </p>\n<ul>\n<li><p>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</p>\n</li>\n<li><p>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。</p>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://facebook.github.io/react/docs/react-component.html\" target=\"_blank\" rel=\"noopener\">React官方文档</a></li>\n</ul>"},{"title":"理解Redux","date":"2018-02-06T06:30:55.000Z","banner":"http://img.yanyuanfe.cn/stock-photo-245270081.jpg","_content":"\n> Redux的核心思想是Web应用是一个状态机，视图与状态是一一对应的。\n\n![image](http://img.yanyuanfe.cn/redux.png)\n\n<!--more-->\n\n> 最近一年的工作中都在使用React相关的技术栈，当初理解Redux也费了很大功夫，一直都想写一点关于Redux的教程，现在，终于开始了。\n\n### 为什么使用Redux\n\nRedux的出现是为了解决Javascript中复杂的状态管理，当你的应用变得庞大，需要处理复杂的交互场景时，你可以尝试使用Redux。如果你使用React，如果你需要共享状态到很多组件中，如果你需要处理异步，如果一个组件的状态改变需要更新其他组件，你可能需要Redux。\n\n### 介绍\nRedux 是 JavaScript 状态容器，提供可预测化的状态管理。\n\nRedux专注于状态管理，和react解耦。\n\nRedux 可以用这三个基本原则来描述：\n\n- 单一状态树\n\n整个应用的 state 被储存在一棵对象树中，并且这个对象树只存在于唯一一个store中。\n\n- State 是只读的\n\n唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n\n- 使用纯函数来执行修改\n\n为了描述 action 如何改变 state树，你需要编写 reducers。\n\n### Action\n\nAction 本质上是 JavaScript 普通对象。Redux约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放action。\n\nRedux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。\nstore 里能直接通过 store.dispatch() 调用 dispatch() 方法。\n\n### Reducer\n\nReducers 根据传入的action和state计算新的state。\n\nReducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。\n只要传入参数相同，计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。\n\n1. reducer中不要修改state，而是返回新对象。 可以使用 Object.assign() 新建一个副本。不能这样使用：\n\n``` js\nObject.assign(state, { visibilityFilter: action.filter })\n```\n上述代码会改变第一个参数的值。必须把第一个参数设置为空对象。也可以开启ES7使用对象展开运算符, 从而使用 { ...state, ...newState } 达到相同的目的。\n3. 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。\n\n## Store\n\nstore 是维持应用state的容器，并在当你发起 action 的时候调用 reducer。\nStore 就是把它们联系到一起的对象。Store 有以下职责：\n- 维持应用的 state；\n- 提供 getState() 方法获取 state；\n- 提供 dispatch(action) 方法更新 state；\n- 通过 subscribe(listener) 注册监听器;\n- 通过 subscribe(listener)返回的函数注销监听器。\n\nRedux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 多个reducer 组合而不是创建多个 store。\n\n### 数据流\n\nRedux 应用中数据的生命周期遵循下面 4 个步骤：\n1. 调用 store.dispatch(action)。\n\n你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。\n\n2. Redux store 调用传入的 reducer 函数。\n\nStore 会把两个参数传入 reducer： 当前的 state 树和 action。\n\n3. 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。\n\n4. Redux store 保存了根 reducer 返回的完整 state 树。\n\n### 总结\n\n本文只是一些关于redux的概念和基本介绍，下次会带来它的基本用法。","source":"_posts/理解Redux.md","raw":"---\ntitle: 理解Redux\ndate: 2018-02-06 14:30:55\nbanner: http://img.yanyuanfe.cn/stock-photo-245270081.jpg\ntags:\n  - React\n  - Redux\n---\n\n> Redux的核心思想是Web应用是一个状态机，视图与状态是一一对应的。\n\n![image](http://img.yanyuanfe.cn/redux.png)\n\n<!--more-->\n\n> 最近一年的工作中都在使用React相关的技术栈，当初理解Redux也费了很大功夫，一直都想写一点关于Redux的教程，现在，终于开始了。\n\n### 为什么使用Redux\n\nRedux的出现是为了解决Javascript中复杂的状态管理，当你的应用变得庞大，需要处理复杂的交互场景时，你可以尝试使用Redux。如果你使用React，如果你需要共享状态到很多组件中，如果你需要处理异步，如果一个组件的状态改变需要更新其他组件，你可能需要Redux。\n\n### 介绍\nRedux 是 JavaScript 状态容器，提供可预测化的状态管理。\n\nRedux专注于状态管理，和react解耦。\n\nRedux 可以用这三个基本原则来描述：\n\n- 单一状态树\n\n整个应用的 state 被储存在一棵对象树中，并且这个对象树只存在于唯一一个store中。\n\n- State 是只读的\n\n唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n\n- 使用纯函数来执行修改\n\n为了描述 action 如何改变 state树，你需要编写 reducers。\n\n### Action\n\nAction 本质上是 JavaScript 普通对象。Redux约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放action。\n\nRedux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。\nstore 里能直接通过 store.dispatch() 调用 dispatch() 方法。\n\n### Reducer\n\nReducers 根据传入的action和state计算新的state。\n\nReducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。\n只要传入参数相同，计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。\n\n1. reducer中不要修改state，而是返回新对象。 可以使用 Object.assign() 新建一个副本。不能这样使用：\n\n``` js\nObject.assign(state, { visibilityFilter: action.filter })\n```\n上述代码会改变第一个参数的值。必须把第一个参数设置为空对象。也可以开启ES7使用对象展开运算符, 从而使用 { ...state, ...newState } 达到相同的目的。\n3. 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。\n\n## Store\n\nstore 是维持应用state的容器，并在当你发起 action 的时候调用 reducer。\nStore 就是把它们联系到一起的对象。Store 有以下职责：\n- 维持应用的 state；\n- 提供 getState() 方法获取 state；\n- 提供 dispatch(action) 方法更新 state；\n- 通过 subscribe(listener) 注册监听器;\n- 通过 subscribe(listener)返回的函数注销监听器。\n\nRedux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 多个reducer 组合而不是创建多个 store。\n\n### 数据流\n\nRedux 应用中数据的生命周期遵循下面 4 个步骤：\n1. 调用 store.dispatch(action)。\n\n你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。\n\n2. Redux store 调用传入的 reducer 函数。\n\nStore 会把两个参数传入 reducer： 当前的 state 树和 action。\n\n3. 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。\n\n4. Redux store 保存了根 reducer 返回的完整 state 树。\n\n### 总结\n\n本文只是一些关于redux的概念和基本介绍，下次会带来它的基本用法。","slug":"理解Redux","published":1,"updated":"2020-07-16T13:56:47.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenoi002jp70vclamd016","content":"<blockquote>\n<p>Redux的核心思想是Web应用是一个状态机，视图与状态是一一对应的。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/redux.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<blockquote>\n<p>最近一年的工作中都在使用React相关的技术栈，当初理解Redux也费了很大功夫，一直都想写一点关于Redux的教程，现在，终于开始了。</p>\n</blockquote>\n<h3 id=\"为什么使用Redux\"><a href=\"#为什么使用Redux\" class=\"headerlink\" title=\"为什么使用Redux\"></a>为什么使用Redux</h3><p>Redux的出现是为了解决Javascript中复杂的状态管理，当你的应用变得庞大，需要处理复杂的交互场景时，你可以尝试使用Redux。如果你使用React，如果你需要共享状态到很多组件中，如果你需要处理异步，如果一个组件的状态改变需要更新其他组件，你可能需要Redux。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>\n<p>Redux专注于状态管理，和react解耦。</p>\n<p>Redux 可以用这三个基本原则来描述：</p>\n<ul>\n<li>单一状态树</li>\n</ul>\n<p>整个应用的 state 被储存在一棵对象树中，并且这个对象树只存在于唯一一个store中。</p>\n<ul>\n<li>State 是只读的</li>\n</ul>\n<p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p>\n<ul>\n<li>使用纯函数来执行修改</li>\n</ul>\n<p>为了描述 action 如何改变 state树，你需要编写 reducers。</p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>Action 本质上是 JavaScript 普通对象。Redux约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放action。</p>\n<p>Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。<br>store 里能直接通过 store.dispatch() 调用 dispatch() 方法。</p>\n<h3 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h3><p>Reducers 根据传入的action和state计算新的state。</p>\n<p>Reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。<br>只要传入参数相同，计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</p>\n<ol>\n<li>reducer中不要修改state，而是返回新对象。 可以使用 Object.assign() 新建一个副本。不能这样使用：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(state, &#123; <span class=\"attr\">visibilityFilter</span>: action.filter &#125;)</span><br></pre></td></tr></table></figure>\n<p>上述代码会改变第一个参数的值。必须把第一个参数设置为空对象。也可以开启ES7使用对象展开运算符, 从而使用 { …state, …newState } 达到相同的目的。</p>\n<ol start=\"3\">\n<li>在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。</li>\n</ol>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p>store 是维持应用state的容器，并在当你发起 action 的时候调用 reducer。<br>Store 就是把它们联系到一起的对象。Store 有以下职责：</p>\n<ul>\n<li>维持应用的 state；</li>\n<li>提供 getState() 方法获取 state；</li>\n<li>提供 dispatch(action) 方法更新 state；</li>\n<li>通过 subscribe(listener) 注册监听器;</li>\n<li>通过 subscribe(listener)返回的函数注销监听器。</li>\n</ul>\n<p>Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 多个reducer 组合而不是创建多个 store。</p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>\n<ol>\n<li>调用 store.dispatch(action)。</li>\n</ol>\n<p>你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。</p>\n<ol start=\"2\">\n<li>Redux store 调用传入的 reducer 函数。</li>\n</ol>\n<p>Store 会把两个参数传入 reducer： 当前的 state 树和 action。</p>\n<ol start=\"3\">\n<li><p>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</p>\n</li>\n<li><p>Redux store 保存了根 reducer 返回的完整 state 树。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文只是一些关于redux的概念和基本介绍，下次会带来它的基本用法。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Redux的核心思想是Web应用是一个状态机，视图与状态是一一对应的。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/redux.png\" alt=\"image\"></p>","more":"<blockquote>\n<p>最近一年的工作中都在使用React相关的技术栈，当初理解Redux也费了很大功夫，一直都想写一点关于Redux的教程，现在，终于开始了。</p>\n</blockquote>\n<h3 id=\"为什么使用Redux\"><a href=\"#为什么使用Redux\" class=\"headerlink\" title=\"为什么使用Redux\"></a>为什么使用Redux</h3><p>Redux的出现是为了解决Javascript中复杂的状态管理，当你的应用变得庞大，需要处理复杂的交互场景时，你可以尝试使用Redux。如果你使用React，如果你需要共享状态到很多组件中，如果你需要处理异步，如果一个组件的状态改变需要更新其他组件，你可能需要Redux。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>\n<p>Redux专注于状态管理，和react解耦。</p>\n<p>Redux 可以用这三个基本原则来描述：</p>\n<ul>\n<li>单一状态树</li>\n</ul>\n<p>整个应用的 state 被储存在一棵对象树中，并且这个对象树只存在于唯一一个store中。</p>\n<ul>\n<li>State 是只读的</li>\n</ul>\n<p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p>\n<ul>\n<li>使用纯函数来执行修改</li>\n</ul>\n<p>为了描述 action 如何改变 state树，你需要编写 reducers。</p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>Action 本质上是 JavaScript 普通对象。Redux约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放action。</p>\n<p>Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。<br>store 里能直接通过 store.dispatch() 调用 dispatch() 方法。</p>\n<h3 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h3><p>Reducers 根据传入的action和state计算新的state。</p>\n<p>Reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。<br>只要传入参数相同，计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</p>\n<ol>\n<li>reducer中不要修改state，而是返回新对象。 可以使用 Object.assign() 新建一个副本。不能这样使用：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(state, &#123; <span class=\"attr\">visibilityFilter</span>: action.filter &#125;)</span><br></pre></td></tr></table></figure>\n<p>上述代码会改变第一个参数的值。必须把第一个参数设置为空对象。也可以开启ES7使用对象展开运算符, 从而使用 { …state, …newState } 达到相同的目的。</p>\n<ol start=\"3\">\n<li>在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。</li>\n</ol>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p>store 是维持应用state的容器，并在当你发起 action 的时候调用 reducer。<br>Store 就是把它们联系到一起的对象。Store 有以下职责：</p>\n<ul>\n<li>维持应用的 state；</li>\n<li>提供 getState() 方法获取 state；</li>\n<li>提供 dispatch(action) 方法更新 state；</li>\n<li>通过 subscribe(listener) 注册监听器;</li>\n<li>通过 subscribe(listener)返回的函数注销监听器。</li>\n</ul>\n<p>Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 多个reducer 组合而不是创建多个 store。</p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>\n<ol>\n<li>调用 store.dispatch(action)。</li>\n</ol>\n<p>你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。</p>\n<ol start=\"2\">\n<li>Redux store 调用传入的 reducer 函数。</li>\n</ol>\n<p>Store 会把两个参数传入 reducer： 当前的 state 树和 action。</p>\n<ol start=\"3\">\n<li><p>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</p>\n</li>\n<li><p>Redux store 保存了根 reducer 返回的完整 state 树。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文只是一些关于redux的概念和基本介绍，下次会带来它的基本用法。</p>"},{"title":"移动端H5调试工具指南","date":"2020-09-20T14:56:01.000Z","_content":"\n> 拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。\n\n![image](http://img.yanyuanfe.cn/mobile.jpeg)\n\n<!--more-->\n\n### 前言\n在移动端Web开发的项目中，由于移动端设备的多样性，IOS系统的兼容性，不同安卓设备的Webview兼容性的不同，而PC端的浏览器开发者工具又很难复现问题，拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。\n以下是我在开发过程中使用过的几款调试工具。\n\n### vConsole\n\nvConsole是由微信公众平台前端团队开源的一个轻量、可拓展、针对手机网页的前端开发者调试面板，可用于展示console日志，方便开发、调试。\n\nGithub: https://github.com/Tencent/vConsole\n\n在线体验地址：http://wechatfe.github.io/vconsole/demo.html\n\n特性：\n- 查看 console 日志\n- 查看网络请求\n- 查看页面 element 结构\n- 查看 Cookies、localStorage 和 SessionStorage\n- 手动执行 JS 命令行\n- 自定义插件\n\n快速上手：\n\n- Script引入：\n\n``` js\n<head>\n  <script src=\"http://wechatfe.github.io/vconsole/lib/vconsole.min.js\"></script>\n  <script>\n    var vConsole = new VConsole();\n  </script>\n</head>\n```\n为了便于后续扩展，建议在 <head> 中引入：\n- NPM\n\n``` bash\nnpm install vconsole\n```\n\n``` js\nimport vConsole from \"vconsole\";\n\nconst vConsole = new VConsole();\n```\n\n### eruda\n\nEruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。\n\nGithub:https://github.com/liriliri/eruda\n\n在线体验地址： https://eruda.liriliri.io/\n\n特性：\n\n- 按钮拖拽，面板透明度大小设置。\n\n- Console 面板：捕获 Console 日志，支持 log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括 %c 自定义样式输出；支持按日志类型及正则表达式过滤；支持 JavaScript 脚本执行。\n\n- Elements 面板：查看标签内容及属性；查看应用在 Dom 上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看 Dom 上绑定的各类事件。\n\n- Network 面板：捕获请求，查看发送数据、返回头、返回内容等信息。\n\n- Resources 面板：查看并清除 localStorage、sessionStorage 及 cookie；查看页面加载脚本及样式文件；查看页面加载图片。\n\n- Sources 面板：查看页面源码；格式化 html，css，js 代码及 json 数据。\n\n- Info 面板：输出 URL 及 User Agent；支持自定义输出内容。\n\n- Snippets 面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。\n\n\n快速上手：\n\n- 通过CDN使用：\n\n``` js\n<script src=\"//cdn.jsdelivr.net/npm/eruda\"></script>\n<script>eruda.init();</script>\n```\n- NPM\n\n``` js\nnpm install eruda --save\n\n<script src=\"node_modules/eruda/eruda.js\"></script>\n<script>eruda.init();</script>\n```\n\nvconsole和eruda功能类似，都是在移动端网页内置一个console面板，但是，使用起来却不是很方便，比如在调试某个元素的时候，由于手机端屏幕的局限性，操作起来并不方便，下面将介绍两个最具代表性的远程调试工具。\n\n### Weinre\n\nWeinre代表**We**b **In**spector **Re** mote，是一种远程调试工具。\n\nWeinre作为一种远程调试工具，在结构上分为三层：\n\n- 目标页面（target）：被调试的页面，页面已嵌入weinre的远程js；\n- Debug客户端（client）：本地的Web Inspector调试客户端；\n- Debug服务端（agent）：一个HTTP Server，为目标页面与Debug客户端建立通信。\n\n快速开始：\n\n安装：\n``` \nnpm install -g weinre\n```\n\n命令行启动：\n\n```\nweinre --httpPort 8080 --boundHost -all-\n```\n\n打开谷歌浏览器（-webkit内核）输入：http://127.0.0.1:8080/  \n\n然后添加Debug Target：\n\n在你需要调试的页面添加如下script（ip）：\n\n\n```\n<script src=\"http://你的ip:8080/target/target-script-min.js#anonymous\" type=\"text/javascript\"></script>\n```\n\n然后在手机端打开调试页面，手机需要和电脑在同一WIFI。\n\n最后回到最开始打开的http://127.0.0.1:8080 ，点击“debug client user interface:”  如果没有问题的话，就已经成功添加了Debug Target。\n\n注意：我目前还没有使用过这个工具，详细的使用指南请查看：https://github.com/nupthale/weinre\n\n### Chii\n\nChii是与 weinre 一样的远程调试工具，主要是将 web inspector 替换为最新的 chrome devtools frontend.\n\nGithub：https://github.com/liriliri/chii\n\nChii和Weinre相比，调试界面变成了Chrome的开发者工具，更加友好。\n\n快速开始：\n\n安装：\n\n\n```\nnpm install chii -g\n```\n启动：\n\n\n```\nchii start -p 8080\n```\n在你要调试的页面注入以下脚本：\n\n\n```\n<script src=\"//你的ip:8080/target.js\"></script>\n```\n\n然后就可以访问 localhost:8080 开始调试页面。\n\n是不是很简单，你可以在手机上进行操作，然后在PC端的调试面板中查看元素和log输出。\n\n\n### 总结\n\n以上就是移动端调试工具的相关分享，类似的工具还有很多，最出名的就是以上几种吧，还有一些类似的工具如：\nhttps://github.com/wuchangming/spy-debugger， 但是我还没有用过，以后有更好用的再来分享。","source":"_posts/移动端H5调试工具指南.md","raw":"---\ntitle: 移动端H5调试工具指南\ndate: 2020-09-20 22:56:01\ntags:\n  - 移动端\n  - 调试\n---\n\n> 拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。\n\n![image](http://img.yanyuanfe.cn/mobile.jpeg)\n\n<!--more-->\n\n### 前言\n在移动端Web开发的项目中，由于移动端设备的多样性，IOS系统的兼容性，不同安卓设备的Webview兼容性的不同，而PC端的浏览器开发者工具又很难复现问题，拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。\n以下是我在开发过程中使用过的几款调试工具。\n\n### vConsole\n\nvConsole是由微信公众平台前端团队开源的一个轻量、可拓展、针对手机网页的前端开发者调试面板，可用于展示console日志，方便开发、调试。\n\nGithub: https://github.com/Tencent/vConsole\n\n在线体验地址：http://wechatfe.github.io/vconsole/demo.html\n\n特性：\n- 查看 console 日志\n- 查看网络请求\n- 查看页面 element 结构\n- 查看 Cookies、localStorage 和 SessionStorage\n- 手动执行 JS 命令行\n- 自定义插件\n\n快速上手：\n\n- Script引入：\n\n``` js\n<head>\n  <script src=\"http://wechatfe.github.io/vconsole/lib/vconsole.min.js\"></script>\n  <script>\n    var vConsole = new VConsole();\n  </script>\n</head>\n```\n为了便于后续扩展，建议在 <head> 中引入：\n- NPM\n\n``` bash\nnpm install vconsole\n```\n\n``` js\nimport vConsole from \"vconsole\";\n\nconst vConsole = new VConsole();\n```\n\n### eruda\n\nEruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。\n\nGithub:https://github.com/liriliri/eruda\n\n在线体验地址： https://eruda.liriliri.io/\n\n特性：\n\n- 按钮拖拽，面板透明度大小设置。\n\n- Console 面板：捕获 Console 日志，支持 log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括 %c 自定义样式输出；支持按日志类型及正则表达式过滤；支持 JavaScript 脚本执行。\n\n- Elements 面板：查看标签内容及属性；查看应用在 Dom 上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看 Dom 上绑定的各类事件。\n\n- Network 面板：捕获请求，查看发送数据、返回头、返回内容等信息。\n\n- Resources 面板：查看并清除 localStorage、sessionStorage 及 cookie；查看页面加载脚本及样式文件；查看页面加载图片。\n\n- Sources 面板：查看页面源码；格式化 html，css，js 代码及 json 数据。\n\n- Info 面板：输出 URL 及 User Agent；支持自定义输出内容。\n\n- Snippets 面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。\n\n\n快速上手：\n\n- 通过CDN使用：\n\n``` js\n<script src=\"//cdn.jsdelivr.net/npm/eruda\"></script>\n<script>eruda.init();</script>\n```\n- NPM\n\n``` js\nnpm install eruda --save\n\n<script src=\"node_modules/eruda/eruda.js\"></script>\n<script>eruda.init();</script>\n```\n\nvconsole和eruda功能类似，都是在移动端网页内置一个console面板，但是，使用起来却不是很方便，比如在调试某个元素的时候，由于手机端屏幕的局限性，操作起来并不方便，下面将介绍两个最具代表性的远程调试工具。\n\n### Weinre\n\nWeinre代表**We**b **In**spector **Re** mote，是一种远程调试工具。\n\nWeinre作为一种远程调试工具，在结构上分为三层：\n\n- 目标页面（target）：被调试的页面，页面已嵌入weinre的远程js；\n- Debug客户端（client）：本地的Web Inspector调试客户端；\n- Debug服务端（agent）：一个HTTP Server，为目标页面与Debug客户端建立通信。\n\n快速开始：\n\n安装：\n``` \nnpm install -g weinre\n```\n\n命令行启动：\n\n```\nweinre --httpPort 8080 --boundHost -all-\n```\n\n打开谷歌浏览器（-webkit内核）输入：http://127.0.0.1:8080/  \n\n然后添加Debug Target：\n\n在你需要调试的页面添加如下script（ip）：\n\n\n```\n<script src=\"http://你的ip:8080/target/target-script-min.js#anonymous\" type=\"text/javascript\"></script>\n```\n\n然后在手机端打开调试页面，手机需要和电脑在同一WIFI。\n\n最后回到最开始打开的http://127.0.0.1:8080 ，点击“debug client user interface:”  如果没有问题的话，就已经成功添加了Debug Target。\n\n注意：我目前还没有使用过这个工具，详细的使用指南请查看：https://github.com/nupthale/weinre\n\n### Chii\n\nChii是与 weinre 一样的远程调试工具，主要是将 web inspector 替换为最新的 chrome devtools frontend.\n\nGithub：https://github.com/liriliri/chii\n\nChii和Weinre相比，调试界面变成了Chrome的开发者工具，更加友好。\n\n快速开始：\n\n安装：\n\n\n```\nnpm install chii -g\n```\n启动：\n\n\n```\nchii start -p 8080\n```\n在你要调试的页面注入以下脚本：\n\n\n```\n<script src=\"//你的ip:8080/target.js\"></script>\n```\n\n然后就可以访问 localhost:8080 开始调试页面。\n\n是不是很简单，你可以在手机上进行操作，然后在PC端的调试面板中查看元素和log输出。\n\n\n### 总结\n\n以上就是移动端调试工具的相关分享，类似的工具还有很多，最出名的就是以上几种吧，还有一些类似的工具如：\nhttps://github.com/wuchangming/spy-debugger， 但是我还没有用过，以后有更好用的再来分享。","slug":"移动端H5调试工具指南","published":1,"updated":"2020-11-25T15:04:47.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenoj002lp70v7stkt56z","content":"<blockquote>\n<p>拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/mobile.jpeg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在移动端Web开发的项目中，由于移动端设备的多样性，IOS系统的兼容性，不同安卓设备的Webview兼容性的不同，而PC端的浏览器开发者工具又很难复现问题，拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。<br>以下是我在开发过程中使用过的几款调试工具。</p>\n<h3 id=\"vConsole\"><a href=\"#vConsole\" class=\"headerlink\" title=\"vConsole\"></a>vConsole</h3><p>vConsole是由微信公众平台前端团队开源的一个轻量、可拓展、针对手机网页的前端开发者调试面板，可用于展示console日志，方便开发、调试。</p>\n<p>Github: <a href=\"https://github.com/Tencent/vConsole\" target=\"_blank\" rel=\"noopener\">https://github.com/Tencent/vConsole</a></p>\n<p>在线体验地址：<a href=\"http://wechatfe.github.io/vconsole/demo.html\" target=\"_blank\" rel=\"noopener\">http://wechatfe.github.io/vconsole/demo.html</a></p>\n<p>特性：</p>\n<ul>\n<li>查看 console 日志</li>\n<li>查看网络请求</li>\n<li>查看页面 element 结构</li>\n<li>查看 Cookies、localStorage 和 SessionStorage</li>\n<li>手动执行 JS 命令行</li>\n<li>自定义插件</li>\n</ul>\n<p>快速上手：</p>\n<ul>\n<li>Script引入：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;script src=<span class=\"string\">\"http://wechatfe.github.io/vconsole/lib/vconsole.min.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    var vConsole = new VConsole();</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>script&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></span><br></pre></td></tr></table></figure>\n<p>为了便于后续扩展，建议在 <head><meta name=\"generator\" content=\"Hexo 3.9.0\"> 中引入：</head></p>\n<ul>\n<li>NPM</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install vconsole</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> vConsole <span class=\"keyword\">from</span> <span class=\"string\">\"vconsole\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> vConsole = <span class=\"keyword\">new</span> VConsole();</span><br></pre></td></tr></table></figure>\n<h3 id=\"eruda\"><a href=\"#eruda\" class=\"headerlink\" title=\"eruda\"></a>eruda</h3><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p>\n<p>Github:<a href=\"https://github.com/liriliri/eruda\" target=\"_blank\" rel=\"noopener\">https://github.com/liriliri/eruda</a></p>\n<p>在线体验地址： <a href=\"https://eruda.liriliri.io/\" target=\"_blank\" rel=\"noopener\">https://eruda.liriliri.io/</a></p>\n<p>特性：</p>\n<ul>\n<li><p>按钮拖拽，面板透明度大小设置。</p>\n</li>\n<li><p>Console 面板：捕获 Console 日志，支持 log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括 %c 自定义样式输出；支持按日志类型及正则表达式过滤；支持 JavaScript 脚本执行。</p>\n</li>\n<li><p>Elements 面板：查看标签内容及属性；查看应用在 Dom 上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看 Dom 上绑定的各类事件。</p>\n</li>\n<li><p>Network 面板：捕获请求，查看发送数据、返回头、返回内容等信息。</p>\n</li>\n<li><p>Resources 面板：查看并清除 localStorage、sessionStorage 及 cookie；查看页面加载脚本及样式文件；查看页面加载图片。</p>\n</li>\n<li><p>Sources 面板：查看页面源码；格式化 html，css，js 代码及 json 数据。</p>\n</li>\n<li><p>Info 面板：输出 URL 及 User Agent；支持自定义输出内容。</p>\n</li>\n<li><p>Snippets 面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</p>\n</li>\n</ul>\n<p>快速上手：</p>\n<ul>\n<li>通过CDN使用：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"//cdn.jsdelivr.net/npm/eruda\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;eruda.init();&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NPM</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install eruda --save</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"node_modules/eruda/eruda.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;eruda.init();&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>\n<p>vconsole和eruda功能类似，都是在移动端网页内置一个console面板，但是，使用起来却不是很方便，比如在调试某个元素的时候，由于手机端屏幕的局限性，操作起来并不方便，下面将介绍两个最具代表性的远程调试工具。</p>\n<h3 id=\"Weinre\"><a href=\"#Weinre\" class=\"headerlink\" title=\"Weinre\"></a>Weinre</h3><p>Weinre代表<strong>We</strong>b <strong>In</strong>spector <strong>Re</strong> mote，是一种远程调试工具。</p>\n<p>Weinre作为一种远程调试工具，在结构上分为三层：</p>\n<ul>\n<li>目标页面（target）：被调试的页面，页面已嵌入weinre的远程js；</li>\n<li>Debug客户端（client）：本地的Web Inspector调试客户端；</li>\n<li>Debug服务端（agent）：一个HTTP Server，为目标页面与Debug客户端建立通信。</li>\n</ul>\n<p>快速开始：</p>\n<p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g weinre</span><br></pre></td></tr></table></figure></p>\n<p>命令行启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">weinre --httpPort 8080 --boundHost -all-</span><br></pre></td></tr></table></figure>\n<p>打开谷歌浏览器（-webkit内核）输入：<a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a>  </p>\n<p>然后添加Debug Target：</p>\n<p>在你需要调试的页面添加如下script（ip）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://你的ip:8080/target/target-script-min.js#anonymous&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在手机端打开调试页面，手机需要和电脑在同一WIFI。</p>\n<p>最后回到最开始打开的<a href=\"http://127.0.0.1:8080\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080</a> ，点击“debug client user interface:”  如果没有问题的话，就已经成功添加了Debug Target。</p>\n<p>注意：我目前还没有使用过这个工具，详细的使用指南请查看：<a href=\"https://github.com/nupthale/weinre\" target=\"_blank\" rel=\"noopener\">https://github.com/nupthale/weinre</a></p>\n<h3 id=\"Chii\"><a href=\"#Chii\" class=\"headerlink\" title=\"Chii\"></a>Chii</h3><p>Chii是与 weinre 一样的远程调试工具，主要是将 web inspector 替换为最新的 chrome devtools frontend.</p>\n<p>Github：<a href=\"https://github.com/liriliri/chii\" target=\"_blank\" rel=\"noopener\">https://github.com/liriliri/chii</a></p>\n<p>Chii和Weinre相比，调试界面变成了Chrome的开发者工具，更加友好。</p>\n<p>快速开始：</p>\n<p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install chii -g</span><br></pre></td></tr></table></figure>\n<p>启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chii start -p 8080</span><br></pre></td></tr></table></figure>\n<p>在你要调试的页面注入以下脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;//你的ip:8080/target.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后就可以访问 localhost:8080 开始调试页面。</p>\n<p>是不是很简单，你可以在手机上进行操作，然后在PC端的调试面板中查看元素和log输出。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上就是移动端调试工具的相关分享，类似的工具还有很多，最出名的就是以上几种吧，还有一些类似的工具如：<br><a href=\"https://github.com/wuchangming/spy-debugger，\" target=\"_blank\" rel=\"noopener\">https://github.com/wuchangming/spy-debugger，</a> 但是我还没有用过，以后有更好用的再来分享。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/mobile.jpeg\" alt=\"image\"></p>","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在移动端Web开发的项目中，由于移动端设备的多样性，IOS系统的兼容性，不同安卓设备的Webview兼容性的不同，而PC端的浏览器开发者工具又很难复现问题，拥有一款好用的移动端调试工具，在开发和调试BUG的过程中，都能快速提升开发效率和定位问题的能力。<br>以下是我在开发过程中使用过的几款调试工具。</p>\n<h3 id=\"vConsole\"><a href=\"#vConsole\" class=\"headerlink\" title=\"vConsole\"></a>vConsole</h3><p>vConsole是由微信公众平台前端团队开源的一个轻量、可拓展、针对手机网页的前端开发者调试面板，可用于展示console日志，方便开发、调试。</p>\n<p>Github: <a href=\"https://github.com/Tencent/vConsole\" target=\"_blank\" rel=\"noopener\">https://github.com/Tencent/vConsole</a></p>\n<p>在线体验地址：<a href=\"http://wechatfe.github.io/vconsole/demo.html\" target=\"_blank\" rel=\"noopener\">http://wechatfe.github.io/vconsole/demo.html</a></p>\n<p>特性：</p>\n<ul>\n<li>查看 console 日志</li>\n<li>查看网络请求</li>\n<li>查看页面 element 结构</li>\n<li>查看 Cookies、localStorage 和 SessionStorage</li>\n<li>手动执行 JS 命令行</li>\n<li>自定义插件</li>\n</ul>\n<p>快速上手：</p>\n<ul>\n<li>Script引入：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;script src=<span class=\"string\">\"http://wechatfe.github.io/vconsole/lib/vconsole.min.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    var vConsole = new VConsole();</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>script&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></span><br></pre></td></tr></table></figure>\n<p>为了便于后续扩展，建议在 <head><meta name=\"generator\" content=\"Hexo 3.9.0\"> 中引入：</head></p>\n<ul>\n<li>NPM</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install vconsole</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> vConsole <span class=\"keyword\">from</span> <span class=\"string\">\"vconsole\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> vConsole = <span class=\"keyword\">new</span> VConsole();</span><br></pre></td></tr></table></figure>\n<h3 id=\"eruda\"><a href=\"#eruda\" class=\"headerlink\" title=\"eruda\"></a>eruda</h3><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p>\n<p>Github:<a href=\"https://github.com/liriliri/eruda\" target=\"_blank\" rel=\"noopener\">https://github.com/liriliri/eruda</a></p>\n<p>在线体验地址： <a href=\"https://eruda.liriliri.io/\" target=\"_blank\" rel=\"noopener\">https://eruda.liriliri.io/</a></p>\n<p>特性：</p>\n<ul>\n<li><p>按钮拖拽，面板透明度大小设置。</p>\n</li>\n<li><p>Console 面板：捕获 Console 日志，支持 log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括 %c 自定义样式输出；支持按日志类型及正则表达式过滤；支持 JavaScript 脚本执行。</p>\n</li>\n<li><p>Elements 面板：查看标签内容及属性；查看应用在 Dom 上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看 Dom 上绑定的各类事件。</p>\n</li>\n<li><p>Network 面板：捕获请求，查看发送数据、返回头、返回内容等信息。</p>\n</li>\n<li><p>Resources 面板：查看并清除 localStorage、sessionStorage 及 cookie；查看页面加载脚本及样式文件；查看页面加载图片。</p>\n</li>\n<li><p>Sources 面板：查看页面源码；格式化 html，css，js 代码及 json 数据。</p>\n</li>\n<li><p>Info 面板：输出 URL 及 User Agent；支持自定义输出内容。</p>\n</li>\n<li><p>Snippets 面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</p>\n</li>\n</ul>\n<p>快速上手：</p>\n<ul>\n<li>通过CDN使用：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"//cdn.jsdelivr.net/npm/eruda\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;eruda.init();&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NPM</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install eruda --save</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"node_modules/eruda/eruda.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;eruda.init();&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>\n<p>vconsole和eruda功能类似，都是在移动端网页内置一个console面板，但是，使用起来却不是很方便，比如在调试某个元素的时候，由于手机端屏幕的局限性，操作起来并不方便，下面将介绍两个最具代表性的远程调试工具。</p>\n<h3 id=\"Weinre\"><a href=\"#Weinre\" class=\"headerlink\" title=\"Weinre\"></a>Weinre</h3><p>Weinre代表<strong>We</strong>b <strong>In</strong>spector <strong>Re</strong> mote，是一种远程调试工具。</p>\n<p>Weinre作为一种远程调试工具，在结构上分为三层：</p>\n<ul>\n<li>目标页面（target）：被调试的页面，页面已嵌入weinre的远程js；</li>\n<li>Debug客户端（client）：本地的Web Inspector调试客户端；</li>\n<li>Debug服务端（agent）：一个HTTP Server，为目标页面与Debug客户端建立通信。</li>\n</ul>\n<p>快速开始：</p>\n<p>安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g weinre</span><br></pre></td></tr></table></figure></p>\n<p>命令行启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">weinre --httpPort 8080 --boundHost -all-</span><br></pre></td></tr></table></figure>\n<p>打开谷歌浏览器（-webkit内核）输入：<a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a>  </p>\n<p>然后添加Debug Target：</p>\n<p>在你需要调试的页面添加如下script（ip）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;http://你的ip:8080/target/target-script-min.js#anonymous&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在手机端打开调试页面，手机需要和电脑在同一WIFI。</p>\n<p>最后回到最开始打开的<a href=\"http://127.0.0.1:8080\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080</a> ，点击“debug client user interface:”  如果没有问题的话，就已经成功添加了Debug Target。</p>\n<p>注意：我目前还没有使用过这个工具，详细的使用指南请查看：<a href=\"https://github.com/nupthale/weinre\" target=\"_blank\" rel=\"noopener\">https://github.com/nupthale/weinre</a></p>\n<h3 id=\"Chii\"><a href=\"#Chii\" class=\"headerlink\" title=\"Chii\"></a>Chii</h3><p>Chii是与 weinre 一样的远程调试工具，主要是将 web inspector 替换为最新的 chrome devtools frontend.</p>\n<p>Github：<a href=\"https://github.com/liriliri/chii\" target=\"_blank\" rel=\"noopener\">https://github.com/liriliri/chii</a></p>\n<p>Chii和Weinre相比，调试界面变成了Chrome的开发者工具，更加友好。</p>\n<p>快速开始：</p>\n<p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install chii -g</span><br></pre></td></tr></table></figure>\n<p>启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chii start -p 8080</span><br></pre></td></tr></table></figure>\n<p>在你要调试的页面注入以下脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;//你的ip:8080/target.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后就可以访问 localhost:8080 开始调试页面。</p>\n<p>是不是很简单，你可以在手机上进行操作，然后在PC端的调试面板中查看元素和log输出。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上就是移动端调试工具的相关分享，类似的工具还有很多，最出名的就是以上几种吧，还有一些类似的工具如：<br><a href=\"https://github.com/wuchangming/spy-debugger，\" target=\"_blank\" rel=\"noopener\">https://github.com/wuchangming/spy-debugger，</a> 但是我还没有用过，以后有更好用的再来分享。</p>"},{"title":"编写高性能的React代码","date":"2018-09-25T13:56:56.000Z","banner":"http://img.yanyuanfe.cn/react.jpg","_content":"> 本文总结了一些编写React代码的建议，有助于理解React的渲染机制，主要是通过减少不必要的重新渲染来提升React性能。\n\n![image](http://img.yanyuanfe.cn/react.jpg)\n\n<!--more-->\n\n回顾使用React开发的经历，已有接近两年了，一直想要写一篇文章来介绍如何编写高性能的React代码，又或者是性能调优之类的，于是，我总结了一些编写高性能React代码的实践，或许能让你对React的理解更加深刻。\n\n### 影响React性能的主要因素\nReact专注于构建用户界面，内部通过VirtualDOM和Diff算法实现视图的更新，本身拥有很高的性能。当组件的state和props改变的时候，React就会重新render，进而更新视图。在render过程中，react会将JSX语法转换为虚拟DOM，同时进行Diff算法比较新旧DOM的变化，从而对视图进行局部更新。试想，当render执行后，JSX转换虚拟DOM，然后Diff，最后发现新旧DOM是一样的，最后并没有更新视图。那么，就导致了不必要的render，造成了性能的浪费。所以，减少不必要的render，成为优化React性能的主要因素。\n\n### state只与视图有关\n编写React组件的时候，你肯定会用到变量，变量可以保存在this上，可以保存到state中，还可以使用全局变量。那么什么时候该使用state呢？答案是只有与视图相关的变量才放在state中，与视图无关的可以放在this上。如果与视图更新无关的变量放在state中，而且这个变量需要频繁的更新，而每次更新都需要重新render，势必造成性能浪费，使用this来存放无疑是更好的选择。\n\n### shouldComponentUpdate\n考虑如下代码：\n\n``` js\nexport default class Home extends Component {\n  state = {\n    count: 0\n  }\n\n  add = () => {\n    this.setState({count: 0});\n  }\n  \n  render() {\n    console.log('render');\n    return (\n      <div className=\"App\">\n        <div onClick={this.add}>+++</div>\n        <p className=\"App-intro\">\n          {this.state.count}\n        </p>\n      </div>\n    );\n  }\n}\n```\n当点击+++触发add事时，setState更新state，但是新旧state完全一样，React并没有在Component组件中进行优化，导致不必要的render执行。此时，需要我们手动进行优化，当state或者props更新后react组件的生命周期shouldComponentUpdate触发，在shouldComponentUpdate中可以对新旧state和props进行比较，判断组件是否需要重新render。\n\n``` js\nshouldComponentUpdate(nextProps, nextState) {\n    if(nextState.count === this.state.count) {\n      return false;\n    }\n}\n```\n默认情况下shouldComponentUpdate返回true，即始终要重新渲染，此处我们使用shouldComponentUpdate进行比较后，返回false，react将不会重新render。\n\n当state为字符串等基本类型的时候，shouldComponentUpdate还能应付自如，那如果state是对象或者数组等引用类型呢？对于引用类型只能对其进行递归比较才能判断其是否相等，又或者是采用JSON.stringify(nextState.obj) === JSON.stringify(this.state.obj)进行比较，但是当对象嵌套层级较深或者函数、正则等类型时，shouldComponentUpdate便失去了它的用武之地。\n\n### PureComponent\nReact.PureComponent与React.Component 几乎完全相同，但React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。\n简而言之，PureComponent自己内部实现了一个shouldComponentUpdate，而不需要我们再去编写比较代码。\nReact.PureComponent的shouldComponentUpdate() 只会对对象进行浅对比。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）。\n测试表明，使用PureComponent的性能会略胜shouldComponentUpdate一筹。\n\n\n### StateLessComponent\n无状态组件（StateLessComponent）又称函数式组件。\n\n``` js\nconst Text = ({ children = 'Hello World!' }) =>\n  <p>{children}</p>\n```\n函数式组件没有class声明，没有生命周期，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。\n\n\n### 箭头函数与bind\n当我们在组件上绑定事件处理函数的时候，为了能正常访问state，通常会使用bind或者箭头函数。\n\n```js\n<Button onClick={this.update.bind(this)} />\n```\n又或者\n\n``` js\n<Button onClick={() => { console.log(\"Click\"); }} />\n```\n\n在以上情况下，bind每次都返回全新的函数，箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同），对于组件来说每次绑定的都是新的函数，Button组件在进行 props 比较的时候会认为前后props不一样，造成重新渲染。\n比较推荐的写法有两种：\n\n``` js\nupdate = () => {\n    //\n}\n<Button onClick={this.update} />\n```\n或者\n``` js\nconstructor(props) {\n    super(props);\n    this.update = this.update.bind(this);\n}\n\nupdate() {\n    //\n}\n<Button onClick={this.update} />\n```\n\n### 内联style\n当我们为组件设置样式的时候，可能会写出如下代码：\n\n\n``` js\n<Button style={{width: 100, marginTop: 50 }} />\n```\n这种写法，每次render时style返回的都是全新的对象，我们知道，引用类型比较的是引用地址，每次的结果都是不相等，也会导致重新渲染。\n推荐的写法是使用className。\n```js\n<Button className=\"btn\" />\n```\n\n### 属性传递与[]\n\n当我们为组件设置缺省值的时候:\n\n``` js\n<RadioGroup options={this.props.options || []} />\n```\n\n如果每次 this.props.options 值都是 null 的话，意味着每次传递给<RadioGroup />都是字面量数组[]，但字面量数组和new Array()效果是一样的，始终生成新的实例，所以表面上看虽然每次传递给组件的都是相同的空数组，其实对组件来说每次都是新的属性，都会引起渲染。所以正确的方式应该将一些常用值以变量的形式保存下来：\n\n``` js\nconst DEFAULT_OPTIONS = [];\n\n<RadioGroup options={this.props.options || DEFAULT_OPTIONS} />\n```\n<div class=\"tip\">\n注意：此处的DEFAULT_OPTIONS不能写在render中，当写在render中的时候，还是会每次都生成一个新的数组，依然会重新渲染，正确的做法是放在组件外面或者使用this.DEFAULT_OPTIONS = []。\n</div>\n\n### map 与 key\n在react中，你应该经常用到map来渲染一个列表，当你忘记为每个列表元素设置key属性的时候，react会在控制台发出警告a key should be provided for list items。\n实际上，Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。\n\n一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key:\n\n``` js\nconst todoItems = todos.map((todo) =>\n  <li key={todo.id}>\n    {todo.text}\n  </li>\n);\n```\n\n当元素没有确定的id时，你可以使用他的序列号索引index作为key：\n\n``` js\nconst todoItems = todos.map((todo, index) =>\n  // Only do this if items have no stable IDs\n  <li key={index}>\n    {todo.text}\n  </li>\n);\n```\n当todoItems中数据发生改变的时候，使用索引作为key的列表都将重新渲染。所以不建议使用索引来进行排序，因为这会导致渲染变得很慢。\n\n### 减少在render内执行变量\n\n我们已经知道，当组件的state和props发生改变的时候，render都会执行，那么，当render中有变量的执行或者函数执行的时候，可能会影响渲染性能，所以，应该减少在render内执行变量或者函数。\n\n### 精简props和state\n从上面我们已经知道，当props和state为引用类型的时候，react内部只对props和state进行浅比较，那么，props和state可以尽量设置为基础数据类型，对象的嵌套层级不要过深，减少props的参数数量，使组件的props和state对象数据尽可能达到扁平化，都可以在一定程度上优化react的渲染性能。\n\n### 总结\n\n本文讨论了一系列编写React代码的原则，旨在从减少重新render的方面来提升react代码的性能。性能优化一直是一个持久的话题，还可以从很多方面去考虑，比如，使用不可变的数据结构immutable.js，使用reselect来缓存redux中的复杂计算，对组件尽可能进行拆分为子组件，都是值得探讨的话题。那么，下次再见。\n","source":"_posts/编写高性能React代码的原则.md","raw":"---\ntitle: 编写高性能的React代码\ndate: 2018-9-25 21:56:56\nbanner: http://img.yanyuanfe.cn/react.jpg\ntags:\n- React\n---\n> 本文总结了一些编写React代码的建议，有助于理解React的渲染机制，主要是通过减少不必要的重新渲染来提升React性能。\n\n![image](http://img.yanyuanfe.cn/react.jpg)\n\n<!--more-->\n\n回顾使用React开发的经历，已有接近两年了，一直想要写一篇文章来介绍如何编写高性能的React代码，又或者是性能调优之类的，于是，我总结了一些编写高性能React代码的实践，或许能让你对React的理解更加深刻。\n\n### 影响React性能的主要因素\nReact专注于构建用户界面，内部通过VirtualDOM和Diff算法实现视图的更新，本身拥有很高的性能。当组件的state和props改变的时候，React就会重新render，进而更新视图。在render过程中，react会将JSX语法转换为虚拟DOM，同时进行Diff算法比较新旧DOM的变化，从而对视图进行局部更新。试想，当render执行后，JSX转换虚拟DOM，然后Diff，最后发现新旧DOM是一样的，最后并没有更新视图。那么，就导致了不必要的render，造成了性能的浪费。所以，减少不必要的render，成为优化React性能的主要因素。\n\n### state只与视图有关\n编写React组件的时候，你肯定会用到变量，变量可以保存在this上，可以保存到state中，还可以使用全局变量。那么什么时候该使用state呢？答案是只有与视图相关的变量才放在state中，与视图无关的可以放在this上。如果与视图更新无关的变量放在state中，而且这个变量需要频繁的更新，而每次更新都需要重新render，势必造成性能浪费，使用this来存放无疑是更好的选择。\n\n### shouldComponentUpdate\n考虑如下代码：\n\n``` js\nexport default class Home extends Component {\n  state = {\n    count: 0\n  }\n\n  add = () => {\n    this.setState({count: 0});\n  }\n  \n  render() {\n    console.log('render');\n    return (\n      <div className=\"App\">\n        <div onClick={this.add}>+++</div>\n        <p className=\"App-intro\">\n          {this.state.count}\n        </p>\n      </div>\n    );\n  }\n}\n```\n当点击+++触发add事时，setState更新state，但是新旧state完全一样，React并没有在Component组件中进行优化，导致不必要的render执行。此时，需要我们手动进行优化，当state或者props更新后react组件的生命周期shouldComponentUpdate触发，在shouldComponentUpdate中可以对新旧state和props进行比较，判断组件是否需要重新render。\n\n``` js\nshouldComponentUpdate(nextProps, nextState) {\n    if(nextState.count === this.state.count) {\n      return false;\n    }\n}\n```\n默认情况下shouldComponentUpdate返回true，即始终要重新渲染，此处我们使用shouldComponentUpdate进行比较后，返回false，react将不会重新render。\n\n当state为字符串等基本类型的时候，shouldComponentUpdate还能应付自如，那如果state是对象或者数组等引用类型呢？对于引用类型只能对其进行递归比较才能判断其是否相等，又或者是采用JSON.stringify(nextState.obj) === JSON.stringify(this.state.obj)进行比较，但是当对象嵌套层级较深或者函数、正则等类型时，shouldComponentUpdate便失去了它的用武之地。\n\n### PureComponent\nReact.PureComponent与React.Component 几乎完全相同，但React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。\n简而言之，PureComponent自己内部实现了一个shouldComponentUpdate，而不需要我们再去编写比较代码。\nReact.PureComponent的shouldComponentUpdate() 只会对对象进行浅对比。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）。\n测试表明，使用PureComponent的性能会略胜shouldComponentUpdate一筹。\n\n\n### StateLessComponent\n无状态组件（StateLessComponent）又称函数式组件。\n\n``` js\nconst Text = ({ children = 'Hello World!' }) =>\n  <p>{children}</p>\n```\n函数式组件没有class声明，没有生命周期，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。\n\n\n### 箭头函数与bind\n当我们在组件上绑定事件处理函数的时候，为了能正常访问state，通常会使用bind或者箭头函数。\n\n```js\n<Button onClick={this.update.bind(this)} />\n```\n又或者\n\n``` js\n<Button onClick={() => { console.log(\"Click\"); }} />\n```\n\n在以上情况下，bind每次都返回全新的函数，箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同），对于组件来说每次绑定的都是新的函数，Button组件在进行 props 比较的时候会认为前后props不一样，造成重新渲染。\n比较推荐的写法有两种：\n\n``` js\nupdate = () => {\n    //\n}\n<Button onClick={this.update} />\n```\n或者\n``` js\nconstructor(props) {\n    super(props);\n    this.update = this.update.bind(this);\n}\n\nupdate() {\n    //\n}\n<Button onClick={this.update} />\n```\n\n### 内联style\n当我们为组件设置样式的时候，可能会写出如下代码：\n\n\n``` js\n<Button style={{width: 100, marginTop: 50 }} />\n```\n这种写法，每次render时style返回的都是全新的对象，我们知道，引用类型比较的是引用地址，每次的结果都是不相等，也会导致重新渲染。\n推荐的写法是使用className。\n```js\n<Button className=\"btn\" />\n```\n\n### 属性传递与[]\n\n当我们为组件设置缺省值的时候:\n\n``` js\n<RadioGroup options={this.props.options || []} />\n```\n\n如果每次 this.props.options 值都是 null 的话，意味着每次传递给<RadioGroup />都是字面量数组[]，但字面量数组和new Array()效果是一样的，始终生成新的实例，所以表面上看虽然每次传递给组件的都是相同的空数组，其实对组件来说每次都是新的属性，都会引起渲染。所以正确的方式应该将一些常用值以变量的形式保存下来：\n\n``` js\nconst DEFAULT_OPTIONS = [];\n\n<RadioGroup options={this.props.options || DEFAULT_OPTIONS} />\n```\n<div class=\"tip\">\n注意：此处的DEFAULT_OPTIONS不能写在render中，当写在render中的时候，还是会每次都生成一个新的数组，依然会重新渲染，正确的做法是放在组件外面或者使用this.DEFAULT_OPTIONS = []。\n</div>\n\n### map 与 key\n在react中，你应该经常用到map来渲染一个列表，当你忘记为每个列表元素设置key属性的时候，react会在控制台发出警告a key should be provided for list items。\n实际上，Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。\n\n一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key:\n\n``` js\nconst todoItems = todos.map((todo) =>\n  <li key={todo.id}>\n    {todo.text}\n  </li>\n);\n```\n\n当元素没有确定的id时，你可以使用他的序列号索引index作为key：\n\n``` js\nconst todoItems = todos.map((todo, index) =>\n  // Only do this if items have no stable IDs\n  <li key={index}>\n    {todo.text}\n  </li>\n);\n```\n当todoItems中数据发生改变的时候，使用索引作为key的列表都将重新渲染。所以不建议使用索引来进行排序，因为这会导致渲染变得很慢。\n\n### 减少在render内执行变量\n\n我们已经知道，当组件的state和props发生改变的时候，render都会执行，那么，当render中有变量的执行或者函数执行的时候，可能会影响渲染性能，所以，应该减少在render内执行变量或者函数。\n\n### 精简props和state\n从上面我们已经知道，当props和state为引用类型的时候，react内部只对props和state进行浅比较，那么，props和state可以尽量设置为基础数据类型，对象的嵌套层级不要过深，减少props的参数数量，使组件的props和state对象数据尽可能达到扁平化，都可以在一定程度上优化react的渲染性能。\n\n### 总结\n\n本文讨论了一系列编写React代码的原则，旨在从减少重新render的方面来提升react代码的性能。性能优化一直是一个持久的话题，还可以从很多方面去考虑，比如，使用不可变的数据结构immutable.js，使用reselect来缓存redux中的复杂计算，对组件尽可能进行拆分为子组件，都是值得探讨的话题。那么，下次再见。\n","slug":"编写高性能React代码的原则","published":1,"updated":"2020-07-16T13:56:47.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenok002pp70v7iufl5on","content":"<blockquote>\n<p>本文总结了一些编写React代码的建议，有助于理解React的渲染机制，主要是通过减少不必要的重新渲染来提升React性能。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>回顾使用React开发的经历，已有接近两年了，一直想要写一篇文章来介绍如何编写高性能的React代码，又或者是性能调优之类的，于是，我总结了一些编写高性能React代码的实践，或许能让你对React的理解更加深刻。</p>\n<h3 id=\"影响React性能的主要因素\"><a href=\"#影响React性能的主要因素\" class=\"headerlink\" title=\"影响React性能的主要因素\"></a>影响React性能的主要因素</h3><p>React专注于构建用户界面，内部通过VirtualDOM和Diff算法实现视图的更新，本身拥有很高的性能。当组件的state和props改变的时候，React就会重新render，进而更新视图。在render过程中，react会将JSX语法转换为虚拟DOM，同时进行Diff算法比较新旧DOM的变化，从而对视图进行局部更新。试想，当render执行后，JSX转换虚拟DOM，然后Diff，最后发现新旧DOM是一样的，最后并没有更新视图。那么，就导致了不必要的render，造成了性能的浪费。所以，减少不必要的render，成为优化React性能的主要因素。</p>\n<h3 id=\"state只与视图有关\"><a href=\"#state只与视图有关\" class=\"headerlink\" title=\"state只与视图有关\"></a>state只与视图有关</h3><p>编写React组件的时候，你肯定会用到变量，变量可以保存在this上，可以保存到state中，还可以使用全局变量。那么什么时候该使用state呢？答案是只有与视图相关的变量才放在state中，与视图无关的可以放在this上。如果与视图更新无关的变量放在state中，而且这个变量需要频繁的更新，而每次更新都需要重新render，势必造成性能浪费，使用this来存放无疑是更好的选择。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;<span class=\"keyword\">this</span>.add&#125;&gt;+++&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;p className=\"App-intro\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &#123;this.state.count&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>p&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当点击+++触发add事时，setState更新state，但是新旧state完全一样，React并没有在Component组件中进行优化，导致不必要的render执行。此时，需要我们手动进行优化，当state或者props更新后react组件的生命周期shouldComponentUpdate触发，在shouldComponentUpdate中可以对新旧state和props进行比较，判断组件是否需要重新render。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nextState.count === <span class=\"keyword\">this</span>.state.count) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下shouldComponentUpdate返回true，即始终要重新渲染，此处我们使用shouldComponentUpdate进行比较后，返回false，react将不会重新render。</p>\n<p>当state为字符串等基本类型的时候，shouldComponentUpdate还能应付自如，那如果state是对象或者数组等引用类型呢？对于引用类型只能对其进行递归比较才能判断其是否相等，又或者是采用JSON.stringify(nextState.obj) === JSON.stringify(this.state.obj)进行比较，但是当对象嵌套层级较深或者函数、正则等类型时，shouldComponentUpdate便失去了它的用武之地。</p>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><p>React.PureComponent与React.Component 几乎完全相同，但React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。<br>简而言之，PureComponent自己内部实现了一个shouldComponentUpdate，而不需要我们再去编写比较代码。<br>React.PureComponent的shouldComponentUpdate() 只会对对象进行浅对比。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）。<br>测试表明，使用PureComponent的性能会略胜shouldComponentUpdate一筹。</p>\n<h3 id=\"StateLessComponent\"><a href=\"#StateLessComponent\" class=\"headerlink\" title=\"StateLessComponent\"></a>StateLessComponent</h3><p>无状态组件（StateLessComponent）又称函数式组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text = <span class=\"function\">(<span class=\"params\">&#123; children = <span class=\"string\">'Hello World!'</span> &#125;</span>) =&gt;</span></span><br><span class=\"line\">  &lt;p&gt;&#123;children&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br></pre></td></tr></table></figure>\n<p>函数式组件没有class声明，没有生命周期，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。</p>\n<h3 id=\"箭头函数与bind\"><a href=\"#箭头函数与bind\" class=\"headerlink\" title=\"箭头函数与bind\"></a>箭头函数与bind</h3><p>当我们在组件上绑定事件处理函数的时候，为了能正常访问state，通常会使用bind或者箭头函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button onClick=&#123;<span class=\"keyword\">this</span>.update.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>又或者</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button onClick=&#123;() =&gt; &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Click\"</span>); &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>在以上情况下，bind每次都返回全新的函数，箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同），对于组件来说每次绑定的都是新的函数，Button组件在进行 props 比较的时候会认为前后props不一样，造成重新渲染。<br>比较推荐的写法有两种：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;Button onClick=&#123;<span class=\"keyword\">this</span>.update&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>或者<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.update = <span class=\"keyword\">this</span>.update.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">update() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;Button onClick=&#123;<span class=\"keyword\">this</span>.update&#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内联style\"><a href=\"#内联style\" class=\"headerlink\" title=\"内联style\"></a>内联style</h3><p>当我们为组件设置样式的时候，可能会写出如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button style=&#123;&#123;<span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">marginTop</span>: <span class=\"number\">50</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>这种写法，每次render时style返回的都是全新的对象，我们知道，引用类型比较的是引用地址，每次的结果都是不相等，也会导致重新渲染。<br>推荐的写法是使用className。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button className=<span class=\"string\">\"btn\"</span> /&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"属性传递与\"><a href=\"#属性传递与\" class=\"headerlink\" title=\"属性传递与[]\"></a>属性传递与[]</h3><p>当我们为组件设置缺省值的时候:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;RadioGroup options=&#123;<span class=\"keyword\">this</span>.props.options || []&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>如果每次 this.props.options 值都是 null 的话，意味着每次传递给<radiogroup>都是字面量数组[]，但字面量数组和new Array()效果是一样的，始终生成新的实例，所以表面上看虽然每次传递给组件的都是相同的空数组，其实对组件来说每次都是新的属性，都会引起渲染。所以正确的方式应该将一些常用值以变量的形式保存下来：</radiogroup></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DEFAULT_OPTIONS = [];</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;RadioGroup options=&#123;<span class=\"keyword\">this</span>.props.options || DEFAULT_OPTIONS&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>注意：此处的DEFAULT_OPTIONS不能写在render中，当写在render中的时候，还是会每次都生成一个新的数组，依然会重新渲染，正确的做法是放在组件外面或者使用this.DEFAULT_OPTIONS = []。<br></div>\n\n<h3 id=\"map-与-key\"><a href=\"#map-与-key\" class=\"headerlink\" title=\"map 与 key\"></a>map 与 key</h3><p>在react中，你应该经常用到map来渲染一个列表，当你忘记为每个列表元素设置key属性的时候，react会在控制台发出警告a key should be provided for list items。<br>实际上，Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>\n<p>一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todoItems = todos.map(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span></span><br><span class=\"line\">  &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class=\"line\">    &#123;todo.text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>当元素没有确定的id时，你可以使用他的序列号索引index作为key：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todoItems = todos.map(<span class=\"function\">(<span class=\"params\">todo, index</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">// Only do this if items have no stable IDs</span></span><br><span class=\"line\">  &lt;li key=&#123;index&#125;&gt;</span><br><span class=\"line\">    &#123;todo.text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>当todoItems中数据发生改变的时候，使用索引作为key的列表都将重新渲染。所以不建议使用索引来进行排序，因为这会导致渲染变得很慢。</p>\n<h3 id=\"减少在render内执行变量\"><a href=\"#减少在render内执行变量\" class=\"headerlink\" title=\"减少在render内执行变量\"></a>减少在render内执行变量</h3><p>我们已经知道，当组件的state和props发生改变的时候，render都会执行，那么，当render中有变量的执行或者函数执行的时候，可能会影响渲染性能，所以，应该减少在render内执行变量或者函数。</p>\n<h3 id=\"精简props和state\"><a href=\"#精简props和state\" class=\"headerlink\" title=\"精简props和state\"></a>精简props和state</h3><p>从上面我们已经知道，当props和state为引用类型的时候，react内部只对props和state进行浅比较，那么，props和state可以尽量设置为基础数据类型，对象的嵌套层级不要过深，减少props的参数数量，使组件的props和state对象数据尽可能达到扁平化，都可以在一定程度上优化react的渲染性能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文讨论了一系列编写React代码的原则，旨在从减少重新render的方面来提升react代码的性能。性能优化一直是一个持久的话题，还可以从很多方面去考虑，比如，使用不可变的数据结构immutable.js，使用reselect来缓存redux中的复杂计算，对组件尽可能进行拆分为子组件，都是值得探讨的话题。那么，下次再见。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文总结了一些编写React代码的建议，有助于理解React的渲染机制，主要是通过减少不必要的重新渲染来提升React性能。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react.jpg\" alt=\"image\"></p>","more":"<p>回顾使用React开发的经历，已有接近两年了，一直想要写一篇文章来介绍如何编写高性能的React代码，又或者是性能调优之类的，于是，我总结了一些编写高性能React代码的实践，或许能让你对React的理解更加深刻。</p>\n<h3 id=\"影响React性能的主要因素\"><a href=\"#影响React性能的主要因素\" class=\"headerlink\" title=\"影响React性能的主要因素\"></a>影响React性能的主要因素</h3><p>React专注于构建用户界面，内部通过VirtualDOM和Diff算法实现视图的更新，本身拥有很高的性能。当组件的state和props改变的时候，React就会重新render，进而更新视图。在render过程中，react会将JSX语法转换为虚拟DOM，同时进行Diff算法比较新旧DOM的变化，从而对视图进行局部更新。试想，当render执行后，JSX转换虚拟DOM，然后Diff，最后发现新旧DOM是一样的，最后并没有更新视图。那么，就导致了不必要的render，造成了性能的浪费。所以，减少不必要的render，成为优化React性能的主要因素。</p>\n<h3 id=\"state只与视图有关\"><a href=\"#state只与视图有关\" class=\"headerlink\" title=\"state只与视图有关\"></a>state只与视图有关</h3><p>编写React组件的时候，你肯定会用到变量，变量可以保存在this上，可以保存到state中，还可以使用全局变量。那么什么时候该使用state呢？答案是只有与视图相关的变量才放在state中，与视图无关的可以放在this上。如果与视图更新无关的变量放在state中，而且这个变量需要频繁的更新，而每次更新都需要重新render，势必造成性能浪费，使用this来存放无疑是更好的选择。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;<span class=\"keyword\">this</span>.add&#125;&gt;+++&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;p className=\"App-intro\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &#123;this.state.count&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>p&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当点击+++触发add事时，setState更新state，但是新旧state完全一样，React并没有在Component组件中进行优化，导致不必要的render执行。此时，需要我们手动进行优化，当state或者props更新后react组件的生命周期shouldComponentUpdate触发，在shouldComponentUpdate中可以对新旧state和props进行比较，判断组件是否需要重新render。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nextState.count === <span class=\"keyword\">this</span>.state.count) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下shouldComponentUpdate返回true，即始终要重新渲染，此处我们使用shouldComponentUpdate进行比较后，返回false，react将不会重新render。</p>\n<p>当state为字符串等基本类型的时候，shouldComponentUpdate还能应付自如，那如果state是对象或者数组等引用类型呢？对于引用类型只能对其进行递归比较才能判断其是否相等，又或者是采用JSON.stringify(nextState.obj) === JSON.stringify(this.state.obj)进行比较，但是当对象嵌套层级较深或者函数、正则等类型时，shouldComponentUpdate便失去了它的用武之地。</p>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><p>React.PureComponent与React.Component 几乎完全相同，但React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。<br>简而言之，PureComponent自己内部实现了一个shouldComponentUpdate，而不需要我们再去编写比较代码。<br>React.PureComponent的shouldComponentUpdate() 只会对对象进行浅对比。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）。<br>测试表明，使用PureComponent的性能会略胜shouldComponentUpdate一筹。</p>\n<h3 id=\"StateLessComponent\"><a href=\"#StateLessComponent\" class=\"headerlink\" title=\"StateLessComponent\"></a>StateLessComponent</h3><p>无状态组件（StateLessComponent）又称函数式组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text = <span class=\"function\">(<span class=\"params\">&#123; children = <span class=\"string\">'Hello World!'</span> &#125;</span>) =&gt;</span></span><br><span class=\"line\">  &lt;p&gt;&#123;children&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br></pre></td></tr></table></figure>\n<p>函数式组件没有class声明，没有生命周期，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。</p>\n<h3 id=\"箭头函数与bind\"><a href=\"#箭头函数与bind\" class=\"headerlink\" title=\"箭头函数与bind\"></a>箭头函数与bind</h3><p>当我们在组件上绑定事件处理函数的时候，为了能正常访问state，通常会使用bind或者箭头函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button onClick=&#123;<span class=\"keyword\">this</span>.update.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>又或者</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button onClick=&#123;() =&gt; &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Click\"</span>); &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>在以上情况下，bind每次都返回全新的函数，箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同），对于组件来说每次绑定的都是新的函数，Button组件在进行 props 比较的时候会认为前后props不一样，造成重新渲染。<br>比较推荐的写法有两种：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">update = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;Button onClick=&#123;<span class=\"keyword\">this</span>.update&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>或者<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.update = <span class=\"keyword\">this</span>.update.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">update() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;Button onClick=&#123;<span class=\"keyword\">this</span>.update&#125; /&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内联style\"><a href=\"#内联style\" class=\"headerlink\" title=\"内联style\"></a>内联style</h3><p>当我们为组件设置样式的时候，可能会写出如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button style=&#123;&#123;<span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">marginTop</span>: <span class=\"number\">50</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>这种写法，每次render时style返回的都是全新的对象，我们知道，引用类型比较的是引用地址，每次的结果都是不相等，也会导致重新渲染。<br>推荐的写法是使用className。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button className=<span class=\"string\">\"btn\"</span> /&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"属性传递与\"><a href=\"#属性传递与\" class=\"headerlink\" title=\"属性传递与[]\"></a>属性传递与[]</h3><p>当我们为组件设置缺省值的时候:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;RadioGroup options=&#123;<span class=\"keyword\">this</span>.props.options || []&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>如果每次 this.props.options 值都是 null 的话，意味着每次传递给<radiogroup>都是字面量数组[]，但字面量数组和new Array()效果是一样的，始终生成新的实例，所以表面上看虽然每次传递给组件的都是相同的空数组，其实对组件来说每次都是新的属性，都会引起渲染。所以正确的方式应该将一些常用值以变量的形式保存下来：</radiogroup></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DEFAULT_OPTIONS = [];</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;RadioGroup options=&#123;<span class=\"keyword\">this</span>.props.options || DEFAULT_OPTIONS&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>注意：此处的DEFAULT_OPTIONS不能写在render中，当写在render中的时候，还是会每次都生成一个新的数组，依然会重新渲染，正确的做法是放在组件外面或者使用this.DEFAULT_OPTIONS = []。<br></div>\n\n<h3 id=\"map-与-key\"><a href=\"#map-与-key\" class=\"headerlink\" title=\"map 与 key\"></a>map 与 key</h3><p>在react中，你应该经常用到map来渲染一个列表，当你忘记为每个列表元素设置key属性的时候，react会在控制台发出警告a key should be provided for list items。<br>实际上，Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>\n<p>一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todoItems = todos.map(<span class=\"function\">(<span class=\"params\">todo</span>) =&gt;</span></span><br><span class=\"line\">  &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class=\"line\">    &#123;todo.text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>当元素没有确定的id时，你可以使用他的序列号索引index作为key：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todoItems = todos.map(<span class=\"function\">(<span class=\"params\">todo, index</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">// Only do this if items have no stable IDs</span></span><br><span class=\"line\">  &lt;li key=&#123;index&#125;&gt;</span><br><span class=\"line\">    &#123;todo.text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>当todoItems中数据发生改变的时候，使用索引作为key的列表都将重新渲染。所以不建议使用索引来进行排序，因为这会导致渲染变得很慢。</p>\n<h3 id=\"减少在render内执行变量\"><a href=\"#减少在render内执行变量\" class=\"headerlink\" title=\"减少在render内执行变量\"></a>减少在render内执行变量</h3><p>我们已经知道，当组件的state和props发生改变的时候，render都会执行，那么，当render中有变量的执行或者函数执行的时候，可能会影响渲染性能，所以，应该减少在render内执行变量或者函数。</p>\n<h3 id=\"精简props和state\"><a href=\"#精简props和state\" class=\"headerlink\" title=\"精简props和state\"></a>精简props和state</h3><p>从上面我们已经知道，当props和state为引用类型的时候，react内部只对props和state进行浅比较，那么，props和state可以尽量设置为基础数据类型，对象的嵌套层级不要过深，减少props的参数数量，使组件的props和state对象数据尽可能达到扁平化，都可以在一定程度上优化react的渲染性能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文讨论了一系列编写React代码的原则，旨在从减少重新render的方面来提升react代码的性能。性能优化一直是一个持久的话题，还可以从很多方面去考虑，比如，使用不可变的数据结构immutable.js，使用reselect来缓存redux中的复杂计算，对组件尽可能进行拆分为子组件，都是值得探讨的话题。那么，下次再见。</p>"},{"title":"谈谈React中的组件","date":"2018-03-19T13:00:56.000Z","banner":"http://img.yanyuanfe.cn/photo-1454165804606-c3d57bc86b40%20%281%29.jpeg","_content":"\n> React的核心思想是一切皆组件\n\n![image](http://img.yanyuanfe.cn/react.png)\n\n<!--more-->\n\n在React中，一切皆组件。组件可以将UI切分为一系列独立的、可复用的部件，这样使我们可以专注于构建每一个单独的部件。\n\n理解React中各种各样的组件对于更好的学习React变得尤为重要，如UI组件、容器组件、无状态组件、函数式组件，对react了解不够深入的人通常对于这些概念理解不够清晰，很难写出高质量的react组件，本文是我对于React的组件的一些理解。\n\n### Component\n\nCompoent在这里指React.Component，大多数人一开始学习React了解最多的便是Component。使用Component可以非常方便的定义一个组件。\n使用ES6的class来定义一个组件如下：\n\n\n``` js\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n\n### PureComponent\n\nPureComponent在这里指React.PureComponent，PureComponent与Component几乎完全相同，但是PureComponent通过props和state的浅对比来实现shouldComponentUpdate（）。\n\n``` js\nclass Welcome extends React.PureComponent {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n在React的生命周期中，当组件的props和state发生改变时，会执行组件的shouldComponentUpdate函数，当该函数返回为true时组件重新渲染，返回为false则不重新渲染。使用Component定义的组件中，shouldComponentUpdate默认返回为true，通常当组件遭遇性能问题时，可以在shouldComponent中对新旧属性和状态进行相等判断，来减少不必要的重新渲染。\n\nPureComponent是react v15.3.0中新加入的特性，默认实现了shouldComponentUpdate中对于新旧属性和状态的相等比较，减少不必要的重新渲染来提升性能。\n\n注意：PureComponent的shouldComponentUpdate只会对对象进行浅比较，当对象层级较深或者结构复杂时，可能会出现对象深层数据已改变而视图没有更新的问题，使用时需要注意。\n\n### 函数式组件\n\n上述使用Component和PureComponent定义的组件称为声明式组件。在react中，还可以使用函数定义一个组件，称为函数式组件。如下：\n\n\n``` js\nconst Text = ({ children = 'Hello World!' }) =>\n  <p>{children}</p>\n```\n\n函数式组件又称无状态（stateless）组件，在组件中不能对状态（state）进行操作，使用函数式组件使react的代码更具有可读性，可以减少诸如class、constructor等冗余代码，有利于组件复用。\n函数式组件具有以下特点：\n\n1. 函数式组件不会被实例化，提升了整体渲染性能。\n\n函数式组件没有class声明，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。\n\n2. 函数式组件不能访问this对象。\n\n函数式组件内部不能访问this.state，无法操作状态。\n3. 函数式组件没有生命周期。\n4. 函数式组件只接受props和context参数，没有副作用。\n\n### UI组件和容器组件\n\n在结合redux管理数据流的应用中，redux将组件分为UI组件（presentational component）和容器组件（container component）。UI组件又称为展示型组件。在早期的Redux的版本中，作者将上述两种组件定义为智能（Smart）组件和木桶（Dumb）组件，两者的区别是看是否有数据操作。Dumb组件对应UI组件，Smart组件对应容器组件。UI组件只负责UI的呈现，不负责业务逻辑;内部没有状态，数据由this.props参数提供;容器组件负责处理业务逻辑，不负责UI呈现;有内部状态;使用Redux的API连接UI组件。\n\n通常在项目的文件结构中，components文件夹包含UI组件，containers文件夹包含容器组件。\n\n### 纯组件\n提到纯组件，先来回顾一下函数式编程中的“纯函数”，纯函数由三大原则构成：\n- 给定相同的输入，总是返回相同的输出;\n- 函数执行过程中不会产生副作用（side effect）;\n- 没有额外的状态依赖;\n\n在react中，使用纯组件可以提高Virtual DOM的执行效率，那么，怎样的组件才是纯组件呢？\n\n首先，PureComponent并不是纯组件，因为在组件中存在生命周期，并且拥有内部状态state，可以产生副作用。\n\n通常，函数式组件、UI组件、无状态组件这类仅接受props参数进行数据渲染的组件可以称为纯组件，它们接受相同的输入参数props，返回相同的输出，且不具有副作用。\n\n### 受控组件\n在HTML中，像input,textarea, 和 select这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 setState(). 方法进行更新。\n\n在react中，使用state来控制表单元素的数据的显示，同时控制表单元素输入引起值的变化并更新state来进行表单元素数据的更新，其值由React控制的输入表单元素称为“受控组件”。\n考虑如下代码：\n\n\n``` js\nclass Form extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n上述代码是一个受控组件的示例，由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。\n\n### 非受控组件\n\n在大多数情况下，我们推荐使用 受控组件 来实现表单。 在受控组件中表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。\n\n要编写一个非受控组件，而非为每个状态更新编写事件处理程序，你可以 使用 ref 从 DOM 获取表单值。\n考虑如下代码：\n\n``` js\nclass Form extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.input.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={(input) => this.input = input} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n 由于非受控组件将真实数据保存在 DOM 中，因此在使用非受控组件时，更容易同时集成 React 和非 React 代码。如果你想快速而随性，这样做可以减小代码量。否则，你应该使用受控组件。\n\n通常，不建议使用非受控组件。\n\n### 高阶组件\n\n高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。\n\n具体而言，高阶组件类似于高阶函数，且该函数接受一个React组件作为参数，并返回一个新的组件。\n\n\n``` js\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n\n\n你或许没听过高阶组件之前已经使用过了，在react的一些第三方库，如react-redux的connect，react-router-dom的withRouter等等。\n\n高阶组件可以让代码更具有复用性、逻辑性与抽象特性。它可以对render方法做劫持，也可以控制props与state。\n\n考虑以下代码：\n\n``` js\nexport default function Form(Comp) {\n  return class WrapperComp extends Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n\n      }\n      this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(key, val) {\n      this.setState({\n        [key]: val\n      })\n    }\n\n    render() {\n      return <Comp {...this.props} handleChange={this.handleChange} state={this.state}/>\n    }\n  }\n}\n```\n\n上述代码是一个高阶组件，为了解决使用表单组件时频繁的编写时间处理函数来管理表单数据的问题。使用方法如下：\n\n``` js\nclass Login extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n\n    }\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(key, val) {\n    this.setState({\n      [key]: val\n    })\n  }\n\n  render() {\n    return (\n      <div className=\"login\">\n        <input\n          type=\"text\"\n          value={this.props.state.user}\n          onChange={(e) => this.props.handleChange('user', e.target.value)}\n        />\n        <input\n          type=\"password\"\n          value={this.props.state.psw}\n          onChange={(e) => this.props.handleChange('psw', e.target.value)}\n        />\n      </div>\n    )\n  }\n}\n\nexport default Form(Login);\n```\n\n\n这样，对于需要在很多地方使用表单的组件，可以提供组件复用度，减少样板代码。\n\n\n\n> 参考：https://react.bootcss.com/","source":"_posts/谈谈React中的组件.md","raw":"---\ntitle: 谈谈React中的组件\ndate: 2018-03-19 21:00:56\nbanner: http://img.yanyuanfe.cn/photo-1454165804606-c3d57bc86b40%20%281%29.jpeg\ntags:\n- React\n---\n\n> React的核心思想是一切皆组件\n\n![image](http://img.yanyuanfe.cn/react.png)\n\n<!--more-->\n\n在React中，一切皆组件。组件可以将UI切分为一系列独立的、可复用的部件，这样使我们可以专注于构建每一个单独的部件。\n\n理解React中各种各样的组件对于更好的学习React变得尤为重要，如UI组件、容器组件、无状态组件、函数式组件，对react了解不够深入的人通常对于这些概念理解不够清晰，很难写出高质量的react组件，本文是我对于React的组件的一些理解。\n\n### Component\n\nCompoent在这里指React.Component，大多数人一开始学习React了解最多的便是Component。使用Component可以非常方便的定义一个组件。\n使用ES6的class来定义一个组件如下：\n\n\n``` js\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n\n### PureComponent\n\nPureComponent在这里指React.PureComponent，PureComponent与Component几乎完全相同，但是PureComponent通过props和state的浅对比来实现shouldComponentUpdate（）。\n\n``` js\nclass Welcome extends React.PureComponent {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n在React的生命周期中，当组件的props和state发生改变时，会执行组件的shouldComponentUpdate函数，当该函数返回为true时组件重新渲染，返回为false则不重新渲染。使用Component定义的组件中，shouldComponentUpdate默认返回为true，通常当组件遭遇性能问题时，可以在shouldComponent中对新旧属性和状态进行相等判断，来减少不必要的重新渲染。\n\nPureComponent是react v15.3.0中新加入的特性，默认实现了shouldComponentUpdate中对于新旧属性和状态的相等比较，减少不必要的重新渲染来提升性能。\n\n注意：PureComponent的shouldComponentUpdate只会对对象进行浅比较，当对象层级较深或者结构复杂时，可能会出现对象深层数据已改变而视图没有更新的问题，使用时需要注意。\n\n### 函数式组件\n\n上述使用Component和PureComponent定义的组件称为声明式组件。在react中，还可以使用函数定义一个组件，称为函数式组件。如下：\n\n\n``` js\nconst Text = ({ children = 'Hello World!' }) =>\n  <p>{children}</p>\n```\n\n函数式组件又称无状态（stateless）组件，在组件中不能对状态（state）进行操作，使用函数式组件使react的代码更具有可读性，可以减少诸如class、constructor等冗余代码，有利于组件复用。\n函数式组件具有以下特点：\n\n1. 函数式组件不会被实例化，提升了整体渲染性能。\n\n函数式组件没有class声明，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。\n\n2. 函数式组件不能访问this对象。\n\n函数式组件内部不能访问this.state，无法操作状态。\n3. 函数式组件没有生命周期。\n4. 函数式组件只接受props和context参数，没有副作用。\n\n### UI组件和容器组件\n\n在结合redux管理数据流的应用中，redux将组件分为UI组件（presentational component）和容器组件（container component）。UI组件又称为展示型组件。在早期的Redux的版本中，作者将上述两种组件定义为智能（Smart）组件和木桶（Dumb）组件，两者的区别是看是否有数据操作。Dumb组件对应UI组件，Smart组件对应容器组件。UI组件只负责UI的呈现，不负责业务逻辑;内部没有状态，数据由this.props参数提供;容器组件负责处理业务逻辑，不负责UI呈现;有内部状态;使用Redux的API连接UI组件。\n\n通常在项目的文件结构中，components文件夹包含UI组件，containers文件夹包含容器组件。\n\n### 纯组件\n提到纯组件，先来回顾一下函数式编程中的“纯函数”，纯函数由三大原则构成：\n- 给定相同的输入，总是返回相同的输出;\n- 函数执行过程中不会产生副作用（side effect）;\n- 没有额外的状态依赖;\n\n在react中，使用纯组件可以提高Virtual DOM的执行效率，那么，怎样的组件才是纯组件呢？\n\n首先，PureComponent并不是纯组件，因为在组件中存在生命周期，并且拥有内部状态state，可以产生副作用。\n\n通常，函数式组件、UI组件、无状态组件这类仅接受props参数进行数据渲染的组件可以称为纯组件，它们接受相同的输入参数props，返回相同的输出，且不具有副作用。\n\n### 受控组件\n在HTML中，像input,textarea, 和 select这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 setState(). 方法进行更新。\n\n在react中，使用state来控制表单元素的数据的显示，同时控制表单元素输入引起值的变化并更新state来进行表单元素数据的更新，其值由React控制的输入表单元素称为“受控组件”。\n考虑如下代码：\n\n\n``` js\nclass Form extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n上述代码是一个受控组件的示例，由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。\n\n### 非受控组件\n\n在大多数情况下，我们推荐使用 受控组件 来实现表单。 在受控组件中表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。\n\n要编写一个非受控组件，而非为每个状态更新编写事件处理程序，你可以 使用 ref 从 DOM 获取表单值。\n考虑如下代码：\n\n``` js\nclass Form extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.input.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={(input) => this.input = input} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n 由于非受控组件将真实数据保存在 DOM 中，因此在使用非受控组件时，更容易同时集成 React 和非 React 代码。如果你想快速而随性，这样做可以减小代码量。否则，你应该使用受控组件。\n\n通常，不建议使用非受控组件。\n\n### 高阶组件\n\n高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。\n\n具体而言，高阶组件类似于高阶函数，且该函数接受一个React组件作为参数，并返回一个新的组件。\n\n\n``` js\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n\n\n你或许没听过高阶组件之前已经使用过了，在react的一些第三方库，如react-redux的connect，react-router-dom的withRouter等等。\n\n高阶组件可以让代码更具有复用性、逻辑性与抽象特性。它可以对render方法做劫持，也可以控制props与state。\n\n考虑以下代码：\n\n``` js\nexport default function Form(Comp) {\n  return class WrapperComp extends Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n\n      }\n      this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(key, val) {\n      this.setState({\n        [key]: val\n      })\n    }\n\n    render() {\n      return <Comp {...this.props} handleChange={this.handleChange} state={this.state}/>\n    }\n  }\n}\n```\n\n上述代码是一个高阶组件，为了解决使用表单组件时频繁的编写时间处理函数来管理表单数据的问题。使用方法如下：\n\n``` js\nclass Login extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n\n    }\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(key, val) {\n    this.setState({\n      [key]: val\n    })\n  }\n\n  render() {\n    return (\n      <div className=\"login\">\n        <input\n          type=\"text\"\n          value={this.props.state.user}\n          onChange={(e) => this.props.handleChange('user', e.target.value)}\n        />\n        <input\n          type=\"password\"\n          value={this.props.state.psw}\n          onChange={(e) => this.props.handleChange('psw', e.target.value)}\n        />\n      </div>\n    )\n  }\n}\n\nexport default Form(Login);\n```\n\n\n这样，对于需要在很多地方使用表单的组件，可以提供组件复用度，减少样板代码。\n\n\n\n> 参考：https://react.bootcss.com/","slug":"谈谈React中的组件","published":1,"updated":"2020-07-16T13:56:47.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenol002sp70vymvsy9z0","content":"<blockquote>\n<p>React的核心思想是一切皆组件</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>在React中，一切皆组件。组件可以将UI切分为一系列独立的、可复用的部件，这样使我们可以专注于构建每一个单独的部件。</p>\n<p>理解React中各种各样的组件对于更好的学习React变得尤为重要，如UI组件、容器组件、无状态组件、函数式组件，对react了解不够深入的人通常对于这些概念理解不够清晰，很难写出高质量的react组件，本文是我对于React的组件的一些理解。</p>\n<h3 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"Component\"></a>Component</h3><p>Compoent在这里指React.Component，大多数人一开始学习React了解最多的便是Component。使用Component可以非常方便的定义一个组件。<br>使用ES6的class来定义一个组件如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><p>PureComponent在这里指React.PureComponent，PureComponent与Component几乎完全相同，但是PureComponent通过props和state的浅对比来实现shouldComponentUpdate（）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">PureComponent</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在React的生命周期中，当组件的props和state发生改变时，会执行组件的shouldComponentUpdate函数，当该函数返回为true时组件重新渲染，返回为false则不重新渲染。使用Component定义的组件中，shouldComponentUpdate默认返回为true，通常当组件遭遇性能问题时，可以在shouldComponent中对新旧属性和状态进行相等判断，来减少不必要的重新渲染。</p>\n<p>PureComponent是react v15.3.0中新加入的特性，默认实现了shouldComponentUpdate中对于新旧属性和状态的相等比较，减少不必要的重新渲染来提升性能。</p>\n<p>注意：PureComponent的shouldComponentUpdate只会对对象进行浅比较，当对象层级较深或者结构复杂时，可能会出现对象深层数据已改变而视图没有更新的问题，使用时需要注意。</p>\n<h3 id=\"函数式组件\"><a href=\"#函数式组件\" class=\"headerlink\" title=\"函数式组件\"></a>函数式组件</h3><p>上述使用Component和PureComponent定义的组件称为声明式组件。在react中，还可以使用函数定义一个组件，称为函数式组件。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text = <span class=\"function\">(<span class=\"params\">&#123; children = <span class=\"string\">'Hello World!'</span> &#125;</span>) =&gt;</span></span><br><span class=\"line\">  &lt;p&gt;&#123;children&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br></pre></td></tr></table></figure>\n<p>函数式组件又称无状态（stateless）组件，在组件中不能对状态（state）进行操作，使用函数式组件使react的代码更具有可读性，可以减少诸如class、constructor等冗余代码，有利于组件复用。<br>函数式组件具有以下特点：</p>\n<ol>\n<li>函数式组件不会被实例化，提升了整体渲染性能。</li>\n</ol>\n<p>函数式组件没有class声明，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。</p>\n<ol start=\"2\">\n<li>函数式组件不能访问this对象。</li>\n</ol>\n<p>函数式组件内部不能访问this.state，无法操作状态。</p>\n<ol start=\"3\">\n<li>函数式组件没有生命周期。</li>\n<li>函数式组件只接受props和context参数，没有副作用。</li>\n</ol>\n<h3 id=\"UI组件和容器组件\"><a href=\"#UI组件和容器组件\" class=\"headerlink\" title=\"UI组件和容器组件\"></a>UI组件和容器组件</h3><p>在结合redux管理数据流的应用中，redux将组件分为UI组件（presentational component）和容器组件（container component）。UI组件又称为展示型组件。在早期的Redux的版本中，作者将上述两种组件定义为智能（Smart）组件和木桶（Dumb）组件，两者的区别是看是否有数据操作。Dumb组件对应UI组件，Smart组件对应容器组件。UI组件只负责UI的呈现，不负责业务逻辑;内部没有状态，数据由this.props参数提供;容器组件负责处理业务逻辑，不负责UI呈现;有内部状态;使用Redux的API连接UI组件。</p>\n<p>通常在项目的文件结构中，components文件夹包含UI组件，containers文件夹包含容器组件。</p>\n<h3 id=\"纯组件\"><a href=\"#纯组件\" class=\"headerlink\" title=\"纯组件\"></a>纯组件</h3><p>提到纯组件，先来回顾一下函数式编程中的“纯函数”，纯函数由三大原则构成：</p>\n<ul>\n<li>给定相同的输入，总是返回相同的输出;</li>\n<li>函数执行过程中不会产生副作用（side effect）;</li>\n<li>没有额外的状态依赖;</li>\n</ul>\n<p>在react中，使用纯组件可以提高Virtual DOM的执行效率，那么，怎样的组件才是纯组件呢？</p>\n<p>首先，PureComponent并不是纯组件，因为在组件中存在生命周期，并且拥有内部状态state，可以产生副作用。</p>\n<p>通常，函数式组件、UI组件、无状态组件这类仅接受props参数进行数据渲染的组件可以称为纯组件，它们接受相同的输入参数props，返回相同的输出，且不具有副作用。</p>\n<h3 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h3><p>在HTML中，像input,textarea, 和 select这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 setState(). 方法进行更新。</p>\n<p>在react中，使用state来控制表单元素的数据的显示，同时控制表单元素输入引起值的变化并更新state来进行表单元素数据的更新，其值由React控制的输入表单元素称为“受控组件”。<br>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Form</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: event.target.value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleSubmit(event) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.state.value);</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form onSubmit=&#123;<span class=\"keyword\">this</span>.handleSubmit&#125;&gt;</span><br><span class=\"line\">        &lt;label&gt;</span><br><span class=\"line\">          Name:</span><br><span class=\"line\">          &lt;input type=<span class=\"string\">\"text\"</span> value=&#123;<span class=\"keyword\">this</span>.state.value&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/label&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;input type=\"submit\" value=\"Submit\" /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>上述代码是一个受控组件的示例，由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。</p>\n<h3 id=\"非受控组件\"><a href=\"#非受控组件\" class=\"headerlink\" title=\"非受控组件\"></a>非受控组件</h3><p>在大多数情况下，我们推荐使用 受控组件 来实现表单。 在受控组件中表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。</p>\n<p>要编写一个非受控组件，而非为每个状态更新编写事件处理程序，你可以 使用 ref 从 DOM 获取表单值。<br>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Form</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleSubmit(event) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.input.value);</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form onSubmit=&#123;<span class=\"keyword\">this</span>.handleSubmit&#125;&gt;</span><br><span class=\"line\">        &lt;label&gt;</span><br><span class=\"line\">          Name:</span><br><span class=\"line\">          &lt;input type=<span class=\"string\">\"text\"</span> ref=&#123;(input) =&gt; <span class=\"keyword\">this</span>.input = input&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/label&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;input type=\"submit\" value=\"Submit\" /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p> 由于非受控组件将真实数据保存在 DOM 中，因此在使用非受控组件时，更容易同时集成 React 和非 React 代码。如果你想快速而随性，这样做可以减小代码量。否则，你应该使用受控组件。</p>\n<p>通常，不建议使用非受控组件。</p>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。</p>\n<p>具体而言，高阶组件类似于高阶函数，且该函数接受一个React组件作为参数，并返回一个新的组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>\n<p>你或许没听过高阶组件之前已经使用过了，在react的一些第三方库，如react-redux的connect，react-router-dom的withRouter等等。</p>\n<p>高阶组件可以让代码更具有复用性、逻辑性与抽象特性。它可以对render方法做劫持，也可以控制props与state。</p>\n<p>考虑以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Form</span>(<span class=\"params\">Comp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WrapperComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange(key, val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        [key]: val</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Comp</span> &#123;<span class=\"attr\">...this.props</span>&#125; <span class=\"attr\">handleChange</span>=<span class=\"string\">&#123;this.handleChange&#125;</span> <span class=\"attr\">state</span>=<span class=\"string\">&#123;this.state&#125;/</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是一个高阶组件，为了解决使用表单组件时频繁的编写时间处理函数来管理表单数据的问题。使用方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(key, val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      [key]: val</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=<span class=\"string\">\"text\"</span></span><br><span class=\"line\">          value=&#123;<span class=\"keyword\">this</span>.props.state.user&#125;</span><br><span class=\"line\">          onChange=&#123;(e) =&gt; <span class=\"keyword\">this</span>.props.handleChange(<span class=\"string\">'user'</span>, e.target.value)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=<span class=\"string\">\"password\"</span></span><br><span class=\"line\">          value=&#123;<span class=\"keyword\">this</span>.props.state.psw&#125;</span><br><span class=\"line\">          onChange=&#123;(e) =&gt; <span class=\"keyword\">this</span>.props.handleChange(<span class=\"string\">'psw'</span>, e.target.value)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Form(Login);</span></span><br></pre></td></tr></table></figure>\n<p>这样，对于需要在很多地方使用表单的组件，可以提供组件复用度，减少样板代码。</p>\n<blockquote>\n<p>参考：<a href=\"https://react.bootcss.com/\" target=\"_blank\" rel=\"noopener\">https://react.bootcss.com/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>React的核心思想是一切皆组件</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/react.png\" alt=\"image\"></p>","more":"<p>在React中，一切皆组件。组件可以将UI切分为一系列独立的、可复用的部件，这样使我们可以专注于构建每一个单独的部件。</p>\n<p>理解React中各种各样的组件对于更好的学习React变得尤为重要，如UI组件、容器组件、无状态组件、函数式组件，对react了解不够深入的人通常对于这些概念理解不够清晰，很难写出高质量的react组件，本文是我对于React的组件的一些理解。</p>\n<h3 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"Component\"></a>Component</h3><p>Compoent在这里指React.Component，大多数人一开始学习React了解最多的便是Component。使用Component可以非常方便的定义一个组件。<br>使用ES6的class来定义一个组件如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><p>PureComponent在这里指React.PureComponent，PureComponent与Component几乎完全相同，但是PureComponent通过props和state的浅对比来实现shouldComponentUpdate（）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">PureComponent</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在React的生命周期中，当组件的props和state发生改变时，会执行组件的shouldComponentUpdate函数，当该函数返回为true时组件重新渲染，返回为false则不重新渲染。使用Component定义的组件中，shouldComponentUpdate默认返回为true，通常当组件遭遇性能问题时，可以在shouldComponent中对新旧属性和状态进行相等判断，来减少不必要的重新渲染。</p>\n<p>PureComponent是react v15.3.0中新加入的特性，默认实现了shouldComponentUpdate中对于新旧属性和状态的相等比较，减少不必要的重新渲染来提升性能。</p>\n<p>注意：PureComponent的shouldComponentUpdate只会对对象进行浅比较，当对象层级较深或者结构复杂时，可能会出现对象深层数据已改变而视图没有更新的问题，使用时需要注意。</p>\n<h3 id=\"函数式组件\"><a href=\"#函数式组件\" class=\"headerlink\" title=\"函数式组件\"></a>函数式组件</h3><p>上述使用Component和PureComponent定义的组件称为声明式组件。在react中，还可以使用函数定义一个组件，称为函数式组件。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text = <span class=\"function\">(<span class=\"params\">&#123; children = <span class=\"string\">'Hello World!'</span> &#125;</span>) =&gt;</span></span><br><span class=\"line\">  &lt;p&gt;&#123;children&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br></pre></td></tr></table></figure>\n<p>函数式组件又称无状态（stateless）组件，在组件中不能对状态（state）进行操作，使用函数式组件使react的代码更具有可读性，可以减少诸如class、constructor等冗余代码，有利于组件复用。<br>函数式组件具有以下特点：</p>\n<ol>\n<li>函数式组件不会被实例化，提升了整体渲染性能。</li>\n</ol>\n<p>函数式组件没有class声明，仅使用render方法实现，不存在组件实例化的过程，因此不需要分配多余的内存，从而提升了渲染性能。</p>\n<ol start=\"2\">\n<li>函数式组件不能访问this对象。</li>\n</ol>\n<p>函数式组件内部不能访问this.state，无法操作状态。</p>\n<ol start=\"3\">\n<li>函数式组件没有生命周期。</li>\n<li>函数式组件只接受props和context参数，没有副作用。</li>\n</ol>\n<h3 id=\"UI组件和容器组件\"><a href=\"#UI组件和容器组件\" class=\"headerlink\" title=\"UI组件和容器组件\"></a>UI组件和容器组件</h3><p>在结合redux管理数据流的应用中，redux将组件分为UI组件（presentational component）和容器组件（container component）。UI组件又称为展示型组件。在早期的Redux的版本中，作者将上述两种组件定义为智能（Smart）组件和木桶（Dumb）组件，两者的区别是看是否有数据操作。Dumb组件对应UI组件，Smart组件对应容器组件。UI组件只负责UI的呈现，不负责业务逻辑;内部没有状态，数据由this.props参数提供;容器组件负责处理业务逻辑，不负责UI呈现;有内部状态;使用Redux的API连接UI组件。</p>\n<p>通常在项目的文件结构中，components文件夹包含UI组件，containers文件夹包含容器组件。</p>\n<h3 id=\"纯组件\"><a href=\"#纯组件\" class=\"headerlink\" title=\"纯组件\"></a>纯组件</h3><p>提到纯组件，先来回顾一下函数式编程中的“纯函数”，纯函数由三大原则构成：</p>\n<ul>\n<li>给定相同的输入，总是返回相同的输出;</li>\n<li>函数执行过程中不会产生副作用（side effect）;</li>\n<li>没有额外的状态依赖;</li>\n</ul>\n<p>在react中，使用纯组件可以提高Virtual DOM的执行效率，那么，怎样的组件才是纯组件呢？</p>\n<p>首先，PureComponent并不是纯组件，因为在组件中存在生命周期，并且拥有内部状态state，可以产生副作用。</p>\n<p>通常，函数式组件、UI组件、无状态组件这类仅接受props参数进行数据渲染的组件可以称为纯组件，它们接受相同的输入参数props，返回相同的输出，且不具有副作用。</p>\n<h3 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h3><p>在HTML中，像input,textarea, 和 select这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 setState(). 方法进行更新。</p>\n<p>在react中，使用state来控制表单元素的数据的显示，同时控制表单元素输入引起值的变化并更新state来进行表单元素数据的更新，其值由React控制的输入表单元素称为“受控组件”。<br>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Form</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: event.target.value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleSubmit(event) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.state.value);</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form onSubmit=&#123;<span class=\"keyword\">this</span>.handleSubmit&#125;&gt;</span><br><span class=\"line\">        &lt;label&gt;</span><br><span class=\"line\">          Name:</span><br><span class=\"line\">          &lt;input type=<span class=\"string\">\"text\"</span> value=&#123;<span class=\"keyword\">this</span>.state.value&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/label&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;input type=\"submit\" value=\"Submit\" /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>上述代码是一个受控组件的示例，由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。</p>\n<h3 id=\"非受控组件\"><a href=\"#非受控组件\" class=\"headerlink\" title=\"非受控组件\"></a>非受控组件</h3><p>在大多数情况下，我们推荐使用 受控组件 来实现表单。 在受控组件中表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。</p>\n<p>要编写一个非受控组件，而非为每个状态更新编写事件处理程序，你可以 使用 ref 从 DOM 获取表单值。<br>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Form</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleSubmit(event) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.input.value);</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form onSubmit=&#123;<span class=\"keyword\">this</span>.handleSubmit&#125;&gt;</span><br><span class=\"line\">        &lt;label&gt;</span><br><span class=\"line\">          Name:</span><br><span class=\"line\">          &lt;input type=<span class=\"string\">\"text\"</span> ref=&#123;(input) =&gt; <span class=\"keyword\">this</span>.input = input&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/label&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;input type=\"submit\" value=\"Submit\" /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p> 由于非受控组件将真实数据保存在 DOM 中，因此在使用非受控组件时，更容易同时集成 React 和非 React 代码。如果你想快速而随性，这样做可以减小代码量。否则，你应该使用受控组件。</p>\n<p>通常，不建议使用非受控组件。</p>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。</p>\n<p>具体而言，高阶组件类似于高阶函数，且该函数接受一个React组件作为参数，并返回一个新的组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>\n<p>你或许没听过高阶组件之前已经使用过了，在react的一些第三方库，如react-redux的connect，react-router-dom的withRouter等等。</p>\n<p>高阶组件可以让代码更具有复用性、逻辑性与抽象特性。它可以对render方法做劫持，也可以控制props与state。</p>\n<p>考虑以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Form</span>(<span class=\"params\">Comp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WrapperComp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange(key, val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        [key]: val</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Comp</span> &#123;<span class=\"attr\">...this.props</span>&#125; <span class=\"attr\">handleChange</span>=<span class=\"string\">&#123;this.handleChange&#125;</span> <span class=\"attr\">state</span>=<span class=\"string\">&#123;this.state&#125;/</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是一个高阶组件，为了解决使用表单组件时频繁的编写时间处理函数来管理表单数据的问题。使用方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(key, val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      [key]: val</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=<span class=\"string\">\"text\"</span></span><br><span class=\"line\">          value=&#123;<span class=\"keyword\">this</span>.props.state.user&#125;</span><br><span class=\"line\">          onChange=&#123;(e) =&gt; <span class=\"keyword\">this</span>.props.handleChange(<span class=\"string\">'user'</span>, e.target.value)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=<span class=\"string\">\"password\"</span></span><br><span class=\"line\">          value=&#123;<span class=\"keyword\">this</span>.props.state.psw&#125;</span><br><span class=\"line\">          onChange=&#123;(e) =&gt; <span class=\"keyword\">this</span>.props.handleChange(<span class=\"string\">'psw'</span>, e.target.value)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Form(Login);</span></span><br></pre></td></tr></table></figure>\n<p>这样，对于需要在很多地方使用表单的组件，可以提供组件复用度，减少样板代码。</p>\n<blockquote>\n<p>参考：<a href=\"https://react.bootcss.com/\" target=\"_blank\" rel=\"noopener\">https://react.bootcss.com/</a></p>\n</blockquote>"},{"title":"自定义Hook在React中的实践","date":"2020-08-03T13:59:14.000Z","_content":"\n> Hook 是 React 16.8 的新增特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。\n\n![image](http://img.yanyuanfe.cn/hooks.png)\n\n<!--more-->\n\n通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。\n\n### Hook介绍\nReact 16.8 新增 Hook特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。\n\n通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。\n\n### 实践自定义Hook\n\n曾经使用React的Class组件的时候，我遇到这样一个问题：在一个前端分页的表格展示页面中，分页数据没有同步到URL上，当刷新页面或者进入详情页再后退的时候，前一个分页的数据丢失，会导致展示为第一页的数据，用户体验很不好。\n\n在hook还未出现的时候，这个问题解决起来是很繁琐的，思路大概是监听Table的onChange事件，获取分页参数和筛选参数，然后调用history.replace同步到URL，解决方法其实很简单，但是无法复用，每个组件中都会充斥大量与业务无关的代码。\n\n直到Hooks的出现。当时看到umi开源了umi-hooks,于是提交了一个issue,看会不会有官方的自定义hook实现:\n\nhttps://github.com/alibaba/hooks/issues/232\n\n过了一段时间，随着对hook了解的深入，突然有了使用hook来实现的思路，大致代码如下：\n\n``` js\n// useQuery.js\nimport { useEffect, useState } from \"react\";\nimport { useHistory } from \"react-router-dom\";\nimport qs from \"qs\";\n\nexport const useQuery = (initQuery = {}) => {\n  const history = useHistory();\n  const url = history.location.search;\n  const params = qs.parse(url.split(\"?\")[1]);\n  const [query, setQuery] = useState({\n    offset: 0,\n    ...initQuery,\n    ...params\n  });\n  \n  useEffect(() => {\n    history.replace(`?${qs.stringify(query)}`);\n  }, [query]);\n\n  return [query, setQuery];\n};\n```\n使用：\n\n``` js\nimport React, { useEffect, useState } from \"react\";\nimport { Layout, Button, Table, Input } from \"antd\";\nimport \"./index.less\";\nimport { doctorService } from \"../../services/doctor.service\";\nimport { useQuery } from \"../../common/useQuery\";\n\nconst { Search } = Input;\n\nconst DoctorList = () => {\n  const [doctorList, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [query, setQuery] = useQuery({\n    search: \"\"\n  });\n\n  const columns = [\n    {\n      title: \"编号\",\n      dataIndex: \"doctor_id\",\n      key: \"id\",\n      defaultSortOrder: \"descend\",\n      sorter: (a, b) => a.doctor_id - b.doctor_id\n    },\n    {\n      title: \"姓名\",\n      dataIndex: \"name\",\n      key: \"name\"\n    },\n    {\n      title: \"医院\",\n      dataIndex: \"hospital\",\n      key: \"hospital\"\n    },\n    {\n      title: \"地区\",\n      dataIndex: \"zone\",\n      key: \"zone\"\n    },\n    {\n      title: \"销售\",\n      dataIndex: \"sales\",\n      key: \"sales\"\n    },\n    {\n      title: \"操作\",\n      dataIndex: \"action\",\n      key: \"action\",\n      render: (_, record) => {\n        return (\n          <Button href={`#/doctor/${record.guid}${record.doctor_id}/patient`} type=\"primary\">\n            查看患者\n          </Button>\n        );\n      }\n    }\n  ];\n\n  useEffect(() => {\n    setLoading(true);\n    doctorService.getDoctorList({ company_id: 1 }).then(res => {\n      setData(res ? res.doctor : []);\n      setLoading(false);\n    });\n  }, []);\n\n  return (\n    <Layout>\n      <div className=\"search\">\n        <Search\n          defaultValue={query.search}\n          placeholder=\"输入名字或者医院搜索\"\n          onSearch={val => {\n            setQuery({\n              ...query,\n              search: val\n            });\n          }}\n          style={{ width: 200 }}\n        />\n        <Button href=\"#/doctor/add\" type=\"primary\">\n          添加医生\n        </Button>\n      </div>\n      <Table\n        loading={loading}\n        dataSource={\n          query.search\n            ? doctorList.filter(\n                item => new RegExp(query.search).test(item.name) || new RegExp(query.search).test(item.hospital)\n              )\n            : doctorList\n        }\n        columns={columns}\n        rowKey=\"doctor_id\"\n        pagination={{ defaultPageSize: 20, current: Number(query.offset) }}\n        onChange={(pagination, filters, sorter) => {\n          setQuery({ ...query, offset: pagination.current });\n        }}\n      />\n    </Layout>\n  );\n};\n\nexport default DoctorList;\n\n```\n从上面可以看到，useQuery的代码还是很简单的，useQuery接收一个对象作为初始状态，并使用useState进行内部状态的保存，useQuery的返回值中setQuery可以对query状态进行修改，query的变化通过useEffect进行监听，每次有query变化都使用history.replace同步到URL上，这样当页面进行切换的时候，下一个页面使用history.goBack()回退的时候，上一个页面重新渲染，useQuery重新初始化，初始化的时候从URL上获取query参数，对query state进行初始化，外部的组件也能获取到新的query，从而可以进行搜索或者根据分页开始相应的渲染。\n\n### 高阶组件的实现\n\n使用Hook实现后，我发现在Class组件中，使用高阶组件也能实现这种功能，下面是一个简单的实现：\n\n```\nimport { React } from \"react\";\nimport qs from \"qs\";\n\nexport const withQuery = (initQuery = {}) = (Comp) => {\n  constructor(props) {\n    const url = props.history.location.search;\n    const params = qs.parse(url.split(\"?\")[1]);\n    this.state = {\n      offset: 0,\n      ...initQuery,\n      ...params\n    }\n  }\n  changeQuery = (query) => {\n    this.setState({\n      ...query,\n    }, () => {\n      this.history.replace(`?${qs.stringify(query)}`);\n    })\n  }\n  render() {\n      const {query} = this.state;\n      return <Comp {...this.props} query={query} setQuery={this.changeQuery} />\n  }\n}\n\n```\n下面是withQuery的使用，省略部分代码：\n\n```\nclass List extends React.Component {\n  render() {\n    const {query, setQuery} = this.props;\n    return (\n      <Layout>\n      <div className=\"search\">\n        <Search\n          defaultValue={query.search}\n          placeholder=\"输入名字或者医院搜索\"\n          onSearch={val => {\n            setQuery({\n              ...query,\n              search: val\n            });\n          }}\n          style={{ width: 200 }}\n        />\n        <Button href=\"#/doctor/add\" type=\"primary\">\n          添加医生\n        </Button>\n      </div>\n      <Table\n        loading={loading}\n        dataSource={\n          query.search\n            ? doctorList.filter(\n                item => new RegExp(query.search).test(item.name) || new RegExp(query.search).test(item.hospital)\n              )\n            : doctorList\n        }\n        columns={columns}\n        rowKey=\"doctor_id\"\n        pagination={{ defaultPageSize: 20, current: Number(query.offset) }}\n        onChange={(pagination, filters, sorter) => {\n          setQuery({ ...query, offset: pagination.current });\n        }}\n      />\n    </Layout>\n    )\n  }\n}\n\nexport default withQuery({search: \"\"})(List);\n```\n对比自定义Hook和高阶组件的实现：\n\n- 自定义Hook和高阶组件都可以实现逻辑复用\n- 两者都可以在内部读取props，保存自己的state，执行相应的生命周期，核心原理都是闭包。\n- 自定义hook的使用更加直观，高阶组件需要对组件进行嵌套，存在组件重名，可读性不好的问题。\n- 高阶组件只能通过props或者context来接受外部数据，而自定义hook可以props或者其他自定义hook来接受外部输入数据，数据来源更加清晰。\n\n### 总结\n\nHooks的出现给函数式组件带来了状态、生命周期的使用，通过自定义Hook，可以保存状态，读取props，执行相应的生命周期，可以对逻辑进行更细粒度的抽象，更好的复用逻辑。\n\n","source":"_posts/自定义Hook在React中的实践.md","raw":"---\ntitle: 自定义Hook在React中的实践\ndate: 2020-08-03 21:59:14\ntags:\n  - React\n  - hooks\n---\n\n> Hook 是 React 16.8 的新增特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。\n\n![image](http://img.yanyuanfe.cn/hooks.png)\n\n<!--more-->\n\n通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。\n\n### Hook介绍\nReact 16.8 新增 Hook特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。\n\n通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。\n\n### 实践自定义Hook\n\n曾经使用React的Class组件的时候，我遇到这样一个问题：在一个前端分页的表格展示页面中，分页数据没有同步到URL上，当刷新页面或者进入详情页再后退的时候，前一个分页的数据丢失，会导致展示为第一页的数据，用户体验很不好。\n\n在hook还未出现的时候，这个问题解决起来是很繁琐的，思路大概是监听Table的onChange事件，获取分页参数和筛选参数，然后调用history.replace同步到URL，解决方法其实很简单，但是无法复用，每个组件中都会充斥大量与业务无关的代码。\n\n直到Hooks的出现。当时看到umi开源了umi-hooks,于是提交了一个issue,看会不会有官方的自定义hook实现:\n\nhttps://github.com/alibaba/hooks/issues/232\n\n过了一段时间，随着对hook了解的深入，突然有了使用hook来实现的思路，大致代码如下：\n\n``` js\n// useQuery.js\nimport { useEffect, useState } from \"react\";\nimport { useHistory } from \"react-router-dom\";\nimport qs from \"qs\";\n\nexport const useQuery = (initQuery = {}) => {\n  const history = useHistory();\n  const url = history.location.search;\n  const params = qs.parse(url.split(\"?\")[1]);\n  const [query, setQuery] = useState({\n    offset: 0,\n    ...initQuery,\n    ...params\n  });\n  \n  useEffect(() => {\n    history.replace(`?${qs.stringify(query)}`);\n  }, [query]);\n\n  return [query, setQuery];\n};\n```\n使用：\n\n``` js\nimport React, { useEffect, useState } from \"react\";\nimport { Layout, Button, Table, Input } from \"antd\";\nimport \"./index.less\";\nimport { doctorService } from \"../../services/doctor.service\";\nimport { useQuery } from \"../../common/useQuery\";\n\nconst { Search } = Input;\n\nconst DoctorList = () => {\n  const [doctorList, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [query, setQuery] = useQuery({\n    search: \"\"\n  });\n\n  const columns = [\n    {\n      title: \"编号\",\n      dataIndex: \"doctor_id\",\n      key: \"id\",\n      defaultSortOrder: \"descend\",\n      sorter: (a, b) => a.doctor_id - b.doctor_id\n    },\n    {\n      title: \"姓名\",\n      dataIndex: \"name\",\n      key: \"name\"\n    },\n    {\n      title: \"医院\",\n      dataIndex: \"hospital\",\n      key: \"hospital\"\n    },\n    {\n      title: \"地区\",\n      dataIndex: \"zone\",\n      key: \"zone\"\n    },\n    {\n      title: \"销售\",\n      dataIndex: \"sales\",\n      key: \"sales\"\n    },\n    {\n      title: \"操作\",\n      dataIndex: \"action\",\n      key: \"action\",\n      render: (_, record) => {\n        return (\n          <Button href={`#/doctor/${record.guid}${record.doctor_id}/patient`} type=\"primary\">\n            查看患者\n          </Button>\n        );\n      }\n    }\n  ];\n\n  useEffect(() => {\n    setLoading(true);\n    doctorService.getDoctorList({ company_id: 1 }).then(res => {\n      setData(res ? res.doctor : []);\n      setLoading(false);\n    });\n  }, []);\n\n  return (\n    <Layout>\n      <div className=\"search\">\n        <Search\n          defaultValue={query.search}\n          placeholder=\"输入名字或者医院搜索\"\n          onSearch={val => {\n            setQuery({\n              ...query,\n              search: val\n            });\n          }}\n          style={{ width: 200 }}\n        />\n        <Button href=\"#/doctor/add\" type=\"primary\">\n          添加医生\n        </Button>\n      </div>\n      <Table\n        loading={loading}\n        dataSource={\n          query.search\n            ? doctorList.filter(\n                item => new RegExp(query.search).test(item.name) || new RegExp(query.search).test(item.hospital)\n              )\n            : doctorList\n        }\n        columns={columns}\n        rowKey=\"doctor_id\"\n        pagination={{ defaultPageSize: 20, current: Number(query.offset) }}\n        onChange={(pagination, filters, sorter) => {\n          setQuery({ ...query, offset: pagination.current });\n        }}\n      />\n    </Layout>\n  );\n};\n\nexport default DoctorList;\n\n```\n从上面可以看到，useQuery的代码还是很简单的，useQuery接收一个对象作为初始状态，并使用useState进行内部状态的保存，useQuery的返回值中setQuery可以对query状态进行修改，query的变化通过useEffect进行监听，每次有query变化都使用history.replace同步到URL上，这样当页面进行切换的时候，下一个页面使用history.goBack()回退的时候，上一个页面重新渲染，useQuery重新初始化，初始化的时候从URL上获取query参数，对query state进行初始化，外部的组件也能获取到新的query，从而可以进行搜索或者根据分页开始相应的渲染。\n\n### 高阶组件的实现\n\n使用Hook实现后，我发现在Class组件中，使用高阶组件也能实现这种功能，下面是一个简单的实现：\n\n```\nimport { React } from \"react\";\nimport qs from \"qs\";\n\nexport const withQuery = (initQuery = {}) = (Comp) => {\n  constructor(props) {\n    const url = props.history.location.search;\n    const params = qs.parse(url.split(\"?\")[1]);\n    this.state = {\n      offset: 0,\n      ...initQuery,\n      ...params\n    }\n  }\n  changeQuery = (query) => {\n    this.setState({\n      ...query,\n    }, () => {\n      this.history.replace(`?${qs.stringify(query)}`);\n    })\n  }\n  render() {\n      const {query} = this.state;\n      return <Comp {...this.props} query={query} setQuery={this.changeQuery} />\n  }\n}\n\n```\n下面是withQuery的使用，省略部分代码：\n\n```\nclass List extends React.Component {\n  render() {\n    const {query, setQuery} = this.props;\n    return (\n      <Layout>\n      <div className=\"search\">\n        <Search\n          defaultValue={query.search}\n          placeholder=\"输入名字或者医院搜索\"\n          onSearch={val => {\n            setQuery({\n              ...query,\n              search: val\n            });\n          }}\n          style={{ width: 200 }}\n        />\n        <Button href=\"#/doctor/add\" type=\"primary\">\n          添加医生\n        </Button>\n      </div>\n      <Table\n        loading={loading}\n        dataSource={\n          query.search\n            ? doctorList.filter(\n                item => new RegExp(query.search).test(item.name) || new RegExp(query.search).test(item.hospital)\n              )\n            : doctorList\n        }\n        columns={columns}\n        rowKey=\"doctor_id\"\n        pagination={{ defaultPageSize: 20, current: Number(query.offset) }}\n        onChange={(pagination, filters, sorter) => {\n          setQuery({ ...query, offset: pagination.current });\n        }}\n      />\n    </Layout>\n    )\n  }\n}\n\nexport default withQuery({search: \"\"})(List);\n```\n对比自定义Hook和高阶组件的实现：\n\n- 自定义Hook和高阶组件都可以实现逻辑复用\n- 两者都可以在内部读取props，保存自己的state，执行相应的生命周期，核心原理都是闭包。\n- 自定义hook的使用更加直观，高阶组件需要对组件进行嵌套，存在组件重名，可读性不好的问题。\n- 高阶组件只能通过props或者context来接受外部数据，而自定义hook可以props或者其他自定义hook来接受外部输入数据，数据来源更加清晰。\n\n### 总结\n\nHooks的出现给函数式组件带来了状态、生命周期的使用，通过自定义Hook，可以保存状态，读取props，执行相应的生命周期，可以对逻辑进行更细粒度的抽象，更好的复用逻辑。\n\n","slug":"自定义Hook在React中的实践","published":1,"updated":"2020-09-29T14:10:30.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenom002vp70vvxduvdqt","content":"<blockquote>\n<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/hooks.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。</p>\n<h3 id=\"Hook介绍\"><a href=\"#Hook介绍\" class=\"headerlink\" title=\"Hook介绍\"></a>Hook介绍</h3><p>React 16.8 新增 Hook特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。</p>\n<p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。</p>\n<h3 id=\"实践自定义Hook\"><a href=\"#实践自定义Hook\" class=\"headerlink\" title=\"实践自定义Hook\"></a>实践自定义Hook</h3><p>曾经使用React的Class组件的时候，我遇到这样一个问题：在一个前端分页的表格展示页面中，分页数据没有同步到URL上，当刷新页面或者进入详情页再后退的时候，前一个分页的数据丢失，会导致展示为第一页的数据，用户体验很不好。</p>\n<p>在hook还未出现的时候，这个问题解决起来是很繁琐的，思路大概是监听Table的onChange事件，获取分页参数和筛选参数，然后调用history.replace同步到URL，解决方法其实很简单，但是无法复用，每个组件中都会充斥大量与业务无关的代码。</p>\n<p>直到Hooks的出现。当时看到umi开源了umi-hooks,于是提交了一个issue,看会不会有官方的自定义hook实现:</p>\n<p><a href=\"https://github.com/alibaba/hooks/issues/232\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/hooks/issues/232</a></p>\n<p>过了一段时间，随着对hook了解的深入，突然有了使用hook来实现的思路，大致代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// useQuery.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-dom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> qs <span class=\"keyword\">from</span> <span class=\"string\">\"qs\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useQuery = <span class=\"function\">(<span class=\"params\">initQuery = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> history = useHistory();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = history.location.search;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = qs.parse(url.split(<span class=\"string\">\"?\"</span>)[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(&#123;</span><br><span class=\"line\">    offset: <span class=\"number\">0</span>,</span><br><span class=\"line\">    ...initQuery,</span><br><span class=\"line\">    ...params</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    history.replace(<span class=\"string\">`?<span class=\"subst\">$&#123;qs.stringify(query)&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;, [query]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [query, setQuery];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useEffect, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Layout, Button, Table, Input &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"antd\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"./index.less\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; doctorService &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"../../services/doctor.service\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useQuery &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"../../common/useQuery\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Search &#125; = Input;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> DoctorList = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [doctorList, setData] = useState([]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [loading, setLoading] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useQuery(&#123;</span><br><span class=\"line\">    search: <span class=\"string\">\"\"</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> columns = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"编号\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"doctor_id\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"id\"</span>,</span><br><span class=\"line\">      defaultSortOrder: <span class=\"string\">\"descend\"</span>,</span><br><span class=\"line\">      sorter: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.doctor_id - b.doctor_id</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"姓名\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"name\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"name\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"医院\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"hospital\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"hospital\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"地区\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"zone\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"zone\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"销售\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"sales\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"sales\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"操作\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"action\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"action\"</span>,</span><br><span class=\"line\">      render: <span class=\"function\">(<span class=\"params\">_, record</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;Button href=&#123;<span class=\"string\">`#/doctor/<span class=\"subst\">$&#123;record.guid&#125;</span><span class=\"subst\">$&#123;record.doctor_id&#125;</span>/patient`</span>&#125; type=<span class=\"string\">\"primary\"</span>&gt;</span><br><span class=\"line\">            查看患者</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  ];</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  useEffect(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    setLoading(true);</span></span><br><span class=\"line\"><span class=\"regexp\">    doctorService.getDoctorList(&#123; company_id: 1 &#125;).then(res =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      setData(res ? res.doctor : []);</span></span><br><span class=\"line\"><span class=\"regexp\">      setLoading(false);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;, []);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Layout&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"search\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Search</span></span><br><span class=\"line\"><span class=\"regexp\">          defaultValue=&#123;query.search&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          placeholder=\"输入名字或者医院搜索\"</span></span><br><span class=\"line\"><span class=\"regexp\">          onSearch=&#123;val =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            setQuery(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">              ...query,</span></span><br><span class=\"line\"><span class=\"regexp\">              search: val</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          style=&#123;&#123; width: 200 &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        /</span>&gt;</span><br><span class=\"line\">        &lt;Button href=<span class=\"string\">\"#/doctor/add\"</span> type=<span class=\"string\">\"primary\"</span>&gt;</span><br><span class=\"line\">          添加医生</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;Table</span><br><span class=\"line\">        loading=&#123;loading&#125;</span><br><span class=\"line\">        dataSource=&#123;</span><br><span class=\"line\">          query.search</span><br><span class=\"line\">            ? doctorList.filter(</span><br><span class=\"line\">                item =&gt; <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(query.search).test(item.name) || <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(query.search).test(item.hospital)</span><br><span class=\"line\">              )</span><br><span class=\"line\">            : doctorList</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        columns=&#123;columns&#125;</span><br><span class=\"line\">        rowKey=<span class=\"string\">\"doctor_id\"</span></span><br><span class=\"line\">        pagination=&#123;&#123; <span class=\"attr\">defaultPageSize</span>: <span class=\"number\">20</span>, <span class=\"attr\">current</span>: <span class=\"built_in\">Number</span>(query.offset) &#125;&#125;</span><br><span class=\"line\">        onChange=&#123;(pagination, filters, sorter) =&gt; &#123;</span><br><span class=\"line\">          setQuery(&#123; ...query, <span class=\"attr\">offset</span>: pagination.current &#125;);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Layout&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default DoctorList;</span></span><br></pre></td></tr></table></figure>\n<p>从上面可以看到，useQuery的代码还是很简单的，useQuery接收一个对象作为初始状态，并使用useState进行内部状态的保存，useQuery的返回值中setQuery可以对query状态进行修改，query的变化通过useEffect进行监听，每次有query变化都使用history.replace同步到URL上，这样当页面进行切换的时候，下一个页面使用history.goBack()回退的时候，上一个页面重新渲染，useQuery重新初始化，初始化的时候从URL上获取query参数，对query state进行初始化，外部的组件也能获取到新的query，从而可以进行搜索或者根据分页开始相应的渲染。</p>\n<h3 id=\"高阶组件的实现\"><a href=\"#高阶组件的实现\" class=\"headerlink\" title=\"高阶组件的实现\"></a>高阶组件的实现</h3><p>使用Hook实现后，我发现在Class组件中，使用高阶组件也能实现这种功能，下面是一个简单的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; React &#125; from &quot;react&quot;;</span><br><span class=\"line\">import qs from &quot;qs&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const withQuery = (initQuery = &#123;&#125;) = (Comp) =&gt; &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    const url = props.history.location.search;</span><br><span class=\"line\">    const params = qs.parse(url.split(&quot;?&quot;)[1]);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      offset: 0,</span><br><span class=\"line\">      ...initQuery,</span><br><span class=\"line\">      ...params</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeQuery = (query) =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      ...query,</span><br><span class=\"line\">    &#125;, () =&gt; &#123;</span><br><span class=\"line\">      this.history.replace(`?$&#123;qs.stringify(query)&#125;`);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      const &#123;query&#125; = this.state;</span><br><span class=\"line\">      return &lt;Comp &#123;...this.props&#125; query=&#123;query&#125; setQuery=&#123;this.changeQuery&#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是withQuery的使用，省略部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class List extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;query, setQuery&#125; = this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Layout&gt;</span><br><span class=\"line\">      &lt;div className=&quot;search&quot;&gt;</span><br><span class=\"line\">        &lt;Search</span><br><span class=\"line\">          defaultValue=&#123;query.search&#125;</span><br><span class=\"line\">          placeholder=&quot;输入名字或者医院搜索&quot;</span><br><span class=\"line\">          onSearch=&#123;val =&gt; &#123;</span><br><span class=\"line\">            setQuery(&#123;</span><br><span class=\"line\">              ...query,</span><br><span class=\"line\">              search: val</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;&#125;</span><br><span class=\"line\">          style=&#123;&#123; width: 200 &#125;&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;Button href=&quot;#/doctor/add&quot; type=&quot;primary&quot;&gt;</span><br><span class=\"line\">          添加医生</span><br><span class=\"line\">        &lt;/Button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;Table</span><br><span class=\"line\">        loading=&#123;loading&#125;</span><br><span class=\"line\">        dataSource=&#123;</span><br><span class=\"line\">          query.search</span><br><span class=\"line\">            ? doctorList.filter(</span><br><span class=\"line\">                item =&gt; new RegExp(query.search).test(item.name) || new RegExp(query.search).test(item.hospital)</span><br><span class=\"line\">              )</span><br><span class=\"line\">            : doctorList</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        columns=&#123;columns&#125;</span><br><span class=\"line\">        rowKey=&quot;doctor_id&quot;</span><br><span class=\"line\">        pagination=&#123;&#123; defaultPageSize: 20, current: Number(query.offset) &#125;&#125;</span><br><span class=\"line\">        onChange=&#123;(pagination, filters, sorter) =&gt; &#123;</span><br><span class=\"line\">          setQuery(&#123; ...query, offset: pagination.current &#125;);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;/Layout&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default withQuery(&#123;search: &quot;&quot;&#125;)(List);</span><br></pre></td></tr></table></figure>\n<p>对比自定义Hook和高阶组件的实现：</p>\n<ul>\n<li>自定义Hook和高阶组件都可以实现逻辑复用</li>\n<li>两者都可以在内部读取props，保存自己的state，执行相应的生命周期，核心原理都是闭包。</li>\n<li>自定义hook的使用更加直观，高阶组件需要对组件进行嵌套，存在组件重名，可读性不好的问题。</li>\n<li>高阶组件只能通过props或者context来接受外部数据，而自定义hook可以props或者其他自定义hook来接受外部输入数据，数据来源更加清晰。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Hooks的出现给函数式组件带来了状态、生命周期的使用，通过自定义Hook，可以保存状态，读取props，执行相应的生命周期，可以对逻辑进行更细粒度的抽象，更好的复用逻辑。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/hooks.png\" alt=\"image\"></p>","more":"<p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。</p>\n<h3 id=\"Hook介绍\"><a href=\"#Hook介绍\" class=\"headerlink\" title=\"Hook介绍\"></a>Hook介绍</h3><p>React 16.8 新增 Hook特性。它可以让你在不编写 Class 的情况下使用 state 以及其他的 React 特性。</p>\n<p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。</p>\n<h3 id=\"实践自定义Hook\"><a href=\"#实践自定义Hook\" class=\"headerlink\" title=\"实践自定义Hook\"></a>实践自定义Hook</h3><p>曾经使用React的Class组件的时候，我遇到这样一个问题：在一个前端分页的表格展示页面中，分页数据没有同步到URL上，当刷新页面或者进入详情页再后退的时候，前一个分页的数据丢失，会导致展示为第一页的数据，用户体验很不好。</p>\n<p>在hook还未出现的时候，这个问题解决起来是很繁琐的，思路大概是监听Table的onChange事件，获取分页参数和筛选参数，然后调用history.replace同步到URL，解决方法其实很简单，但是无法复用，每个组件中都会充斥大量与业务无关的代码。</p>\n<p>直到Hooks的出现。当时看到umi开源了umi-hooks,于是提交了一个issue,看会不会有官方的自定义hook实现:</p>\n<p><a href=\"https://github.com/alibaba/hooks/issues/232\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/hooks/issues/232</a></p>\n<p>过了一段时间，随着对hook了解的深入，突然有了使用hook来实现的思路，大致代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// useQuery.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-dom\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> qs <span class=\"keyword\">from</span> <span class=\"string\">\"qs\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useQuery = <span class=\"function\">(<span class=\"params\">initQuery = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> history = useHistory();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = history.location.search;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = qs.parse(url.split(<span class=\"string\">\"?\"</span>)[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(&#123;</span><br><span class=\"line\">    offset: <span class=\"number\">0</span>,</span><br><span class=\"line\">    ...initQuery,</span><br><span class=\"line\">    ...params</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    history.replace(<span class=\"string\">`?<span class=\"subst\">$&#123;qs.stringify(query)&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;, [query]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [query, setQuery];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useEffect, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Layout, Button, Table, Input &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"antd\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"./index.less\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; doctorService &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"../../services/doctor.service\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useQuery &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"../../common/useQuery\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Search &#125; = Input;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> DoctorList = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [doctorList, setData] = useState([]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [loading, setLoading] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useQuery(&#123;</span><br><span class=\"line\">    search: <span class=\"string\">\"\"</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> columns = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"编号\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"doctor_id\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"id\"</span>,</span><br><span class=\"line\">      defaultSortOrder: <span class=\"string\">\"descend\"</span>,</span><br><span class=\"line\">      sorter: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.doctor_id - b.doctor_id</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"姓名\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"name\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"name\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"医院\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"hospital\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"hospital\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"地区\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"zone\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"zone\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"销售\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"sales\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"sales\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      title: <span class=\"string\">\"操作\"</span>,</span><br><span class=\"line\">      dataIndex: <span class=\"string\">\"action\"</span>,</span><br><span class=\"line\">      key: <span class=\"string\">\"action\"</span>,</span><br><span class=\"line\">      render: <span class=\"function\">(<span class=\"params\">_, record</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;Button href=&#123;<span class=\"string\">`#/doctor/<span class=\"subst\">$&#123;record.guid&#125;</span><span class=\"subst\">$&#123;record.doctor_id&#125;</span>/patient`</span>&#125; type=<span class=\"string\">\"primary\"</span>&gt;</span><br><span class=\"line\">            查看患者</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  ];</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  useEffect(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    setLoading(true);</span></span><br><span class=\"line\"><span class=\"regexp\">    doctorService.getDoctorList(&#123; company_id: 1 &#125;).then(res =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      setData(res ? res.doctor : []);</span></span><br><span class=\"line\"><span class=\"regexp\">      setLoading(false);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;, []);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Layout&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"search\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Search</span></span><br><span class=\"line\"><span class=\"regexp\">          defaultValue=&#123;query.search&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          placeholder=\"输入名字或者医院搜索\"</span></span><br><span class=\"line\"><span class=\"regexp\">          onSearch=&#123;val =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            setQuery(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">              ...query,</span></span><br><span class=\"line\"><span class=\"regexp\">              search: val</span></span><br><span class=\"line\"><span class=\"regexp\">            &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          style=&#123;&#123; width: 200 &#125;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        /</span>&gt;</span><br><span class=\"line\">        &lt;Button href=<span class=\"string\">\"#/doctor/add\"</span> type=<span class=\"string\">\"primary\"</span>&gt;</span><br><span class=\"line\">          添加医生</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;Table</span><br><span class=\"line\">        loading=&#123;loading&#125;</span><br><span class=\"line\">        dataSource=&#123;</span><br><span class=\"line\">          query.search</span><br><span class=\"line\">            ? doctorList.filter(</span><br><span class=\"line\">                item =&gt; <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(query.search).test(item.name) || <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(query.search).test(item.hospital)</span><br><span class=\"line\">              )</span><br><span class=\"line\">            : doctorList</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        columns=&#123;columns&#125;</span><br><span class=\"line\">        rowKey=<span class=\"string\">\"doctor_id\"</span></span><br><span class=\"line\">        pagination=&#123;&#123; <span class=\"attr\">defaultPageSize</span>: <span class=\"number\">20</span>, <span class=\"attr\">current</span>: <span class=\"built_in\">Number</span>(query.offset) &#125;&#125;</span><br><span class=\"line\">        onChange=&#123;(pagination, filters, sorter) =&gt; &#123;</span><br><span class=\"line\">          setQuery(&#123; ...query, <span class=\"attr\">offset</span>: pagination.current &#125;);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Layout&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default DoctorList;</span></span><br></pre></td></tr></table></figure>\n<p>从上面可以看到，useQuery的代码还是很简单的，useQuery接收一个对象作为初始状态，并使用useState进行内部状态的保存，useQuery的返回值中setQuery可以对query状态进行修改，query的变化通过useEffect进行监听，每次有query变化都使用history.replace同步到URL上，这样当页面进行切换的时候，下一个页面使用history.goBack()回退的时候，上一个页面重新渲染，useQuery重新初始化，初始化的时候从URL上获取query参数，对query state进行初始化，外部的组件也能获取到新的query，从而可以进行搜索或者根据分页开始相应的渲染。</p>\n<h3 id=\"高阶组件的实现\"><a href=\"#高阶组件的实现\" class=\"headerlink\" title=\"高阶组件的实现\"></a>高阶组件的实现</h3><p>使用Hook实现后，我发现在Class组件中，使用高阶组件也能实现这种功能，下面是一个简单的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; React &#125; from &quot;react&quot;;</span><br><span class=\"line\">import qs from &quot;qs&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const withQuery = (initQuery = &#123;&#125;) = (Comp) =&gt; &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    const url = props.history.location.search;</span><br><span class=\"line\">    const params = qs.parse(url.split(&quot;?&quot;)[1]);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      offset: 0,</span><br><span class=\"line\">      ...initQuery,</span><br><span class=\"line\">      ...params</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  changeQuery = (query) =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      ...query,</span><br><span class=\"line\">    &#125;, () =&gt; &#123;</span><br><span class=\"line\">      this.history.replace(`?$&#123;qs.stringify(query)&#125;`);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">      const &#123;query&#125; = this.state;</span><br><span class=\"line\">      return &lt;Comp &#123;...this.props&#125; query=&#123;query&#125; setQuery=&#123;this.changeQuery&#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是withQuery的使用，省略部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class List extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123;query, setQuery&#125; = this.props;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;Layout&gt;</span><br><span class=\"line\">      &lt;div className=&quot;search&quot;&gt;</span><br><span class=\"line\">        &lt;Search</span><br><span class=\"line\">          defaultValue=&#123;query.search&#125;</span><br><span class=\"line\">          placeholder=&quot;输入名字或者医院搜索&quot;</span><br><span class=\"line\">          onSearch=&#123;val =&gt; &#123;</span><br><span class=\"line\">            setQuery(&#123;</span><br><span class=\"line\">              ...query,</span><br><span class=\"line\">              search: val</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;&#125;</span><br><span class=\"line\">          style=&#123;&#123; width: 200 &#125;&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;Button href=&quot;#/doctor/add&quot; type=&quot;primary&quot;&gt;</span><br><span class=\"line\">          添加医生</span><br><span class=\"line\">        &lt;/Button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;Table</span><br><span class=\"line\">        loading=&#123;loading&#125;</span><br><span class=\"line\">        dataSource=&#123;</span><br><span class=\"line\">          query.search</span><br><span class=\"line\">            ? doctorList.filter(</span><br><span class=\"line\">                item =&gt; new RegExp(query.search).test(item.name) || new RegExp(query.search).test(item.hospital)</span><br><span class=\"line\">              )</span><br><span class=\"line\">            : doctorList</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        columns=&#123;columns&#125;</span><br><span class=\"line\">        rowKey=&quot;doctor_id&quot;</span><br><span class=\"line\">        pagination=&#123;&#123; defaultPageSize: 20, current: Number(query.offset) &#125;&#125;</span><br><span class=\"line\">        onChange=&#123;(pagination, filters, sorter) =&gt; &#123;</span><br><span class=\"line\">          setQuery(&#123; ...query, offset: pagination.current &#125;);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;/Layout&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default withQuery(&#123;search: &quot;&quot;&#125;)(List);</span><br></pre></td></tr></table></figure>\n<p>对比自定义Hook和高阶组件的实现：</p>\n<ul>\n<li>自定义Hook和高阶组件都可以实现逻辑复用</li>\n<li>两者都可以在内部读取props，保存自己的state，执行相应的生命周期，核心原理都是闭包。</li>\n<li>自定义hook的使用更加直观，高阶组件需要对组件进行嵌套，存在组件重名，可读性不好的问题。</li>\n<li>高阶组件只能通过props或者context来接受外部数据，而自定义hook可以props或者其他自定义hook来接受外部输入数据，数据来源更加清晰。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Hooks的出现给函数式组件带来了状态、生命周期的使用，通过自定义Hook，可以保存状态，读取props，执行相应的生命周期，可以对逻辑进行更细粒度的抽象，更好的复用逻辑。</p>"},{"title":"聊聊Vue组件通信方式","date":"2020-07-09T14:07:47.000Z","_content":"\n> 组件是现代前端框架最强大的功能，但是组件的作用域是相互独立的，那么不同组件之间如何传递数据呢？\n\n![image](http://img.yanyuanfe.cn/vue.png)\n\n<!--more-->\n\n为了构建大型Web应用，现代前端框架都引入了组件系统，将模版和逻辑抽象为可复用的组件，可以提高项目的开发效率和可维护性。而组件间的通信一直是一个老生常谈的问题，今天来讨论一下Vue中的组件通信。\n\n### props\n通过props可以实现父组件向子组件传递数据，prop是定义在组件上的一些自定义属性，需要提前在子组件中的props声明。\n\n``` vue\n// 子组件\n<template>\n    <div>{{text}}</div>\n</template>\n\n<script>\n    export default {\n        name: 'Confirm',\n        props: {\n            text: {\n                type: String,\n                default: ''\n            },\n        }\n    }\n</script>\n```\n\n``` vue\n// 父组件\n<template>\n    <confirm :text=\"文字\">\n</template>\n```\n\n### 自定义事件\n\n通过自定义事件的方式可以在子组件中向父组件传递数据。\n\n``` vue\n// 子组件\n<template>\n    <button @click=\"confirm\">Click</button>\n</template>\n\n<script>\n    export default {\n        name: 'Confirm',\n        methods: {\n            confirm() {\n              this.$emit('confirm',\"data\")\n            }\n        }\n    }\n</script>\n```\n\n``` vue\n// 父组件\n<template>\n    <confirm @confirm=\"handleConfirm\">\n</template>\n\n<script>\n    export default {\n        methods: {\n            confirm(data) {\n              console.log(data);\n            }\n        }\n    }\n</script>\n```\n子组件使用this.$emit可以触发自定义事件，第一个参数是自定义事件名称，第二个参数为传递的参数（可选）。父组件使用@监听子组件的自定义事件。\n\n### 事件总线\nprops只适用于父子组件之间数据的传递，兄弟组件之间的通信可以使用eventBus的方式，具体使用方式如下：\n\n新建eventBus.js:\n\n\n``` vue\nimport Vue from 'vue';  \nexport default new Vue(); \n```\n\n触发事件的组件：\n\n\n``` vue\nimport eventBus from './eventBus.js'; \n\nmethods: {  \n   onClick(event) {  \n       eventBus.$emit('clickEvent', event.target);   \n   }  \n}  \n```\n\n监听事件的组件：\n\n``` vue\nimport eventBus from './eventBus.js'; \n\nmethods: {  \n   onClick(event) {  \n       eventBus.$on('clickEvent', (data) => {\n           console.log(data);\n       });   \n   }  \n}  \n```\n\neventBus的方法实现了一个全局的状态管理，在任意组件之间都能非常便捷的传递数据。\n\n### Vuex\n\n在大型Web应用中，上述组件通信方式已经不能很好的满足实际的需求，Vue官网提供了一个全局状态管理库：Vuex。具体可参考官方文档。\n\n### $root和$parent\n\n在每个 new Vue 实例的子组件中，其根实例可以通过 $root property 进行访问。\n所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。\n和 $root 类似，$parent 可以用来从一个子组件访问父组件的实例。因此可以利用$root或者$root作为桥梁在子组件之间传递数据。\n\n触发事件的组件：\n\n\n``` vue\nmethods: {  \n   onClick(event) {  \n       this.$root.$emit('clickEvent', event.target);   \n   }  \n}  \n```\n\n监听事件的组件：\n\n``` vue\nmethods: {  \n   onClick(event) {  \n       this.$root.$on('clickEvent', (data) => {\n           console.log(data);\n       });   \n   }  \n}  \n```\n\n### $children\n\n父组件也可以使用$children来访问子组件实现父子组件的通信。\n\nthis.$children是当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。\n\n> 慎重使用 $parent 和 $children，它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信。\n\n``` vue\n//父组件\n\nthis.$children[0].xx = xx;\n```\n\n### $refs\n$refs可以创建一个子元素或者子组件的引用，使用$refs可以很方便的调用子组件的方法或者获取子组件的数据。\n\n``` vue\n// 父组件\n<template>\n   <base-input ref=\"usernameInput\"></base-input>\n</template>\n\n<script>\n    export default {\n        methods: {\n            focus() {\n              this.$refs.usernameInput.focus();\n            }\n        }\n    }\n</script>\n```\n\n``` vue\n// 子组件\n<template>\n   <input ref=\"input\">\n</template>\n\n<script>\n    export default {\n        methods: {\n            focus: function () {\n                this.$refs.input.focus()\n          }\n        }\n    }\n</script>\n```\n### $attrs和$listeners\n\n$attrs中包含了父组件传入子组件，且未在子组件props中定义的属性（class和style除外），$attrs会被自动添加到子组件的根元素上，如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。\n\n\n``` vue\n//子组件\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      >\n    </label>\n  `\n})\n```\n\n\n``` vue\n//父组件\n\n<base-input\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n\n同理，$listeners可以将父组件传入的所有事件监听函数指向子组件的某个特定的子元素。\n\n\n``` vue\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  computed: {\n    inputListeners: function () {\n      var vm = this\n      return Object.assign({},\n        {\n          input: function (event) {\n            vm.$emit('input', event.target.value)\n          }\n        }\n      )\n    }\n  },\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on=\"inputListeners\"\n      >\n    </label>\n  `\n})\n```\n\n### provide/inject\n\nprovide和inject是Vue中依赖注入的实现，provide 选项允许我们指定我们想要提供给后代组件的数据/方法。\n\n\n``` vue\n// 提供数据的组件\n<script>\nexport default {\n  provide() {\n    return {\n      form: this\n    };\n  },\n}\n</script>\n```\n\n然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在组件上的属性：\n\n\n``` vue\n<script>\n\nexport default {\n  inject: [\"form\"],\n  methods: {\n    validate() {\n      console.log(this.form);\n    }\n}\n</script>\n```\n\nVue官方的状态管理库-Vuex的原理也是使用了provide/inject。\n\n### 总结\n\n上述就是Vue中的组件通信方案，不同的方案适用场景不同，没有银弹，在项目开发中，需要根据项目需求来选择适合的方案。\n\n\n\n","source":"_posts/聊聊Vue组件通信方式.md","raw":"---\ntitle: 聊聊Vue组件通信方式\ndate: 2020-07-09 22:07:47\ntags:\n  - Vue\n  - 组件\n---\n\n> 组件是现代前端框架最强大的功能，但是组件的作用域是相互独立的，那么不同组件之间如何传递数据呢？\n\n![image](http://img.yanyuanfe.cn/vue.png)\n\n<!--more-->\n\n为了构建大型Web应用，现代前端框架都引入了组件系统，将模版和逻辑抽象为可复用的组件，可以提高项目的开发效率和可维护性。而组件间的通信一直是一个老生常谈的问题，今天来讨论一下Vue中的组件通信。\n\n### props\n通过props可以实现父组件向子组件传递数据，prop是定义在组件上的一些自定义属性，需要提前在子组件中的props声明。\n\n``` vue\n// 子组件\n<template>\n    <div>{{text}}</div>\n</template>\n\n<script>\n    export default {\n        name: 'Confirm',\n        props: {\n            text: {\n                type: String,\n                default: ''\n            },\n        }\n    }\n</script>\n```\n\n``` vue\n// 父组件\n<template>\n    <confirm :text=\"文字\">\n</template>\n```\n\n### 自定义事件\n\n通过自定义事件的方式可以在子组件中向父组件传递数据。\n\n``` vue\n// 子组件\n<template>\n    <button @click=\"confirm\">Click</button>\n</template>\n\n<script>\n    export default {\n        name: 'Confirm',\n        methods: {\n            confirm() {\n              this.$emit('confirm',\"data\")\n            }\n        }\n    }\n</script>\n```\n\n``` vue\n// 父组件\n<template>\n    <confirm @confirm=\"handleConfirm\">\n</template>\n\n<script>\n    export default {\n        methods: {\n            confirm(data) {\n              console.log(data);\n            }\n        }\n    }\n</script>\n```\n子组件使用this.$emit可以触发自定义事件，第一个参数是自定义事件名称，第二个参数为传递的参数（可选）。父组件使用@监听子组件的自定义事件。\n\n### 事件总线\nprops只适用于父子组件之间数据的传递，兄弟组件之间的通信可以使用eventBus的方式，具体使用方式如下：\n\n新建eventBus.js:\n\n\n``` vue\nimport Vue from 'vue';  \nexport default new Vue(); \n```\n\n触发事件的组件：\n\n\n``` vue\nimport eventBus from './eventBus.js'; \n\nmethods: {  \n   onClick(event) {  \n       eventBus.$emit('clickEvent', event.target);   \n   }  \n}  \n```\n\n监听事件的组件：\n\n``` vue\nimport eventBus from './eventBus.js'; \n\nmethods: {  \n   onClick(event) {  \n       eventBus.$on('clickEvent', (data) => {\n           console.log(data);\n       });   \n   }  \n}  \n```\n\neventBus的方法实现了一个全局的状态管理，在任意组件之间都能非常便捷的传递数据。\n\n### Vuex\n\n在大型Web应用中，上述组件通信方式已经不能很好的满足实际的需求，Vue官网提供了一个全局状态管理库：Vuex。具体可参考官方文档。\n\n### $root和$parent\n\n在每个 new Vue 实例的子组件中，其根实例可以通过 $root property 进行访问。\n所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。\n和 $root 类似，$parent 可以用来从一个子组件访问父组件的实例。因此可以利用$root或者$root作为桥梁在子组件之间传递数据。\n\n触发事件的组件：\n\n\n``` vue\nmethods: {  \n   onClick(event) {  \n       this.$root.$emit('clickEvent', event.target);   \n   }  \n}  \n```\n\n监听事件的组件：\n\n``` vue\nmethods: {  \n   onClick(event) {  \n       this.$root.$on('clickEvent', (data) => {\n           console.log(data);\n       });   \n   }  \n}  \n```\n\n### $children\n\n父组件也可以使用$children来访问子组件实现父子组件的通信。\n\nthis.$children是当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。\n\n> 慎重使用 $parent 和 $children，它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信。\n\n``` vue\n//父组件\n\nthis.$children[0].xx = xx;\n```\n\n### $refs\n$refs可以创建一个子元素或者子组件的引用，使用$refs可以很方便的调用子组件的方法或者获取子组件的数据。\n\n``` vue\n// 父组件\n<template>\n   <base-input ref=\"usernameInput\"></base-input>\n</template>\n\n<script>\n    export default {\n        methods: {\n            focus() {\n              this.$refs.usernameInput.focus();\n            }\n        }\n    }\n</script>\n```\n\n``` vue\n// 子组件\n<template>\n   <input ref=\"input\">\n</template>\n\n<script>\n    export default {\n        methods: {\n            focus: function () {\n                this.$refs.input.focus()\n          }\n        }\n    }\n</script>\n```\n### $attrs和$listeners\n\n$attrs中包含了父组件传入子组件，且未在子组件props中定义的属性（class和style除外），$attrs会被自动添加到子组件的根元素上，如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。\n\n\n``` vue\n//子组件\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      >\n    </label>\n  `\n})\n```\n\n\n``` vue\n//父组件\n\n<base-input\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n\n同理，$listeners可以将父组件传入的所有事件监听函数指向子组件的某个特定的子元素。\n\n\n``` vue\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  computed: {\n    inputListeners: function () {\n      var vm = this\n      return Object.assign({},\n        {\n          input: function (event) {\n            vm.$emit('input', event.target.value)\n          }\n        }\n      )\n    }\n  },\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on=\"inputListeners\"\n      >\n    </label>\n  `\n})\n```\n\n### provide/inject\n\nprovide和inject是Vue中依赖注入的实现，provide 选项允许我们指定我们想要提供给后代组件的数据/方法。\n\n\n``` vue\n// 提供数据的组件\n<script>\nexport default {\n  provide() {\n    return {\n      form: this\n    };\n  },\n}\n</script>\n```\n\n然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在组件上的属性：\n\n\n``` vue\n<script>\n\nexport default {\n  inject: [\"form\"],\n  methods: {\n    validate() {\n      console.log(this.form);\n    }\n}\n</script>\n```\n\nVue官方的状态管理库-Vuex的原理也是使用了provide/inject。\n\n### 总结\n\n上述就是Vue中的组件通信方案，不同的方案适用场景不同，没有银弹，在项目开发中，需要根据项目需求来选择适合的方案。\n\n\n\n","slug":"聊聊Vue组件通信方式","published":1,"updated":"2020-07-16T14:17:25.997Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenon002xp70v3atbcfzj","content":"<blockquote>\n<p>组件是现代前端框架最强大的功能，但是组件的作用域是相互独立的，那么不同组件之间如何传递数据呢？</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/vue.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<p>为了构建大型Web应用，现代前端框架都引入了组件系统，将模版和逻辑抽象为可复用的组件，可以提高项目的开发效率和可维护性。而组件间的通信一直是一个老生常谈的问题，今天来讨论一下Vue中的组件通信。</p>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><p>通过props可以实现父组件向子组件传递数据，prop是定义在组件上的一些自定义属性，需要提前在子组件中的props声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        name: &apos;Confirm&apos;,</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            text: &#123;</span><br><span class=\"line\">                type: String,</span><br><span class=\"line\">                default: &apos;&apos;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;confirm :text=&quot;文字&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h3><p>通过自定义事件的方式可以在子组件中向父组件传递数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;confirm&quot;&gt;Click&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        name: &apos;Confirm&apos;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            confirm() &#123;</span><br><span class=\"line\">              this.$emit(&apos;confirm&apos;,&quot;data&quot;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;confirm @confirm=&quot;handleConfirm&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            confirm(data) &#123;</span><br><span class=\"line\">              console.log(data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>子组件使用this.$emit可以触发自定义事件，第一个参数是自定义事件名称，第二个参数为传递的参数（可选）。父组件使用@监听子组件的自定义事件。</p>\n<h3 id=\"事件总线\"><a href=\"#事件总线\" class=\"headerlink\" title=\"事件总线\"></a>事件总线</h3><p>props只适用于父子组件之间数据的传递，兄弟组件之间的通信可以使用eventBus的方式，具体使用方式如下：</p>\n<p>新建eventBus.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;;  </span><br><span class=\"line\">export default new Vue();</span><br></pre></td></tr></table></figure>\n<p>触发事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import eventBus from &apos;./eventBus.js&apos;; </span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       eventBus.$emit(&apos;clickEvent&apos;, event.target);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import eventBus from &apos;./eventBus.js&apos;; </span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       eventBus.$on(&apos;clickEvent&apos;, (data) =&gt; &#123;</span><br><span class=\"line\">           console.log(data);</span><br><span class=\"line\">       &#125;);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>eventBus的方法实现了一个全局的状态管理，在任意组件之间都能非常便捷的传递数据。</p>\n<h3 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h3><p>在大型Web应用中，上述组件通信方式已经不能很好的满足实际的需求，Vue官网提供了一个全局状态管理库：Vuex。具体可参考官方文档。</p>\n<h3 id=\"root和-parent\"><a href=\"#root和-parent\" class=\"headerlink\" title=\"$root和$parent\"></a>$root和$parent</h3><p>在每个 new Vue 实例的子组件中，其根实例可以通过 $root property 进行访问。<br>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。<br>和 $root 类似，$parent 可以用来从一个子组件访问父组件的实例。因此可以利用$root或者$root作为桥梁在子组件之间传递数据。</p>\n<p>触发事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       this.$root.$emit(&apos;clickEvent&apos;, event.target);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       this.$root.$on(&apos;clickEvent&apos;, (data) =&gt; &#123;</span><br><span class=\"line\">           console.log(data);</span><br><span class=\"line\">       &#125;);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"children\"><a href=\"#children\" class=\"headerlink\" title=\"$children\"></a>$children</h3><p>父组件也可以使用$children来访问子组件实现父子组件的通信。</p>\n<p>this.$children是当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。</p>\n<blockquote>\n<p>慎重使用 $parent 和 $children，它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\"></span><br><span class=\"line\">this.$children[0].xx = xx;</span><br></pre></td></tr></table></figure>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"$refs\"></a>$refs</h3><p>$refs可以创建一个子元素或者子组件的引用，使用$refs可以很方便的调用子组件的方法或者获取子组件的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            focus() &#123;</span><br><span class=\"line\">              this.$refs.usernameInput.focus();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;input ref=&quot;input&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            focus: function () &#123;</span><br><span class=\"line\">                this.$refs.input.focus()</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"attrs和-listeners\"><a href=\"#attrs和-listeners\" class=\"headerlink\" title=\"$attrs和$listeners\"></a>$attrs和$listeners</h3><p>$attrs中包含了父组件传入子组件，且未在子组件props中定义的属性（class和style除外），$attrs会被自动添加到子组件的根元素上，如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//子组件</span><br><span class=\"line\">Vue.component(&apos;base-input&apos;, &#123;</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  props: [&apos;label&apos;, &apos;value&apos;],</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      &#123;&#123; label &#125;&#125;</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        v-bind=&quot;$attrs&quot;</span><br><span class=\"line\">        v-bind:value=&quot;value&quot;</span><br><span class=\"line\">        v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;base-input</span><br><span class=\"line\">  v-model=&quot;username&quot;</span><br><span class=\"line\">  required</span><br><span class=\"line\">  placeholder=&quot;Enter your username&quot;</span><br><span class=\"line\">&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n<p>同理，$listeners可以将父组件传入的所有事件监听函数指向子组件的某个特定的子元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;base-input&apos;, &#123;</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  props: [&apos;label&apos;, &apos;value&apos;],</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    inputListeners: function () &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      return Object.assign(&#123;&#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          input: function (event) &#123;</span><br><span class=\"line\">            vm.$emit(&apos;input&apos;, event.target.value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      &#123;&#123; label &#125;&#125;</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        v-bind=&quot;$attrs&quot;</span><br><span class=\"line\">        v-bind:value=&quot;value&quot;</span><br><span class=\"line\">        v-on=&quot;inputListeners&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"provide-inject\"><a href=\"#provide-inject\" class=\"headerlink\" title=\"provide/inject\"></a>provide/inject</h3><p>provide和inject是Vue中依赖注入的实现，provide 选项允许我们指定我们想要提供给后代组件的数据/方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 提供数据的组件</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  provide() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      form: this</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在组件上的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  inject: [&quot;form&quot;],</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    validate() &#123;</span><br><span class=\"line\">      console.log(this.form);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Vue官方的状态管理库-Vuex的原理也是使用了provide/inject。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上述就是Vue中的组件通信方案，不同的方案适用场景不同，没有银弹，在项目开发中，需要根据项目需求来选择适合的方案。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>组件是现代前端框架最强大的功能，但是组件的作用域是相互独立的，那么不同组件之间如何传递数据呢？</p>\n</blockquote>\n<p><img src=\"http://img.yanyuanfe.cn/vue.png\" alt=\"image\"></p>","more":"<p>为了构建大型Web应用，现代前端框架都引入了组件系统，将模版和逻辑抽象为可复用的组件，可以提高项目的开发效率和可维护性。而组件间的通信一直是一个老生常谈的问题，今天来讨论一下Vue中的组件通信。</p>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><p>通过props可以实现父组件向子组件传递数据，prop是定义在组件上的一些自定义属性，需要提前在子组件中的props声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        name: &apos;Confirm&apos;,</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            text: &#123;</span><br><span class=\"line\">                type: String,</span><br><span class=\"line\">                default: &apos;&apos;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;confirm :text=&quot;文字&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h3><p>通过自定义事件的方式可以在子组件中向父组件传递数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;confirm&quot;&gt;Click&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        name: &apos;Confirm&apos;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            confirm() &#123;</span><br><span class=\"line\">              this.$emit(&apos;confirm&apos;,&quot;data&quot;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;confirm @confirm=&quot;handleConfirm&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            confirm(data) &#123;</span><br><span class=\"line\">              console.log(data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>子组件使用this.$emit可以触发自定义事件，第一个参数是自定义事件名称，第二个参数为传递的参数（可选）。父组件使用@监听子组件的自定义事件。</p>\n<h3 id=\"事件总线\"><a href=\"#事件总线\" class=\"headerlink\" title=\"事件总线\"></a>事件总线</h3><p>props只适用于父子组件之间数据的传递，兄弟组件之间的通信可以使用eventBus的方式，具体使用方式如下：</p>\n<p>新建eventBus.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;;  </span><br><span class=\"line\">export default new Vue();</span><br></pre></td></tr></table></figure>\n<p>触发事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import eventBus from &apos;./eventBus.js&apos;; </span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       eventBus.$emit(&apos;clickEvent&apos;, event.target);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import eventBus from &apos;./eventBus.js&apos;; </span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       eventBus.$on(&apos;clickEvent&apos;, (data) =&gt; &#123;</span><br><span class=\"line\">           console.log(data);</span><br><span class=\"line\">       &#125;);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>eventBus的方法实现了一个全局的状态管理，在任意组件之间都能非常便捷的传递数据。</p>\n<h3 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h3><p>在大型Web应用中，上述组件通信方式已经不能很好的满足实际的需求，Vue官网提供了一个全局状态管理库：Vuex。具体可参考官方文档。</p>\n<h3 id=\"root和-parent\"><a href=\"#root和-parent\" class=\"headerlink\" title=\"$root和$parent\"></a>$root和$parent</h3><p>在每个 new Vue 实例的子组件中，其根实例可以通过 $root property 进行访问。<br>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。<br>和 $root 类似，$parent 可以用来从一个子组件访问父组件的实例。因此可以利用$root或者$root作为桥梁在子组件之间传递数据。</p>\n<p>触发事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       this.$root.$emit(&apos;clickEvent&apos;, event.target);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听事件的组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">methods: &#123;  </span><br><span class=\"line\">   onClick(event) &#123;  </span><br><span class=\"line\">       this.$root.$on(&apos;clickEvent&apos;, (data) =&gt; &#123;</span><br><span class=\"line\">           console.log(data);</span><br><span class=\"line\">       &#125;);   </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"children\"><a href=\"#children\" class=\"headerlink\" title=\"$children\"></a>$children</h3><p>父组件也可以使用$children来访问子组件实现父子组件的通信。</p>\n<p>this.$children是当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。</p>\n<blockquote>\n<p>慎重使用 $parent 和 $children，它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\"></span><br><span class=\"line\">this.$children[0].xx = xx;</span><br></pre></td></tr></table></figure>\n<h3 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"$refs\"></a>$refs</h3><p>$refs可以创建一个子元素或者子组件的引用，使用$refs可以很方便的调用子组件的方法或者获取子组件的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            focus() &#123;</span><br><span class=\"line\">              this.$refs.usernameInput.focus();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;input ref=&quot;input&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            focus: function () &#123;</span><br><span class=\"line\">                this.$refs.input.focus()</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"attrs和-listeners\"><a href=\"#attrs和-listeners\" class=\"headerlink\" title=\"$attrs和$listeners\"></a>$attrs和$listeners</h3><p>$attrs中包含了父组件传入子组件，且未在子组件props中定义的属性（class和style除外），$attrs会被自动添加到子组件的根元素上，如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//子组件</span><br><span class=\"line\">Vue.component(&apos;base-input&apos;, &#123;</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  props: [&apos;label&apos;, &apos;value&apos;],</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      &#123;&#123; label &#125;&#125;</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        v-bind=&quot;$attrs&quot;</span><br><span class=\"line\">        v-bind:value=&quot;value&quot;</span><br><span class=\"line\">        v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//父组件</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;base-input</span><br><span class=\"line\">  v-model=&quot;username&quot;</span><br><span class=\"line\">  required</span><br><span class=\"line\">  placeholder=&quot;Enter your username&quot;</span><br><span class=\"line\">&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n<p>同理，$listeners可以将父组件传入的所有事件监听函数指向子组件的某个特定的子元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;base-input&apos;, &#123;</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  props: [&apos;label&apos;, &apos;value&apos;],</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    inputListeners: function () &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      return Object.assign(&#123;&#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          input: function (event) &#123;</span><br><span class=\"line\">            vm.$emit(&apos;input&apos;, event.target.value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      &#123;&#123; label &#125;&#125;</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        v-bind=&quot;$attrs&quot;</span><br><span class=\"line\">        v-bind:value=&quot;value&quot;</span><br><span class=\"line\">        v-on=&quot;inputListeners&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"provide-inject\"><a href=\"#provide-inject\" class=\"headerlink\" title=\"provide/inject\"></a>provide/inject</h3><p>provide和inject是Vue中依赖注入的实现，provide 选项允许我们指定我们想要提供给后代组件的数据/方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 提供数据的组件</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  provide() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      form: this</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在组件上的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  inject: [&quot;form&quot;],</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    validate() &#123;</span><br><span class=\"line\">      console.log(this.form);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>Vue官方的状态管理库-Vuex的原理也是使用了provide/inject。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上述就是Vue中的组件通信方案，不同的方案适用场景不同，没有银弹，在项目开发中，需要根据项目需求来选择适合的方案。</p>"},{"title":"读《前端架构设计》——我眼中的前端架构","date":"2017-05-26T04:23:16.000Z","banner":"http://img.yanyuanfe.cn/v2-03019bdb72b41a18f0b0bb9390d7c208_r.jpg","_content":"\n> 多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。\n\n<!--more-->\n\n最近刚读完《前端架构设计》这本书，收获颇丰，谈谈几点理解。  \n\n本书主要结合作者在参与RedHat项目的网站架构经历，介绍了前端架构的原则和核心，并围绕着前端架构的四个核心：代码、流程、测试、文档，针对每一部分进行了深入的探讨并提出了相应的实践方案。作为一个刚工作不久的前端新手，书中详细地介绍了前端架构的职责和使命，其中介绍的一些工具和概念之前都未听说过，读完之后也增加了我的见识，对于自己的职业规划也有了更加清晰的认识。  \n\n前端是近年来一个新兴的职业，在Web开发的早期，前端一直被认为是低端的名词，“切图仔、美工、网页设计师......”，从这些名词中，你可以想象到早期的“前端”的工作内容。架构从何而来？后来，在前后端一体的时代，“前端”写页面模板，后端读取模板，生成静态页面发送给浏览器渲染，那时的架构是后端架构，采用的是后端MVC模式，前端只是MVC的V层。随着Web2.0时代的到来，前端开始从刀耕火种的蛮荒时代向现代的工程化方向演进，前后端分离，前端开始慢慢建立完善的流程和体系，前端架构开始出现。  \n\n架构的本质是什么？有人说是管理，对机器和代码的管理，那么前端架构是管理什么呢？\n读完本书你就知道，前端架构是对代码、流程、测试、文档的管理，最终目的是实现高效、可持续的工作流。架构师的职责是遵循前端架构的原则，开发和完善各种开发工具、自动化工作流，设计项目架构，提高整个团队的开发效率，让团队成员可以更好的协同工作。\n\n### 代码\n\n从代码的管理来说，前端代码主要包括HTML、CSS、JavaScript，前端架构的职责是建立代码规范、提高代码质量，让代码更加健壮。下面列举几点我的理解：\n- 1、HTML语义化\n- 2、OOCSS、ACSS、BEM、SMACSS，WTFCSS？你值得拥有\n- 3、采用LESS、SASS、PostCSS对CSS进行处理\n- 4、使用ESLint进行代码检查，墙裂推荐\n\n### 流程\n\n从流程管理来讲，前端架构的职责是明确前端开发的各个环节，从需求分析到原型设计，到具体的代码提交和测试，再到最终的部署和维护。在自动化和工程化日益完善的前端领域，你可以采用更先进的方法。通过设计更加完善细致的自动化流程，才能构建出更加高效、更加健壮和可扩展的应用。具体来说，包括工作流设计、团队协作工具、构建工具、持续集成等等。下面是我的几点理解：\n- 1、需求面向整个项目参与者：设计、后端、前端\n- 2、Git进行团队协作\n- 3、采用Grunt、Gulp、Webpack、NPM等自动化构建工具\n- 4、使用Jenkins、Travis CI等服务进行持续集成\n- 5、框架选型  \n\n自动化构建工具的出现有效地解决了前端开发中的效率问题，至于工具的选择，前端架构需要调研每种工具的特点，评估其优点和缺点，根据项目的需求选择更加适合的工具。同样，框架选型也是如此，Angular、React、Vue等MVVM框架一时炙手可热，在项目的技术选型时，必须对整个技术架构考虑周全，包括可扩展性、可测试性等等。所谓框架，只是帮助我们解决问题的工具，提高开发效率，我们需要的是学习框架的思想，不要过度依赖框架。框架的选择要根据适当的业务场景，如果Jquery最适合当前的业务，那就是最好的选择。前端架构师的工作就是不断探索和评估新的技术、平台、方法和框架。\n\n### 测试\n\n从测试管理来讲，前端架构师的职责是通过构建完整的测试来把控网站和设计系统的开发，测试避免了架构师对整个应用的代码进行检查，而是使用各种测试工具来验证应用程序是否正常工作。前端测试一般包括单元测试、集成测试、视觉还原测试、E2E测试等等，其实很多公司的前端是不会写测试用例的，或者很少，可能是繁忙的业务导致没有时间写测试，但是，事实证明，写测试用例的时间是值得的，写测试可以在提交代码之前验证你的代码是否是符合预期的。与测试相关的另外一个概念是测试覆盖率，测试覆盖率反映本次测试的函数或语句被测试到的比例。通过写测试还可以提高开发人员书写函数的健壮性。下面是我的几点理解：\n- 1、编写测试用例，进行自动化单元测试\n- 2、从各方面进行性能优化\n- 3、确认所需的测试覆盖率\n- 4、评估前端测试的标准\n\n### 文档\n\n对于文档管理，前端架构的职责是建立开发的文档并在项目开发过程中进行输出，所谓文档，就像Github项目的README一样，一个优秀的项目应该有完善的文档说明。同样，在团队项目中，特别是人员流动较为频繁的项目，更加应该建立完善的文档说明。此外，文档用来总结项目的踩坑经验，避免产生重复的工作量有很大的作用。下面是我的几点理解：\n- 1、采用Hologram、SassDoc等自动化文档生成工具\n- 2、建立项目Wiki，记录踩坑经验\n\n### 总结\n\n如书中所言，“对于任何优秀的架构而言，只要未到最后一刻，你的工作就不会结束。”只要需求变化，项目变得复杂，那么架构也会发生变化。一个优秀的架构师的工作就是搭建一个解决问题的框架，让团队成员能在框架下进行协同工作，完成项目开发需求。  \n\n在别处看到这样一句话，与诸君共勉。“多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。”","source":"_posts/读《前端架构设计》——我眼中的前端架构.md","raw":"---\ntitle: 读《前端架构设计》——我眼中的前端架构\ndate: 2017-05-26 12:23:16\ncategories: 前端\nbanner: http://img.yanyuanfe.cn/v2-03019bdb72b41a18f0b0bb9390d7c208_r.jpg\ntags:\n\t- 架构\n---\n\n> 多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。\n\n<!--more-->\n\n最近刚读完《前端架构设计》这本书，收获颇丰，谈谈几点理解。  \n\n本书主要结合作者在参与RedHat项目的网站架构经历，介绍了前端架构的原则和核心，并围绕着前端架构的四个核心：代码、流程、测试、文档，针对每一部分进行了深入的探讨并提出了相应的实践方案。作为一个刚工作不久的前端新手，书中详细地介绍了前端架构的职责和使命，其中介绍的一些工具和概念之前都未听说过，读完之后也增加了我的见识，对于自己的职业规划也有了更加清晰的认识。  \n\n前端是近年来一个新兴的职业，在Web开发的早期，前端一直被认为是低端的名词，“切图仔、美工、网页设计师......”，从这些名词中，你可以想象到早期的“前端”的工作内容。架构从何而来？后来，在前后端一体的时代，“前端”写页面模板，后端读取模板，生成静态页面发送给浏览器渲染，那时的架构是后端架构，采用的是后端MVC模式，前端只是MVC的V层。随着Web2.0时代的到来，前端开始从刀耕火种的蛮荒时代向现代的工程化方向演进，前后端分离，前端开始慢慢建立完善的流程和体系，前端架构开始出现。  \n\n架构的本质是什么？有人说是管理，对机器和代码的管理，那么前端架构是管理什么呢？\n读完本书你就知道，前端架构是对代码、流程、测试、文档的管理，最终目的是实现高效、可持续的工作流。架构师的职责是遵循前端架构的原则，开发和完善各种开发工具、自动化工作流，设计项目架构，提高整个团队的开发效率，让团队成员可以更好的协同工作。\n\n### 代码\n\n从代码的管理来说，前端代码主要包括HTML、CSS、JavaScript，前端架构的职责是建立代码规范、提高代码质量，让代码更加健壮。下面列举几点我的理解：\n- 1、HTML语义化\n- 2、OOCSS、ACSS、BEM、SMACSS，WTFCSS？你值得拥有\n- 3、采用LESS、SASS、PostCSS对CSS进行处理\n- 4、使用ESLint进行代码检查，墙裂推荐\n\n### 流程\n\n从流程管理来讲，前端架构的职责是明确前端开发的各个环节，从需求分析到原型设计，到具体的代码提交和测试，再到最终的部署和维护。在自动化和工程化日益完善的前端领域，你可以采用更先进的方法。通过设计更加完善细致的自动化流程，才能构建出更加高效、更加健壮和可扩展的应用。具体来说，包括工作流设计、团队协作工具、构建工具、持续集成等等。下面是我的几点理解：\n- 1、需求面向整个项目参与者：设计、后端、前端\n- 2、Git进行团队协作\n- 3、采用Grunt、Gulp、Webpack、NPM等自动化构建工具\n- 4、使用Jenkins、Travis CI等服务进行持续集成\n- 5、框架选型  \n\n自动化构建工具的出现有效地解决了前端开发中的效率问题，至于工具的选择，前端架构需要调研每种工具的特点，评估其优点和缺点，根据项目的需求选择更加适合的工具。同样，框架选型也是如此，Angular、React、Vue等MVVM框架一时炙手可热，在项目的技术选型时，必须对整个技术架构考虑周全，包括可扩展性、可测试性等等。所谓框架，只是帮助我们解决问题的工具，提高开发效率，我们需要的是学习框架的思想，不要过度依赖框架。框架的选择要根据适当的业务场景，如果Jquery最适合当前的业务，那就是最好的选择。前端架构师的工作就是不断探索和评估新的技术、平台、方法和框架。\n\n### 测试\n\n从测试管理来讲，前端架构师的职责是通过构建完整的测试来把控网站和设计系统的开发，测试避免了架构师对整个应用的代码进行检查，而是使用各种测试工具来验证应用程序是否正常工作。前端测试一般包括单元测试、集成测试、视觉还原测试、E2E测试等等，其实很多公司的前端是不会写测试用例的，或者很少，可能是繁忙的业务导致没有时间写测试，但是，事实证明，写测试用例的时间是值得的，写测试可以在提交代码之前验证你的代码是否是符合预期的。与测试相关的另外一个概念是测试覆盖率，测试覆盖率反映本次测试的函数或语句被测试到的比例。通过写测试还可以提高开发人员书写函数的健壮性。下面是我的几点理解：\n- 1、编写测试用例，进行自动化单元测试\n- 2、从各方面进行性能优化\n- 3、确认所需的测试覆盖率\n- 4、评估前端测试的标准\n\n### 文档\n\n对于文档管理，前端架构的职责是建立开发的文档并在项目开发过程中进行输出，所谓文档，就像Github项目的README一样，一个优秀的项目应该有完善的文档说明。同样，在团队项目中，特别是人员流动较为频繁的项目，更加应该建立完善的文档说明。此外，文档用来总结项目的踩坑经验，避免产生重复的工作量有很大的作用。下面是我的几点理解：\n- 1、采用Hologram、SassDoc等自动化文档生成工具\n- 2、建立项目Wiki，记录踩坑经验\n\n### 总结\n\n如书中所言，“对于任何优秀的架构而言，只要未到最后一刻，你的工作就不会结束。”只要需求变化，项目变得复杂，那么架构也会发生变化。一个优秀的架构师的工作就是搭建一个解决问题的框架，让团队成员能在框架下进行协同工作，完成项目开发需求。  \n\n在别处看到这样一句话，与诸君共勉。“多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。”","slug":"读《前端架构设计》——我眼中的前端架构","published":1,"updated":"2020-07-16T13:56:47.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3pcenoo0030p70vosnbpjyw","content":"<blockquote>\n<p>多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>最近刚读完《前端架构设计》这本书，收获颇丰，谈谈几点理解。  </p>\n<p>本书主要结合作者在参与RedHat项目的网站架构经历，介绍了前端架构的原则和核心，并围绕着前端架构的四个核心：代码、流程、测试、文档，针对每一部分进行了深入的探讨并提出了相应的实践方案。作为一个刚工作不久的前端新手，书中详细地介绍了前端架构的职责和使命，其中介绍的一些工具和概念之前都未听说过，读完之后也增加了我的见识，对于自己的职业规划也有了更加清晰的认识。  </p>\n<p>前端是近年来一个新兴的职业，在Web开发的早期，前端一直被认为是低端的名词，“切图仔、美工、网页设计师……”，从这些名词中，你可以想象到早期的“前端”的工作内容。架构从何而来？后来，在前后端一体的时代，“前端”写页面模板，后端读取模板，生成静态页面发送给浏览器渲染，那时的架构是后端架构，采用的是后端MVC模式，前端只是MVC的V层。随着Web2.0时代的到来，前端开始从刀耕火种的蛮荒时代向现代的工程化方向演进，前后端分离，前端开始慢慢建立完善的流程和体系，前端架构开始出现。  </p>\n<p>架构的本质是什么？有人说是管理，对机器和代码的管理，那么前端架构是管理什么呢？<br>读完本书你就知道，前端架构是对代码、流程、测试、文档的管理，最终目的是实现高效、可持续的工作流。架构师的职责是遵循前端架构的原则，开发和完善各种开发工具、自动化工作流，设计项目架构，提高整个团队的开发效率，让团队成员可以更好的协同工作。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>从代码的管理来说，前端代码主要包括HTML、CSS、JavaScript，前端架构的职责是建立代码规范、提高代码质量，让代码更加健壮。下面列举几点我的理解：</p>\n<ul>\n<li>1、HTML语义化</li>\n<li>2、OOCSS、ACSS、BEM、SMACSS，WTFCSS？你值得拥有</li>\n<li>3、采用LESS、SASS、PostCSS对CSS进行处理</li>\n<li>4、使用ESLint进行代码检查，墙裂推荐</li>\n</ul>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><p>从流程管理来讲，前端架构的职责是明确前端开发的各个环节，从需求分析到原型设计，到具体的代码提交和测试，再到最终的部署和维护。在自动化和工程化日益完善的前端领域，你可以采用更先进的方法。通过设计更加完善细致的自动化流程，才能构建出更加高效、更加健壮和可扩展的应用。具体来说，包括工作流设计、团队协作工具、构建工具、持续集成等等。下面是我的几点理解：</p>\n<ul>\n<li>1、需求面向整个项目参与者：设计、后端、前端</li>\n<li>2、Git进行团队协作</li>\n<li>3、采用Grunt、Gulp、Webpack、NPM等自动化构建工具</li>\n<li>4、使用Jenkins、Travis CI等服务进行持续集成</li>\n<li>5、框架选型  </li>\n</ul>\n<p>自动化构建工具的出现有效地解决了前端开发中的效率问题，至于工具的选择，前端架构需要调研每种工具的特点，评估其优点和缺点，根据项目的需求选择更加适合的工具。同样，框架选型也是如此，Angular、React、Vue等MVVM框架一时炙手可热，在项目的技术选型时，必须对整个技术架构考虑周全，包括可扩展性、可测试性等等。所谓框架，只是帮助我们解决问题的工具，提高开发效率，我们需要的是学习框架的思想，不要过度依赖框架。框架的选择要根据适当的业务场景，如果Jquery最适合当前的业务，那就是最好的选择。前端架构师的工作就是不断探索和评估新的技术、平台、方法和框架。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>从测试管理来讲，前端架构师的职责是通过构建完整的测试来把控网站和设计系统的开发，测试避免了架构师对整个应用的代码进行检查，而是使用各种测试工具来验证应用程序是否正常工作。前端测试一般包括单元测试、集成测试、视觉还原测试、E2E测试等等，其实很多公司的前端是不会写测试用例的，或者很少，可能是繁忙的业务导致没有时间写测试，但是，事实证明，写测试用例的时间是值得的，写测试可以在提交代码之前验证你的代码是否是符合预期的。与测试相关的另外一个概念是测试覆盖率，测试覆盖率反映本次测试的函数或语句被测试到的比例。通过写测试还可以提高开发人员书写函数的健壮性。下面是我的几点理解：</p>\n<ul>\n<li>1、编写测试用例，进行自动化单元测试</li>\n<li>2、从各方面进行性能优化</li>\n<li>3、确认所需的测试覆盖率</li>\n<li>4、评估前端测试的标准</li>\n</ul>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>对于文档管理，前端架构的职责是建立开发的文档并在项目开发过程中进行输出，所谓文档，就像Github项目的README一样，一个优秀的项目应该有完善的文档说明。同样，在团队项目中，特别是人员流动较为频繁的项目，更加应该建立完善的文档说明。此外，文档用来总结项目的踩坑经验，避免产生重复的工作量有很大的作用。下面是我的几点理解：</p>\n<ul>\n<li>1、采用Hologram、SassDoc等自动化文档生成工具</li>\n<li>2、建立项目Wiki，记录踩坑经验</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如书中所言，“对于任何优秀的架构而言，只要未到最后一刻，你的工作就不会结束。”只要需求变化，项目变得复杂，那么架构也会发生变化。一个优秀的架构师的工作就是搭建一个解决问题的框架，让团队成员能在框架下进行协同工作，完成项目开发需求。  </p>\n<p>在别处看到这样一句话，与诸君共勉。“多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。”</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。</p>\n</blockquote>","more":"<p>最近刚读完《前端架构设计》这本书，收获颇丰，谈谈几点理解。  </p>\n<p>本书主要结合作者在参与RedHat项目的网站架构经历，介绍了前端架构的原则和核心，并围绕着前端架构的四个核心：代码、流程、测试、文档，针对每一部分进行了深入的探讨并提出了相应的实践方案。作为一个刚工作不久的前端新手，书中详细地介绍了前端架构的职责和使命，其中介绍的一些工具和概念之前都未听说过，读完之后也增加了我的见识，对于自己的职业规划也有了更加清晰的认识。  </p>\n<p>前端是近年来一个新兴的职业，在Web开发的早期，前端一直被认为是低端的名词，“切图仔、美工、网页设计师……”，从这些名词中，你可以想象到早期的“前端”的工作内容。架构从何而来？后来，在前后端一体的时代，“前端”写页面模板，后端读取模板，生成静态页面发送给浏览器渲染，那时的架构是后端架构，采用的是后端MVC模式，前端只是MVC的V层。随着Web2.0时代的到来，前端开始从刀耕火种的蛮荒时代向现代的工程化方向演进，前后端分离，前端开始慢慢建立完善的流程和体系，前端架构开始出现。  </p>\n<p>架构的本质是什么？有人说是管理，对机器和代码的管理，那么前端架构是管理什么呢？<br>读完本书你就知道，前端架构是对代码、流程、测试、文档的管理，最终目的是实现高效、可持续的工作流。架构师的职责是遵循前端架构的原则，开发和完善各种开发工具、自动化工作流，设计项目架构，提高整个团队的开发效率，让团队成员可以更好的协同工作。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>从代码的管理来说，前端代码主要包括HTML、CSS、JavaScript，前端架构的职责是建立代码规范、提高代码质量，让代码更加健壮。下面列举几点我的理解：</p>\n<ul>\n<li>1、HTML语义化</li>\n<li>2、OOCSS、ACSS、BEM、SMACSS，WTFCSS？你值得拥有</li>\n<li>3、采用LESS、SASS、PostCSS对CSS进行处理</li>\n<li>4、使用ESLint进行代码检查，墙裂推荐</li>\n</ul>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><p>从流程管理来讲，前端架构的职责是明确前端开发的各个环节，从需求分析到原型设计，到具体的代码提交和测试，再到最终的部署和维护。在自动化和工程化日益完善的前端领域，你可以采用更先进的方法。通过设计更加完善细致的自动化流程，才能构建出更加高效、更加健壮和可扩展的应用。具体来说，包括工作流设计、团队协作工具、构建工具、持续集成等等。下面是我的几点理解：</p>\n<ul>\n<li>1、需求面向整个项目参与者：设计、后端、前端</li>\n<li>2、Git进行团队协作</li>\n<li>3、采用Grunt、Gulp、Webpack、NPM等自动化构建工具</li>\n<li>4、使用Jenkins、Travis CI等服务进行持续集成</li>\n<li>5、框架选型  </li>\n</ul>\n<p>自动化构建工具的出现有效地解决了前端开发中的效率问题，至于工具的选择，前端架构需要调研每种工具的特点，评估其优点和缺点，根据项目的需求选择更加适合的工具。同样，框架选型也是如此，Angular、React、Vue等MVVM框架一时炙手可热，在项目的技术选型时，必须对整个技术架构考虑周全，包括可扩展性、可测试性等等。所谓框架，只是帮助我们解决问题的工具，提高开发效率，我们需要的是学习框架的思想，不要过度依赖框架。框架的选择要根据适当的业务场景，如果Jquery最适合当前的业务，那就是最好的选择。前端架构师的工作就是不断探索和评估新的技术、平台、方法和框架。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>从测试管理来讲，前端架构师的职责是通过构建完整的测试来把控网站和设计系统的开发，测试避免了架构师对整个应用的代码进行检查，而是使用各种测试工具来验证应用程序是否正常工作。前端测试一般包括单元测试、集成测试、视觉还原测试、E2E测试等等，其实很多公司的前端是不会写测试用例的，或者很少，可能是繁忙的业务导致没有时间写测试，但是，事实证明，写测试用例的时间是值得的，写测试可以在提交代码之前验证你的代码是否是符合预期的。与测试相关的另外一个概念是测试覆盖率，测试覆盖率反映本次测试的函数或语句被测试到的比例。通过写测试还可以提高开发人员书写函数的健壮性。下面是我的几点理解：</p>\n<ul>\n<li>1、编写测试用例，进行自动化单元测试</li>\n<li>2、从各方面进行性能优化</li>\n<li>3、确认所需的测试覆盖率</li>\n<li>4、评估前端测试的标准</li>\n</ul>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p>对于文档管理，前端架构的职责是建立开发的文档并在项目开发过程中进行输出，所谓文档，就像Github项目的README一样，一个优秀的项目应该有完善的文档说明。同样，在团队项目中，特别是人员流动较为频繁的项目，更加应该建立完善的文档说明。此外，文档用来总结项目的踩坑经验，避免产生重复的工作量有很大的作用。下面是我的几点理解：</p>\n<ul>\n<li>1、采用Hologram、SassDoc等自动化文档生成工具</li>\n<li>2、建立项目Wiki，记录踩坑经验</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如书中所言，“对于任何优秀的架构而言，只要未到最后一刻，你的工作就不会结束。”只要需求变化，项目变得复杂，那么架构也会发生变化。一个优秀的架构师的工作就是搭建一个解决问题的框架，让团队成员能在框架下进行协同工作，完成项目开发需求。  </p>\n<p>在别处看到这样一句话，与诸君共勉。“多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。”</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl3pcenmr0000p70vytkzlstx","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenna000ep70vbcovx6jf"},{"post_id":"cl3pcenmw0002p70vpz91dvbe","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenne000jp70vrhzxp69j"},{"post_id":"cl3pcennb000hp70v2rc8n6bd","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenni000op70vwqb0yrk3"},{"post_id":"cl3pcennk000sp70v6j1n2mis","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcennp000yp70vxrkhpb6y"},{"post_id":"cl3pcenno000xp70vanv4u6ls","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcennu0016p70vbhdco3nh"},{"post_id":"cl3pcennt0015p70vjbd2epgs","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenny001dp70vfbgooyha"},{"post_id":"cl3pcennw001ap70vclrxis0d","category_id":"cl3pcennz001ep70vxy5mz8xr","_id":"cl3pceno8001sp70vyku33atw"},{"post_id":"cl3pcenny001cp70vceh7m3ft","category_id":"cl3pcennz001ep70vxy5mz8xr","_id":"cl3pcenoa001yp70v2qg3qv5n"},{"post_id":"cl3pceno9001up70vpq6f2i8b","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenod0024p70vdn3vid31"},{"post_id":"cl3pcenob0020p70vld9itxio","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenof002ap70vnzcnfdhh"},{"post_id":"cl3pcenoc0023p70vnknf8rxo","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenog002dp70vuvz344ba"},{"post_id":"cl3pcenod0026p70vmsyiv666","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenoh002gp70vtq6kmosk"},{"post_id":"cl3pcenog002cp70vqhjpj5uz","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenoj002mp70vtcqn5qtd"},{"post_id":"cl3pcenoh002fp70v462tv2oc","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenol002qp70v22s58f2u"},{"post_id":"cl3pcenoo0030p70vosnbpjyw","category_id":"cl3pcenmy0004p70v8rwfun5q","_id":"cl3pcenoq0035p70v584yjvj5"}],"PostTag":[{"post_id":"cl3pcenmr0000p70vytkzlstx","tag_id":"cl3pcenn00005p70vsoar0nrq","_id":"cl3pcenn6000bp70vprp81yiz"},{"post_id":"cl3pcenmw0002p70vpz91dvbe","tag_id":"cl3pcenn00005p70vsoar0nrq","_id":"cl3pcenna000gp70vsjfqxzc9"},{"post_id":"cl3pcenn00006p70vl06af9fb","tag_id":"cl3pcenna000fp70v5kra8iwq","_id":"cl3pcennh000mp70vfgtewb0j"},{"post_id":"cl3pcenn20007p70vz70650lb","tag_id":"cl3pcenne000kp70vk98t68fl","_id":"cl3pcennk000rp70v8n924icr"},{"post_id":"cl3pcennk000sp70v6j1n2mis","tag_id":"cl3pcenn00005p70vsoar0nrq","_id":"cl3pcennm000vp70vtohry1n1"},{"post_id":"cl3pcenn30008p70vwa85tt5t","tag_id":"cl3pcennj000pp70vglg7946l","_id":"cl3pcennq0010p70vvm4ufg1m"},{"post_id":"cl3pcenn30008p70vwa85tt5t","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcennr0012p70vmgdnajrb"},{"post_id":"cl3pcenn6000cp70volk8gi7z","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pcennu0017p70vzvy7ee9b"},{"post_id":"cl3pcenn9000dp70vxjkcbkax","tag_id":"cl3pcennt0014p70v8o0x4d9m","_id":"cl3pcennx001bp70vzq6ufn2d"},{"post_id":"cl3pcennb000hp70v2rc8n6bd","tag_id":"cl3pcennw0019p70v0r2k9q6x","_id":"cl3pceno3001hp70v74r8d3yw"},{"post_id":"cl3pcennz001gp70vd1d6lrks","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pceno4001jp70vsgxyvhbv"},{"post_id":"cl3pcennz001gp70vd1d6lrks","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pceno6001np70vsomcluap"},{"post_id":"cl3pcennf000lp70vqomkjlx5","tag_id":"cl3pcennt0014p70v8o0x4d9m","_id":"cl3pceno7001pp70vmy6gr1fg"},{"post_id":"cl3pceno3001ip70vds5mopj6","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pceno9001tp70vr9ej7fg5"},{"post_id":"cl3pceno3001ip70vds5mopj6","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenoa001vp70v6hefz6z2"},{"post_id":"cl3pceno5001lp70vokye770c","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pcenob001zp70vmvndq5qf"},{"post_id":"cl3pceno5001lp70vokye770c","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenoc0021p70vcjd7x30h"},{"post_id":"cl3pceno6001op70vu7loukna","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pcenod0025p70v1uyu0lgy"},{"post_id":"cl3pceno6001op70vu7loukna","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenoe0027p70vf3qhv1wp"},{"post_id":"cl3pceno8001rp70vvtnb1oqt","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pcenof002bp70v10t9tyk0"},{"post_id":"cl3pceno8001rp70vvtnb1oqt","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenog002ep70vu5blwqhm"},{"post_id":"cl3pcennh000np70v7vtxm5xw","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pcenoi002ip70vrkdl14ek"},{"post_id":"cl3pcennh000np70v7vtxm5xw","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenoj002kp70vp8rbvywt"},{"post_id":"cl3pcennj000qp70vow0hbt43","tag_id":"cl3pcennt0014p70v8o0x4d9m","_id":"cl3pcenok002op70v4shy552c"},{"post_id":"cl3pcenoh002fp70v462tv2oc","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenol002rp70v6fsgfif4"},{"post_id":"cl3pcenoi002jp70vclamd016","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenom002up70v2pb9q5jl"},{"post_id":"cl3pcenoi002jp70vclamd016","tag_id":"cl3pcennq000zp70vprkzah0l","_id":"cl3pcenon002wp70vb34r6vjv"},{"post_id":"cl3pcennl000up70vjy59qj23","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenoo002zp70vaevgal0a"},{"post_id":"cl3pcennl000up70vjy59qj23","tag_id":"cl3pcenoe0028p70v37cyl9t5","_id":"cl3pcenop0031p70vnnuk7onj"},{"post_id":"cl3pcennl000up70vjy59qj23","tag_id":"cl3pcennt0014p70v8o0x4d9m","_id":"cl3pcenop0032p70v6fsl80it"},{"post_id":"cl3pcenok002pp70v7iufl5on","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenoq0034p70vsrzaxad7"},{"post_id":"cl3pcennn000wp70vrc9ifsgi","tag_id":"cl3pcenoj002np70vvvlw0sa8","_id":"cl3pcenoq0036p70v8y3z0seu"},{"post_id":"cl3pcenol002sp70vymvsy9z0","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenoq0038p70v6oi3gk4l"},{"post_id":"cl3pcenno000xp70vanv4u6ls","tag_id":"cl3pcenom002tp70vj23ne9oq","_id":"cl3pcenor0039p70vnjm7bmta"},{"post_id":"cl3pcennq0011p70vvgnn9bz6","tag_id":"cl3pcenoo002yp70vezajo540","_id":"cl3pcenos003bp70vu8e0cp7c"},{"post_id":"cl3pcenns0013p70vifdugm17","tag_id":"cl3pcenop0033p70v9yaerjwr","_id":"cl3pcenos003cp70vgljt78fe"},{"post_id":"cl3pcennt0015p70vjbd2epgs","tag_id":"cl3pcenoq0037p70v1zqdbdh0","_id":"cl3pcenot003ep70vq6hjsf3z"},{"post_id":"cl3pcennv0018p70vql7t0vf3","tag_id":"cl3pcenor003ap70vvl1dansb","_id":"cl3pcenot003gp70vm8brha8v"},{"post_id":"cl3pcennv0018p70vql7t0vf3","tag_id":"cl3pcenos003dp70v9dv2zfdn","_id":"cl3pcenot003hp70vkcditdtf"},{"post_id":"cl3pcennw001ap70vclrxis0d","tag_id":"cl3pcenot003fp70vpplplzmj","_id":"cl3pcenou003kp70vmrv08sca"},{"post_id":"cl3pcennw001ap70vclrxis0d","tag_id":"cl3pcenot003ip70vhlqvpylj","_id":"cl3pcenou003lp70vaget445a"},{"post_id":"cl3pcenny001cp70vceh7m3ft","tag_id":"cl3pcenou003jp70v2hijemdr","_id":"cl3pcenou003np70vvsiz3hji"},{"post_id":"cl3pceno9001up70vpq6f2i8b","tag_id":"cl3pcenou003mp70vomzm8f0r","_id":"cl3pcenov003pp70v0od09gv2"},{"post_id":"cl3pcenoa001xp70vf8ucgh8b","tag_id":"cl3pcenov003op70v3507phyl","_id":"cl3pcenow003rp70vu0vj0sya"},{"post_id":"cl3pcenob0020p70vld9itxio","tag_id":"cl3pcenoj002np70vvvlw0sa8","_id":"cl3pcenox003tp70vks3wv626"},{"post_id":"cl3pcenoc0023p70vnknf8rxo","tag_id":"cl3pcenoj002np70vvvlw0sa8","_id":"cl3pcenox003vp70v8dbjtzu5"},{"post_id":"cl3pcenod0026p70vmsyiv666","tag_id":"cl3pcenoj002np70vvvlw0sa8","_id":"cl3pcenoy003xp70vvp6ms1cp"},{"post_id":"cl3pcenof0029p70v9mqwbpc7","tag_id":"cl3pcenoj002np70vvvlw0sa8","_id":"cl3pcenoy003zp70v5qqxvhzm"},{"post_id":"cl3pcenog002cp70vqhjpj5uz","tag_id":"cl3pcenoy003yp70v20zdvgww","_id":"cl3pcenoz0041p70vr0f5pdqz"},{"post_id":"cl3pcenoj002lp70v7stkt56z","tag_id":"cl3pcenoz0040p70vw9patw76","_id":"cl3pcenp00044p70vlo7qqjfw"},{"post_id":"cl3pcenoj002lp70v7stkt56z","tag_id":"cl3pcenoz0042p70v0rmf85pu","_id":"cl3pcenp00045p70vprgkgppy"},{"post_id":"cl3pcenom002vp70vvxduvdqt","tag_id":"cl3pcennl000tp70v9q1km7qq","_id":"cl3pcenp00047p70vdrkzyy7x"},{"post_id":"cl3pcenom002vp70vvxduvdqt","tag_id":"cl3pcenoz0043p70v5o3ynej9","_id":"cl3pcenp00048p70vxz1utqag"},{"post_id":"cl3pcenon002xp70v3atbcfzj","tag_id":"cl3pcenp00046p70v79ig85h2","_id":"cl3pcenp1004bp70vtf79s2je"},{"post_id":"cl3pcenon002xp70v3atbcfzj","tag_id":"cl3pcenp00049p70vspj8cu7k","_id":"cl3pcenp1004cp70vqm3yt5q2"},{"post_id":"cl3pcenoo0030p70vosnbpjyw","tag_id":"cl3pcenp1004ap70v597fir39","_id":"cl3pcenp1004dp70v6cokt9ne"}],"Tag":[{"name":"CSS","_id":"cl3pcenn00005p70vsoar0nrq"},{"name":"算法","_id":"cl3pcenna000fp70v5kra8iwq"},{"name":"React Native","_id":"cl3pcenne000kp70vk98t68fl"},{"name":"React Router","_id":"cl3pcennj000pp70vglg7946l"},{"name":"React","_id":"cl3pcennl000tp70v9q1km7qq"},{"name":"Redux","_id":"cl3pcennq000zp70vprkzah0l"},{"name":"Webpack","_id":"cl3pcennt0014p70v8o0x4d9m"},{"name":"Linux","_id":"cl3pcennw0019p70v0r2k9q6x"},{"name":"react-router","_id":"cl3pcenoe0028p70v37cyl9t5"},{"name":"JavaScript","_id":"cl3pcenoj002np70vvvlw0sa8"},{"name":"Node","_id":"cl3pcenom002tp70vj23ne9oq"},{"name":"前端","_id":"cl3pcenoo002yp70vezajo540"},{"name":"HTML5","_id":"cl3pcenop0033p70v9yaerjwr"},{"name":"微信","_id":"cl3pcenoq0037p70v1zqdbdh0"},{"name":"CSS in JS","_id":"cl3pcenor003ap70vvl1dansb"},{"name":"emotion","_id":"cl3pcenos003dp70v9dv2zfdn"},{"name":"杂谈","_id":"cl3pcenot003fp70vpplplzmj"},{"name":"生活","_id":"cl3pcenot003ip70vhlqvpylj"},{"name":"随笔","_id":"cl3pcenou003jp70v2hijemdr"},{"name":"正则","_id":"cl3pcenou003mp70vomzm8f0r"},{"name":"HTTP","_id":"cl3pcenov003op70v3507phyl"},{"name":"ES6","_id":"cl3pcenoy003yp70v20zdvgww"},{"name":"移动端","_id":"cl3pcenoz0040p70vw9patw76"},{"name":"调试","_id":"cl3pcenoz0042p70v0rmf85pu"},{"name":"hooks","_id":"cl3pcenoz0043p70v5o3ynej9"},{"name":"Vue","_id":"cl3pcenp00046p70v79ig85h2"},{"name":"组件","_id":"cl3pcenp00049p70vspj8cu7k"},{"name":"架构","_id":"cl3pcenp1004ap70v597fir39"}]}}